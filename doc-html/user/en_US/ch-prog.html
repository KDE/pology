<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Chapter&nbsp;11.&nbsp;Programming with Pology</title>
<link rel="stylesheet" href="data/style.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="Pology User Manual">
<link rel="up" href="index.html" title="Pology User Manual">
<link rel="prev" href="ch-combined.html" title="Chapter&nbsp;10.&nbsp;Combined Arms Tactics">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr>
<th colspan="3" align="center">Chapter&nbsp;11.&nbsp;Programming with Pology</th>
</tr>
<tr>
<td width="20%" align="left"><a accesskey="p" href="ch-combined.html">Prev</a>&nbsp;</td>
<th width="60%" align="center">&nbsp;</th>
<td width="20%" align="right">&nbsp;</td>
</tr>
</table>
<hr></div>
<div class="chapter">
<div class="titlepage">
<div>
<div>
<h2 class="title"><a name="ch-prog" id="ch-prog"></a>Chapter&nbsp;11.&nbsp;Programming with Pology</h2>
</div>
</div>
</div>
<p>You may find it odd that the user manual contains the section on programming, as that is normally the matter for a separate, programmer-oriented document. On the other hand, while reading the "pure user" sections of this manual, you may have noticed that in Pology the distinction between a user and a programmer is more blurry than one would expect of a translation-related tool. Indeed, before getting into writing standalone Python programs which use the Pology library, there are many places in Pology itself where you can plug in some Python code to adapt the behavior to your language and translation environment. This section exists to support and stimulate such interaction with Pology.</p>
<p>The Pology library is quite simple conceptually and organizationally. It consists of a small core abstraction of the PO format, and a lot of mutually unrelated functionality that may come in handy in particular translation processing scenarios. Everything is covered by <a class="ulink" href="../../api/en_US" target="_top">the Pology API documentation</a>, but since API documentation tends to be non-linear and full of details obstructing the bigger picture, the following subsections are there to provide synthesis and rationale of salient points.</p>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-prfile" id="sec-prfile"></a>11.1.&nbsp;PO Format Abstraction</h2>
</div>
</div>
</div>
<p>The PO format abstraction in Pology is a quite direct and fine-grained reflexion of PO format elements and conventions. This was a design goal from the start; no attempt was made at a more general abstraction, which would tentatively support various translation file formats.</p>
<p>There is, however, one glaring but intentional omission: multi-domain PO files (those which contain <code class="literal">domain "..."</code> directives) are not supported. We had never observed a multi-domain PO file in the wild, nor thought of a significant advantage it could have today over multiple single-domain PO files. Supporting multi-domain PO files would mean not only always needing two nested loops to iterate through messages in a PO file, but it would also interfere with higher levels in Pology which assume equivalence between PO files and domains. Pology will simply report an error when trying to read a multi-domain PO file.</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prflmon" id="sec-prflmon"></a>11.1.1.&nbsp;Monitored Objects</h3>
</div>
</div>
</div>
<p>Because the PO abstraction is intended to be robust against programming errors when quickly writting custom scripts, and frugal on file modifications, by default some of the abstracted objects are "monitored". This means that they are checked for expected data types and have modification counters. Main monitored objects are PO files, PO headers, and PO messages, but also their attributes which are not plain data types (strings or numbers). For the moment, these secondary monitored types include <a class="ulink" href="../../api/en_US/pology.monitored.Monlist-class.html" target="_top"><code class="classname">Monlist</code></a> (the monitored counterpart to built-in <span class="type">list</span>), <a class="ulink" href="../../api/en_US/pology.monitored.Monset-class.html" target="_top"><code class="classname">Monset</code></a> (counterpart to <span class="type">set</span>), and <a class="ulink" href="../../api/en_US/pology.monitored.Monpair-class.html" target="_top"><code class="classname">Monpair</code></a> (like two-element <span class="type">tuple</span>). Monitored types do not in general provide the full scope of functionality of their built-in counterparts, so sometimes it may be easier (and faster) to work with built-in types and convert them to monitored at the moment of adding to PO objects.</p>
<p>To take a <code class="classname">Monlist</code> instance as an example, here is how it behaves on its own:</p>
<pre class="programlisting">
&gt;&gt;&gt; from pology.monitored import Monlist
&gt;&gt;&gt; l = Monlist([u"a", u"b", u"c"])
&gt;&gt;&gt; l.modcount
0
&gt;&gt;&gt; l.append(10)
&gt;&gt;&gt; l
Monlist([u"a", u"b", u"c", 10])
&gt;&gt;&gt; l.modcount
1
&gt;&gt;&gt;
</pre>
<p>Appending an element has caused the modification counter to increase, but, as expected, it was possible to add an integer in spite of previous elements being strings. However, if the monitored list comes from a PO message:</p>
<pre class="programlisting">
&gt;&gt;&gt; from pology.message import Message
&gt;&gt;&gt; msg = Message()
&gt;&gt;&gt; msg.msgstr
Monlist([])
&gt;&gt;&gt; msg.msgstr.append(10)
Traceback (most recent call last):
...
pology.PologyError: Expected &lt;type 'unicode'&gt; for sequence element, got &lt;type 'int'&gt;.
&gt;&gt;&gt; msg.msgstr.append(u"bar")
&gt;&gt;&gt; msg.msgstr.modcount
1
&gt;&gt;&gt; msg.modcount
1
</pre>
<p>The <code class="classname">Message</code> class has type constraints added to its attributes, and therefore addition of an integer to the <code class="varname">.msgstr</code> list was rejected: only <span class="type">unicode</span> values are allowed. This is particularly important due to the basic string type in Python being the raw byte array <span class="type">str</span><sup>[<a name="idp6754464" href="#ftn.idp6754464" class="footnote" id="idp6754464">51</a>]</sup>, to automatically prevent carelessness with encodings. Once a proper string was added to <code class="varname">.msgstr</code> list, its modification counter increased, but also the modification counter of the parent object.</p>
<p>A few more notes on modification counters. Consider this example:</p>
<pre class="programlisting">
&gt;&gt;&gt; msg = Message()
&gt;&gt;&gt; msg.msgstr = Monlist(u"foo")
&gt;&gt;&gt; msg.msgstr.modcount
0
&gt;&gt;&gt; msg.msgstr_modcount
1
&gt;&gt;&gt; msg.modcount
1
&gt;&gt;&gt; msg.msgstr[0] = u"foo"
&gt;&gt;&gt; msg.msgstr.modcount
0
&gt;&gt;&gt; msg.msgstr = Monlist(u"foo")
&gt;&gt;&gt; msg.msgstr_modcount
1
&gt;&gt;&gt; msg.modcount
1
</pre>
<p><code class="literal">Monlist(u"foo")</code> itself is a fresh list with modification counter at 0, so after it was assigned to <code class="varname">msg.msgstr</code>, its modification counter is still 0. However, every attribute of a parent monitored object also has the associated <span class="emphasis"><em>attribute</em></span> modification counter, denoted with trailing <code class="literal">_modcount</code>; therefore <code class="varname">msg.msgstr_modcount</code> did increase on assignment, and so did the parent <code class="varname">msg.modcount</code>. Modification tracking actually checks for equality of values, so when same-valued objects are repeadetly assigned (starting from <code class="literal">msg.msgstr[0] = u"foo"</code> above), modification counters do not increase.</p>
<p>Compound monitored objects may also have the attributes themselves constrained, to prevent typos and other brain glitches from causing mysterious wrong behavior when processing PO files. For example:</p>
<pre class="programlisting">
&gt;&gt;&gt; msg = Message()
&gt;&gt;&gt; msg.msgtsr = Monlist(u"foo")
Traceback (most recent call last):
...
pology.PologyError: Attribute 'msgtsr' is not among specified.
&gt;&gt;&gt;
</pre>
<p>You may conclude that modification tracking and type and attribute constraining would slow down processing, and you would be right. Since PO messages are by far the most processed objects, a non-monitored counterpart to <code class="classname">Message</code> is provided as well, for occasions where the code is only reading PO files, or has been sufficiently tested, and speed is of importance. See <a class="xref" href="ch-prog.html#sec-prflmsg" title="11.1.2.&nbsp;Message">Section&nbsp;11.1.2, “Message”</a> for details.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prflmsg" id="sec-prflmsg"></a>11.1.2.&nbsp;Message</h3>
</div>
</div>
</div>
<p>PO messages are by default represented with the <a class="ulink" href="../../api/en_US/pology.message.Message-class.html" target="_top"><code class="classname">Message</code></a> class. It is monitored for modifications, and constrained on attributes and attribute types. It provides direct attribute access to parts of a PO message:</p>
<pre class="programlisting">
&gt;&gt;&gt; from pology.monitored import Monpair
&gt;&gt;&gt; from pology.message import Message
&gt;&gt;&gt; msg = Message()
&gt;&gt;&gt; msg.msgid = u"Foo %s"
&gt;&gt;&gt; msg.msgstr.append(u"Bar %s")
&gt;&gt;&gt; msg.flag.add(u"c-format")
&gt;&gt;&gt; msg.fuzzy = True
&gt;&gt;&gt; print msg.to_string(),
#, fuzzy, c-format
msgid "Foo %s"
msgstr "Bar %s"

&gt;&gt;&gt;
</pre>
<p>Attribute access provides the least hassle, while being guarded by monitoring, and makes clear the semantics of particular message parts. For example, the <code class="varname">.flag</code> attribute is a set, to indicate that the order of flags should be of no importance to either a human translator or a PO processor, and the <code class="varname">.msgstr</code> attribute is always a list in order to prevent the programmer from not taking into account plural messages. While the fuzzy state is formally indicated by a flag, it is considered special enough to have a separate attribute.</p>
<p>Some message parts may or may not be present in a message, and when they are not present, the corresponding attributes are either empty if sequences (e.g. <code class="varname">.manual_comment</code> list for translator comments), or set to <code class="literal">None</code> if strings<sup>[<a name="idp10991984" href="#ftn.idp10991984" class="footnote" id="idp10991984">52</a>]</sup> (e.g. <code class="varname">.msgctxt</code>).</p>
<p>There are also several derived, read-only attributes for special purposes. For example, if in some context the messages are to be tracked in a dictionary by their keys, there is the <code class="varname">.key</code> attribute available, which is an undefined but unique combination of <code class="varname">.msgctxt</code> and <code class="varname">.msgid</code> attributes. Or, there is the <code class="varname">.active</code> attribute which is <code class="literal">True</code> if the message is neither fuzzy nor obsolete, i.e. its translation (if there is one) would be used by the consumer of the PO file that the message is part of.</p>
<p><code class="classname">Message</code> has a number of methods for frequent operations that need to read or modify more than one attribute. For example, to thoroughly unfuzzy a message, it is not sufficient to just remove its fuzzy flag (by setting <code class="varname">.fuzzy</code> to <code class="literal">False</code> or removing <code class="literal">u"fuzzy"</code> from <code class="varname">.flag</code> set), but previous field comments (<code class="literal">#| ...</code>) should be removed as well, and this is what <code class="function">.unfuzzy()</code> method does:</p>
<pre class="programlisting">
&gt;&gt;&gt; print msg.to_string(),
#| msgid "Foubar"
#, fuzzy
msgid "Foobar"
msgstr "Fubar"

&gt;&gt;&gt; msg.unfuzzy()
&gt;&gt;&gt; print msg.to_string(),
msgid "Foobar"
msgstr "Fubar"

</pre>
<p>Other methods include those to copy over a subset of parts from another message, to revert the message to pristine untranslated state, and so on.</p>
<p>There exists a non-monitored counterpart to <code class="classname">Message</code>, the <a class="ulink" href="../../api/en_US/pology.message.MessageUnsafe-class.html" target="_top"><code class="classname">MessageUnsafe</code></a>class. Its attributes are of built-in types, e.g. <code class="varname">.msgstr</code> is plain <code class="classname">list</code>, and there is no type nor attribute checking. By using <code class="classname">MessageUnsafe</code>, a speedup of 50% to 100% has been observed in practical applications, so it makes for a good trade-off when you know what you are doing (e.g. you are certain that no modifications will be made). A PO file is opened with non-monitored messages by issuing the <code class="literal">monitored=False</code> argument to <code class="classname">Catalog</code> constructor.</p>
<p>Read-only code could should work with <code class="classname">Message</code> and <code class="classname">MessageUnsafe</code> objects without any type-based specialization. Code that writes may need some care to achieve the same, for example:</p>
<pre class="programlisting">
def translate_moo_as_mu (msg):

    if msg.msgid == u"Moo!":  # works for both
        msg.msgstr = [u"Mu!"]  # raises exception if Message
        msg.msgstr[:] = [u"Mu!"]  # works for both
        msg.msgstr[0] = u"Mu!"  # works for both (when not empty)
</pre>
<p>If you need to create an empty message of the same type as another message, or make a same-type copy of the message, you can use <code class="function">type</code> built-in:</p>
<pre class="programlisting">
newmsg1 = type(msg)()  # create empty
newmsg2 = type(msg)(msg)  # copy
</pre>
<p><code class="classname">Message</code> and <code class="classname">MessageUnsafe</code> share the virtual base class <code class="classname">Message_base</code>, so you can use <code class="literal">isinstance(obj, Message_base)</code> to check if an object is a PO message of either type.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prflhead" id="sec-prflhead"></a>11.1.3.&nbsp;Header</h3>
</div>
</div>
</div>
<p>The PO header could be treated as just another message, but that would both be inconvenient for operating on it, and disruptive in iteration over a catalog. Instead the <a class="ulink" href="../../api/en_US/pology.header.Header-class.html" target="_top"><code class="classname">Header</code></a> class is introduced. Similar to <code class="classname">Message</code>, it provides both direct attribute access to parts of the header (like the <code class="varname">.field</code> list of name-value pairs), and methods for usual manipulations which would need a sequence of basic data manipulations (like <code class="function">.set_field()</code> to either modify an existing or add a new header field with the given value).</p>
<p>In particular, header comments are represented by a number of attributes (<code class="varname">.title</code>, <code class="varname">.author</code>, etc.), some of which are strings and some lists, depending on semantics. Unfortunatelly, the PO format does not define this separation formally, so when the PO file is parsed, comments are split heuristically (<code class="varname">.title</code> will be the first comment line, <code class="varname">.author</code> will get every line which looks like it has an email address and a year in it, etc.)</p>
<p><code class="classname">Header</code> is a monitored class just like <code class="classname">Message</code>, but unlike <code class="classname">Message</code> it has no non-monitored counterpart. This is because in practice the header operations make a small part of total processing, so there is no real advantage at having non-monitored headers.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prflcat" id="sec-prflcat"></a>11.1.4.&nbsp;Catalog</h3>
</div>
</div>
</div>
<p>PO files are read and written through <a class="ulink" href="../../api/en_US/pology.catalog.Catalog-class.html" target="_top"><code class="classname">Catalog</code></a> objects. A small script to open a PO file on disk (given as the first argument), find all messages that contain a certain substring in the original text (given as the second argument), and write those messages to standard output, would look like this:</p>
<pre class="programlisting">
import sys
from pology.catalog import Catalog
from pology.msgreport import report_msg_content

popath = sys.argv[1]
substr = sys.argv[2]

cat = Catalog(popath)
for msg in cat:
    if substr in msg.msgid:
        report_msg_content(msg, cat)
</pre>
<p>Note the minimalistic code, both by raw length and access interface. Instead of using something like <code class="literal">print msg.to_string()</code> to output the message, already in this example we introduce the <a class="ulink" href="../../api/en_US/pology.msgreport-module.html" target="_top"><code class="literal">msgreport</code></a> module, which contains various functions for reporting on PO messages;<sup>[<a name="idp6614928" href="#ftn.idp6614928" class="footnote" id="idp6614928">53</a>]</sup> <code class="function">report_msg_content()</code> will first output the PO file name and location of the message (line and entry number) within the file, and then the message content itself, with some highlighting (for field keywords, fuzzy state, etc.) if the output destination permits it. Since no modifications are done to messages, this example would be just as safe but run significantly faster if the PO file were opened in non-monitored mode. This is done by adding the <code class="literal">monitored=False</code> argument to <code class="classname">Catalog</code> constructor:</p>
<pre class="programlisting">
cat = Catalog(popath, monitored=False)
</pre>
<p>and no other modification is required.</p>
<p>When some messages are modified in a catalog created by opening a PO file on disk, the modifications will not be written back to disk until the <code class="function">.sync()</code> method is called -- not even if the program exists. If the catalog is monitored and there were no modifications to it up to the moment <code class="function">.sync()</code> is called, the file on disk will not be touched, and <code class="function">.sync()</code> will return <code class="literal">False</code> (it returns <code class="literal">True</code> if the file is written).<sup>[<a name="idp15884352" href="#ftn.idp15884352" class="footnote" id="idp15884352">54</a>]</sup> In a scenario where a bunch of PO files are processed, this allows you to report only those which were actually modified. Take as an example a simplistic<sup>[<a name="idp15887504" href="#ftn.idp15887504" class="footnote" id="idp15887504">55</a>]</sup> script to search and replace in translation:</p>
<pre class="programlisting">
import sys
from pology.catalog import Catalog
from pology.fsops import collect_catalogs
from pology.report import report

serchstr = sys.argv[1]
replacestr = sys.argv[2]
popaths = sys.argv[3:]

popaths = collect_catalogs(popaths)
for popath in popaths:
    cat = Catalog(popath)
    for msg in cat:
        for i, text in enumerate(msg.msgstr):
            msg.msgstr[i] = text.replace(searchstr, replacestr)
    if cat.sync():
        report("%s (%d)" % (cat.filename, cat.modcount))
</pre>
<p>This script takes the search and replace strings as the first two arguments, followed by any number of PO paths. The paths do not have to be only file paths, but can also be directory paths, in which case the <code class="function">collect_catalogs()</code> function from <a class="ulink" href="../../api/en_US/pology.fsops-module.html" target="_top"><code class="literal">fsops</code></a> module will recursively collect any PO files in them. After the search and replace iteration through a catalog is done (<code class="varname">msgstr</code> being properly handled on plain and plural messages alike), its <code class="function">.sync()</code> method is called, and if it reports that the file was modified, the file's path and number of modified texts is output. The latter is obtained simply as the modification counter state of the catalog, since it was bumped up by one on each text that actually got modified. Note the use of <code class="varname">.filename</code> attribute for illustration, although in this particular case we had the path available in <code class="varname">popath</code> variable.</p>
<p>Syncing to disk is an atomic operation. This means that if you or something else aborts the program in the middle of execution, none of the processed PO files will become corrupted; they will either be in their original state, or in the expected modified state.</p>
<p>As can be seen, at its base the <code class="classname">Catalog</code> class is an iterable container of messages. However, the precise nature of this container is less obvious. To the consumer (a program or converter) the PO file is a dictionary of messages by keys (<code class="varname">msgctxt</code> and <code class="varname">msgid</code> fields); there can be no two messages with the same key, and the order of messages is of no importance. For the human translator, however, the order of messages in the PO file is of great importance, because it is one of <a class="link" href="ch-poformat.html#sec-pocontext" title="2.2.&nbsp;Message Context">context indicators</a>. Message keys are parts of the messages themselves, which means that a message is both its own dictionary key and the value. Taking these constraints together, in Pology the PO file is treated as an <span class="emphasis"><em>ordered set</em></span>, and the <code class="classname">Catalog</code> class interface is made to reflect this.</p>
<p>The ordered set nature of catalogs comes into play when the composition of messages, rather than just the messages themselves, is modified. For example, to remove all obsolete messages from the catalog, the <code class="function">.remove()</code> method <span class="emphasis"><em>could</em></span> be used:</p>
<pre class="programlisting">
for msg in list(cat):
    if msg.obsolete:
        cat.remove(msg)
cat.sync()
</pre>
<p>Note that the message sequence was first copied into a list, since the removal would otherwise clobber the iteration. Unfortunatelly, this code will be very slow (linear time wrt. catalog size), since when a message is removed, internal indexing has to be updated to maintain both the order and quick lookups. Instead, the better way to remove messges is the <code class="function">.remove_on_sync()</code> method, which marks the message for removal on syncing. This runs fast (constant time wrt. catalog size) and requires no copying into a list prior to iteration:</p>
<pre class="programlisting">
for msg in cat:
    if msg.obsolete:
        cat.remove_on_sync(msg)
cat.sync()
</pre>
<p>A message is added to the catalog using the <code class="function">.add()</code> method. If <code class="function">.add()</code> is given only the message itself, it will overwrite the message with the same key if there is one such, or else insert it according to source references, or append it to the end. If <code class="function">.add()</code> is also given the insertion position, it will insert the message at that position only if the message with the same key does not exist in the catalog; if it does, it will ignore the given position and overwrite the existing message. When the message is inserted, <code class="function">.add()</code> suffers the same performance problem as <code class="function">.remove()</code>: it runs in linear time. However, the common case when an empty catalog is created and messages added one by one to the end can run in constant time, and this is what <code class="function">.add_last()</code> method does.<sup>[<a name="idp15193200" href="#ftn.idp15193200" class="footnote" id="idp15193200">56</a>]</sup></p>
<p>The basic way to check if a message with the same key exists in the catalog is to use the <code class="literal">in</code> operator. Since the catalog is ordered, if the position of the message is wanted, <code class="function">.find()</code> method can be used instead. Both these methods are fast, running in constant time. There is a series of <code class="function">.select_*()</code> methods for looking up messages by other than the key, which run in linear time, and return lists of messages since the result may not be unique any more.</p>
<p>Since it is ordered, the catalog can be indexed, and that either by a position or by a message (whose key is used for lookup). To replace a message in the catalog with a message which has the same key but is otherwise different, you can either first fetch its position and then use it as the index, or use the message itself as the index:</p>
<pre class="programlisting">
# Idexing by position.
pos = cat.find(msg)
cat[pos] = msg

# Indexing by message key.
cat[msg] = msg
</pre>
<p>This leads to the following question: what happens if you modify the key of a message (its <code class="varname">.msgctxt</code> or <code class="varname">.msgid</code> attributes) in the catalog? In that case the internal index goes out of sync, rather than being automatically updated. This is a necessary performance measure. If you need to change message keys, while doing that you should treat the catalog as a pure list, using only <code class="literal">in</code> iteration and positional indexing. Afterwards you should either call <code class="function">.sync()</code> if you are done with the catalog, or <code class="function">.sync_map()</code> to only update indexing (and remove messages marked with <code class="function">.remove_on_sync()</code>) without writing out the PO file.</p>
<p>The <code class="classname">Catalog</code> class provides a number of convenience methods which report things about the catalog based on the header information, rather than having to manually examine the header. These include the number of plural forms, the <code class="varname">msgstr</code> index for the given plural number, as well as information important in some Pology contexts, like language code, accelerator markers, markup types, etc. Each of these methods has a counterpart which sets the appropriate value, but this value is not written to disk when the catalog is synced. This is because frequently there are more ways in which the value can be determined from the header, so it is ambiguous how to write it out. Instead, these methods are used to set or override values provided by the catalog (e.g. based on command line options) for the duration of processing only.</p>
<p>To create an empty catalog if it does not exist on disk, the <code class="literal">create=True</code> argument can be added to the constructor. If the catalog does exist, it will be opened as usual; if it did not exist, the new PO file will be written to disk on sync. To unconditionally create an empty catalog, whether the PO file exists or not at the given path, the <code class="literal">truncate=True</code> parameter should be added as well. In this case, if the PO file did exist, it will be overwritten with the new content only when the catalog is synced. The catalog can also be created with an empty string for path, in which case it is guaranteed to be empty even without setting <code class="literal">truncate=True</code>. If a catalog with empty path should later be synced (as opposed to being transient during processing), its <code class="varname">.filename</code> attribute can simply be assigned a valid path before calling <code class="function">.sync()</code>.</p>
<p>In summary, it can be said that the <code class="classname">Catalog</code> class is biased, in terms of performance and ease of use, towards processing existing PO files rather than creating PO files from scratch, and towards processing existing messages in the PO file rather than shuffling them around.</p>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-prcodconv" id="sec-prcodconv"></a>11.2.&nbsp;Coding Conventions</h2>
</div>
</div>
</div>
<p>This section describes the style and conventions that the code which is intended to be included in Pology distribution should adhere to. The general coding style is expected to follow the Python style guide described in <a class="ulink" href="http://www.python.org/dev/peps/pep-0008/" target="_top">PEP 8</a>.</p>
<p>Lines should be up to 80 characters long. Class names should be written in camel case, and all other names in lower case with underscores:</p>
<pre class="programlisting">
class SomeThingy (object):
    ...

    def some_method (self, ...):

        ...
        longer_variable = ...


def some_function (...):
    ...
</pre>
<p>Long expressions with operators should be wrapped in parentheses and before the binary operator, with the first line indented to the level of the other operand:</p>
<pre class="programlisting">
some_quantity = (  a_number_of_thingies * quantity_of_that_per_unit
                  + the_base_offset)
</pre>
<p>In particular, long conditions in <code class="literal">if</code> and <code class="literal">while</code> statements should be written like this:</p>
<pre class="programlisting">
if (    something and something_else and yet_something
    and somewhere_in_between and who_knows_what_else
):
    do_something_appropriate()
</pre>
<p>All messages, warnings, and errors should be issued through <a class="ulink" href="../../api/en_US/pology.report-module.html" target="_top"><code class="literal">msgreport</code></a> and <a class="ulink" href="../../api/en_US/pology.msgreport-module.html" target="_top"><code class="literal">msgreport</code></a> modules. There should be no <code class="function">print</code> statements or raw writes to <code class="literal">sys.stdout</code>/<code class="literal">sys.stderr</code>.</p>
<p>For the code in Pology library, it is always preferable to raise an exception instead of aborting execution. On the other hand, it is fine to add optional parameters by which the client can select if the function should abort rather than raise an exception. All topical problems should raise <code class="classname">pology.PologyError</code> or a subclass of it, and built-in exceptions only for simple general problems (e.g. <code class="classname">IndexError</code> for indexing past the end of something).</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prcsi18n" id="sec-prcsi18n"></a>11.2.1.&nbsp;User-Visible Text and Internationalization</h3>
</div>
</div>
</div>
<p>All user-visible text, be it reports, warnings, errors (including exception messages) should be wrapped for internationalization through Gettext. The top <a class="ulink" href="../../api/en_US/pology.pology-module.html" target="_top"><code class="literal">pology</code></a> module provides several wrappers for Gettext functions, which have the following special traits: context is mandatory on every wrapped text, all format directives must be named, and arguments are specified as keyword-value pairs just after the text argument (unless deferred translation is used). Some examples:</p>
<pre class="programlisting">
# Simple message with context marker.
_("@info",
  "Trying to sync unnamed catalog.")

# Simple message with extended context.
_("@info command description",
  "Keep track of who, when, and how, has translated, modified, "
  "or reviewed messages in a collection of PO files.")

# Another context marker and extended context.
_("@title:column words per message in original",
  "w/msg-or")

# Parameter substitution.
_("@info",
  "Review tag '%(tag)s' not defined in '%(file)s'.",
  tag=rev_tag, file=config_path)

# Plural message
n_("@item:inlist",
   "written %(num)d word", "written %(num)d words",
   num=nwords)

# Deferred translation, when arguments are known later.
tmsg = t_("@info:progress",
          "Examining state: %(file)s")
...
msg = tmsg.with_args(file=some_path).to_string()
</pre>
<p>Every context starts with the "context marker" in form of <code class="literal">@<em class="replaceable"><code>keyword</code></em></code>, drawn from a predefined set (see the <a class="ulink" href="http://techbase.kde.org/Development/Tutorials/Localization/i18n_Semantics#Context_Markers" target="_top">article on i18n semantics</a> at KDE Techbase); it is most often <code class="literal">@info</code> in Pology code. The context marker may be, and should be, followed by a free-form extend context whenever it can help the translator to understand how and where the message is used. It is usual to have the context, text and arguments in different lines, though not necessary if they are short enough to fit one line.</p>
<p>Pology defines lightweight XML markup for coloring text in the <a class="ulink" href="../../api/en_US/pology.colors-module.html" target="_top"><code class="literal">colors</code></a> module. In fact, Gettext wrappers do not return ordinary strings, but <a class="ulink" href="../../api/en_US/pology.colors.ColorString-class.html" target="_top"><code class="classname">ColorString</code></a> objects, and functions from <code class="literal">report</code> and <code class="literal">msgreport</code> modules know how to convert it to raw strings for given output destination (file, terminal, web page...). Therefore you can use colors in any wrapped string:</p>
<pre class="programlisting">
_("@info:progress",
  "&lt;green&gt;History follows:&lt;/green&gt;")

_("@info",
  "&lt;bold&gt;Context:&lt;/bold&gt; %(snippet)s",
  snippet=some_text)
</pre>
<p>Coloring should be used sparingly, only when it will help to cue user's eyes to significant elements of the output.</p>
<p>There are two consequences of having text markup available throughout. The first is that every message must be well-formed XML, which means that it must contain no unballanced tags, and that literal <code class="literal">&lt;</code> characters must be escaped (and then also <code class="literal">&gt;</code> for good style):</p>
<pre class="programlisting">
_("@item automatic name for anonymous input stream",
  "&amp;lt;stream-%(num)s&amp;gt;",
  num=strno)
</pre>
<p>The other consequence is that <code class="classname">ColorString</code> instances must be joined and interpolated with dedicated functions; see <code class="function">cjoin()</code> and <code class="function">cinterp()</code> functions in <code class="literal">colors</code> module.</p>
<p>Unless the text of the message is specifically intended to be a title or an insert (i.e. <code class="literal">@title</code> or <code class="literal">@item</code> context markers), it should be a proper sentence, starting with a capital letter and ending with a dot.</p>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-prsieves" id="sec-prsieves"></a>11.3.&nbsp;Writing Sieves</h2>
</div>
</div>
</div>
<p><a class="link" href="ch-sieve.html" title="Chapter&nbsp;3.&nbsp;Sieving">Pology sieves</a> are filtering-like processing elements applied by the <span class="command"><strong>posieve</strong></span> script to collections of PO files. A sieve can examine as well as modify the PO entries passed through it. Each sieve is written in a separate file. If the sieve file is put into <code class="filename">sieve/</code> directory of Pology distribution (or intallation), the sieve can be referenced on <span class="command"><strong>posieve</strong></span> command line by the shorthand notation; otherwise the path to the sieve file is given. The former is called an internal sieve, and the latter an external sieve, but the sieve file layout and the sieve definition are same for both cases.</p>
<p>In the following, <span class="command"><strong>posieve</strong></span> will be referred to as "the client". This is because tools other than <span class="command"><strong>posieve</strong></span> may start to use sieves in the future, and it will also be described what these clients should adhere to when using sieves.</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prsvlayout" id="sec-prsvlayout"></a>11.3.1.&nbsp;Sieve Layout</h3>
</div>
</div>
</div>
<p>The sieve file must define the <code class="classname">Sieve</code> class, with some mandatory and some optional interface methods and instance variables. There are no restrictions at what you can put into the sieve file beside this class, only keep in mind that <span class="command"><strong>posieve</strong></span> will load the sieve file as a Python module, exactly once during a single run.</p>
<p>Here is a simple sieve (also the complete sieve file) which just counts the number of translated messages:</p>
<pre class="programlisting">
class Sieve (object):

    def __init__ (self, params):

        self.ntranslated = 0

    def process (self, msg, cat):

        if msg.translated:
            self.ntranslated += 1

    def finalize (self):

        report("Total translated: %d" % self.ntranslated)
</pre>
<p>The constructor takes as argument an object specifying any sieve parameters (more on that soon). The <code class="methodname">process</code> method gets called for each message in each PO file processed by the client, and must take as parameters the message (instance of <a class="ulink" href="../../api/en_US/pology.message.Message_base-class.html" target="_top"><code class="classname">Message_base</code></a>) and the catalog which contains it (<a class="ulink" href="../../api/en_US/pology.catalog.Catalog-class.html" target="_top"><code class="classname">Catalog</code></a>). The client calls the <code class="methodname">finalize</code> method after no more messages will be fed to the sieve, but this method does need to be defined (client should check if it exists before placing the call).</p>
<p>Another optional method is <code class="methodname">process_header</code>, which the client calls on the PO header:</p>
<pre class="programlisting">
def process_header (self, hdr, cat):
    # ...
</pre>
<p><code class="literal">hdr</code> is an instance of <a class="ulink" href="../../api/en_US/pology.header.Header-class.html" target="_top"><code class="classname">Header</code></a>, and <code class="literal">cat</code> is the containing catalog. The client will check for the presence of this method, and if it is defined, it will call it prior to any <code class="methodname">process</code> call on the messages from the given catalog. In other words, the client is not allowed to switch catalogs between two calls to <code class="methodname">process</code> without calling <code class="methodname">process_header</code> in between.</p>
<p>There is also the optional <code class="methodname">process_header_last</code> method, for which everything holds just like for <code class="methodname">process_header</code>, except that, when present, the client must call it <span class="emphasis"><em>after</em></span> all consecutive <code class="methodname">process</code> calls on messages from the same catalog:</p>
<pre class="programlisting">
def process_header_last (self, hdr, cat):
    # ...
</pre>
<p>Sieve methods should not abort program execution in case of errors, instead they should throw an exception. In particular, if the <code class="methodname">process</code> method throws <a class="ulink" href="../../api/en_US/pology.sieve.SieveMessageError-class.html" target="_top"><code class="classname">SieveMessageError</code></a>, it means that the sieve can still process other messages in the same catalog; if it throws <a class="ulink" href="../../api/en_US/pology.sieve.SieveCatalogError-class.html" target="_top"><code class="classname">SieveCatalogError</code></a>, then any following messages from the same catalog must be skipped, but other catalogs may be processed. Similarly, if <code class="methodname">process_header</code> throws <code class="classname">SieveCatalogError</code>, other catalogs may still be processed. Any other type of exception tells the client that the sieve should no longer be used.</p>
<p>The <code class="methodname">process</code> and <code class="methodname">process_header</code> methods should either return <code class="literal">None</code> or an integer exit code. A return value which is neither <code class="literal">None</code> nor <code class="literal">0</code> indicates that while the evaluation was successfull (no exception was thrown), the processed entry (message or header) should not be passed further along the <a class="link" href="ch-sieve.html#sec-svchains" title="3.2.&nbsp;Sieve Chains">sieve chain</a>.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prsvparams" id="sec-prsvparams"></a>11.3.2.&nbsp;Sieve Parameter Handling</h3>
</div>
</div>
</div>
<p>The <code class="literal">params</code> parameter of the sieve constructor is an object with data attributes as <a class="link" href="ch-sieve.html#p-svparam">parameters which may influence</a> the sieve operation. The sieve file can define the <code class="function">setup_sieve</code> function, which the client will call with a <a class="ulink" href="../../api/en_US/pology.subcmd.SubcmdView-class.html" target="_top"><code class="classname">SubcmdView</code></a> object as the single argument, to fill in the sieve description and define all mandatory and optional parameters. For example, if the sieve takes an optional parameter named <code class="literal">checklevel</code>, which controles the level (an integer) at which to perform some checks, here is how <code class="function">setup_sieve</code> could look like:</p>
<pre class="programlisting">
def setup_sieve (p):

    p.set_desc("An example sieve.")
    p.add_param("checklevel", int, defval=0,
                desc="Validity checking level.")


class Sieve (object):

    def __init__ (self, params):

        if params.checklevel &gt;= 1:
            # ...setup some level 1 validity checks...
        if params.checklevel &gt;= 2:
            # ...setup some level 2 validity checks...
        #...

    ...
</pre>
<p>See the <a class="ulink" href="../../api/en_US/pology.subcmd.SubcmdView-class.html#add_param" target="_top"><code class="methodname">add_param</code></a> method for details on defining sieve parameters.</p>
<p>The client is not obliged to call <code class="function">setup_sieve</code>, but it must make sure that the object it sends to the sieve as <code class="literal">params</code> has all the instance variable according to the defined parameters.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prsvregime" id="sec-prsvregime"></a>11.3.3.&nbsp;Catalog Regime Indicators</h3>
</div>
</div>
</div>
<p>There are two boolean instance variables that the sieve may define, and which the client may check for to decide on the regime in which the catalogs are opened and closed:</p>
<pre class="programlisting">
class Sieve (object):

    def __init__ (self, params):

        # These are the defaults:
        self.caller_sync = True
        self.caller_monitored = True

    ...
</pre>
<p>The variables are:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="varname">caller_sync</code> instructs the client whether catalogs processed by the sieve should be synced to disk at the end. If the sieve does not define this variable, the client should assume <code class="literal">True</code> and sync catalogs. This variable is typically set to <code class="literal">False</code> in sieves which do not modify anything, because syncing catalogs takes time.</p>
</li>
<li class="listitem">
<p><code class="varname">caller_monitored</code> tells the client whether it should open catalogs in monitored mode. If this variable is not set, the client should assume it <code class="literal">True</code>. This is another way of reducing processing time for sieves which do not modify PO entries.</p>
</li>
</ul>
</div>
<p>Usually a modifying sieve will set neither of these variables, i.e. catalogs will be monitored and synced by default, while a checker sieve will set both to <code class="literal">False</code>. For a modifying sieve that unconditionally modifies all entries sent to it, only <code class="varname">caller_monitored</code> may be set to <code class="literal">False</code> and <code class="varname">caller_sync</code> left undefined (i.e. <code class="literal">True</code>).</p>
<p>If a sieve requests no monitoring or no syncing, the client is not obliged to satisfy these requests. On the other hand, if a sieve does request monitoring or syncing (either explicitly or by not defining the corresponding variables), the client must provide catalogs in that regime. This is because there may be several sieves operating at the same time (a sieve chain), and monitoring and syncing is usually necessary for proper operation of those sieves that request it.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prsvnotes" id="sec-prsvnotes"></a>11.3.4.&nbsp;Further Notes on Sieves</h3>
</div>
</div>
</div>
<p>Since monitored catalogs have modification counters, the sieve may use them within its <code class="methodname">process*</code> methods to find out if any modification really took place. The proper way to do this is to record the counter at start, and check for increase at end:</p>
<pre class="programlisting">
def process (self, msg, cat):

    startcount = msg.modcount

    # ...
    # ... do some stuff
    # ...

    if msg.modcount &gt; startcount:
        self.nmodified += 1
</pre>
<p>The <span class="emphasis"><em>wrong</em></span> way to do it would be to merely check if <code class="literal">msg.modcount &gt; 0</code>, because several modifying sieves may be operating at the same time, each increasing the counters.</p>
<p>If the sieve wants to remove the message from the catalog, if at all possible it should use catalog's <code class="methodname">remove_on_sync</code> instead of <code class="methodname">remove</code> method, to defer actual removal to sync time. This is because <code class="methodname">remove</code> will probably ruin client's iteration over the catalog, so if it must be used, the sieve documentation should state it clearly. <code class="methodname">remove</code> also has linear execution time, while <code class="methodname">remove_on_sync</code> has constant.</p>
<p>If the sieve is to become part of Pology distribution, it should be properly documented. This means fully equipped <code class="function">setup_sieve</code> function in the sieve file, and a piece of user manual documentation. The <code class="classname">Sieve</code> class itself should not be documented in general. Only when <code class="methodname">process*</code> are returning an exit code, this should be stated in their own comments (and in the user manual).</p>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-prhooks" id="sec-prhooks"></a>11.4.&nbsp;Writing Hooks</h2>
</div>
</div>
</div>
<p>Hooks are functions with specified sets of input parameters, return values, processing intent, and behavioral constraints. They can be used as modification and validation plugins in many processing contexts in Pology. There are three broad categories of hooks: filtering, validation and side-effect hooks.</p>
<p>Filtering hooks modify some of their inputs. Modifications are done in-place whenever the input is mutable (like a PO message), otherwise the modified input is provided in a return value (like a PO message text field).</p>
<p>Validation hooks perform certain checks on their inputs, and return a list of <span class="emphasis"><em>annotated spans</em></span> or <span class="emphasis"><em>annotated parts</em></span>, which record all the encountered errors:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><a name="p-annspans" id="p-annspans"></a>Annotated spans are reported when the object of validation is a piece of text. Each span is a tuple of start and end index of the problematic segment in the text, and a note which explains the problem. The return value of a text-validation hook will thus be a list:</p>
<pre class="programlisting">
[(start1, end1, "note1"), (start2, end2, "note1"), ...]
</pre>
<p>The note can also be <code class="literal">None</code>, if there is nothing to say about the problem.</p>
</li>
<li class="listitem">
<p><a name="p-annparts" id="p-annparts"></a>Annotated parts are reported for an object which has more than one distinct piece of text, such as a PO message. Each annotated part is a tuple stating the name of the problematic part of the object (e.g. <code class="literal">"msgid"</code>, <code class="literal">"msgstr"</code>), the item index for array-like parts (e.g. for <code class="literal">msgstr</code>), and the list of problems in appropriate form (for a PO message this is a list of annotated spans). The return value of a PO message-validation hook will look like this:</p>
<pre class="programlisting">
[("part1", item1, [(start11, end11, "note11"), ...]),
 ("part2", item2, [(start21, end21, "note21"), ...]),
 ...]
</pre></li>
</ul>
</div>
<p>Side-effect hooks neither modify their inputs nor report validation information, but can be used for whatever purpose which is independent of the processing chain into which the hook is inserted. For example, a validation hook can be implemented like this as well, when it is enough that it reports problems to standard output, or where the hook client does not know how to use structured validation data (annotated spans or parts). The return value of a side-effect hook the number of errors encountered internally by the hook (an integer). Clients may use this number to decide upon further behavior. For example, if a side-effect hook modified a temporary copy of a file, the client may decide to abandon the result and use the original file if there were some errors.</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prhktypes" id="sec-prhktypes"></a>11.4.1.&nbsp;Hook Taxonomy</h3>
</div>
</div>
</div>
<p>In this section a number of hook types are described and assigned a formal type keyword, so that they can be conveniently referred to elsewhere in Pology documentation.</p>
<p>Each type keyword has the form <span class="emphasis"><em>&lt;letter1&gt;&lt;number&gt;&lt;letter2&gt;</em></span>, e.g. F1A. The first letter represents the hook category: <span class="emphasis"><em>F</em></span> for filtering hooks, <span class="emphasis"><em>V</em></span> for validation hooks, and <span class="emphasis"><em>S</em></span> for side-effect hooks. The number enumerates the input signature by parameter types, and the final letter denotes the difference in semantics of input parameters for equal input signatures. As a handy mnemonic, each type is also given an informal signature in the form of <code class="literal">(param1, param2, ...) -&gt; result</code>; in them, <code class="literal">spans</code> stand for <a class="link" href="ch-prog.html#p-annspans">annotated spans</a>, <code class="literal">parts</code> for <a class="link" href="ch-prog.html#p-annparts">annotated parts</a>, and <code class="literal">numerr</code> for number of errors.</p>
<p>Hooks on pure text:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>F1A (<code class="literal">(text) -&gt; text</code>): filters the text</p>
</li>
<li class="listitem">
<p>V1A (<code class="literal">(text) -&gt; spans</code>): validates the text</p>
</li>
<li class="listitem">
<p>S1A (<code class="literal">(text) -&gt; numerr</code>): side-effects on text</p>
</li>
</ul>
</div>
<p>Hooks on text fields in a PO message in a catalog:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>F3A (<code class="literal">(text, msg, cat) -&gt; text</code>): filters any text field</p>
</li>
<li class="listitem">
<p>V3A (<code class="literal">(text, msg, cat) -&gt; spans</code>): validates any text field</p>
</li>
<li class="listitem">
<p>S3A (<code class="literal">(text, msg, cat) -&gt; numerr</code>): side-effects on any text field</p>
</li>
<li class="listitem">
<p>F3B (<code class="literal">(msgid, msg, cat) -&gt; msgid</code>): filters an original text field; original fields are either <code class="literal">msgid</code> or <code class="literal">msgid_plural</code></p>
</li>
<li class="listitem">
<p>V3B (<code class="literal">(msgid, msg, cat) -&gt; spans</code>): validates an original text field</p>
</li>
<li class="listitem">
<p>S3B (<code class="literal">(msgid, msg, cat) -&gt; numerr</code>): side-effects on an original text field</p>
</li>
<li class="listitem">
<p>F3C (<code class="literal">(msgstr, msg, cat) -&gt; msgstr</code>): filters a translation text field; translation fields are the <code class="literal">msgstr</code> array</p>
</li>
<li class="listitem">
<p>V3C (<code class="literal">(msgstr, msg, cat) -&gt; spans</code>): validates a translation text field</p>
</li>
<li class="listitem">
<p>S3C (<code class="literal">(msgstr, msg, cat) -&gt; numerr</code>): side-effects on a translation text field</p>
</li>
</ul>
</div>
<p>*3B and *3C hook series are introduced next to *3A for cases when it does not make sense for text field to be any other but one of the original, or translation fields. For example, to process the translation sometimes the original (obtained by <code class="literal">msg</code> parameter) must be consulted. If a *3B or *3C hook is applied on an inappropriate text field, the results are undefined.</p>
<p>Hooks on PO entries in a catalog:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="literal">F4A</code> (<code class="literal">(msg, cat) -&gt; numerr</code>): filters a message, modifying it</p>
</li>
<li class="listitem">
<p><code class="literal">V4A</code> (<code class="literal">(msg, cat) -&gt; parts</code>): validates a message</p>
</li>
<li class="listitem">
<p><code class="literal">S4A</code> (<code class="literal">(msg, cat) -&gt; numerr</code>): side-effects on a message (no modification)</p>
</li>
<li class="listitem">
<p><code class="literal">F4B</code> (<code class="literal">(hdr, cat) -&gt; numerr</code>): filters a header, modifying it</p>
</li>
<li class="listitem">
<p><code class="literal">V4B</code> (<code class="literal">(hdr, cat) -&gt; parts</code>): validates a header</p>
</li>
<li class="listitem">
<p><code class="literal">S4B</code> (<code class="literal">(hdr, cat) -&gt; numerr</code>): side-effects on a header (no modification)</p>
</li>
</ul>
</div>
<p>Hooks on PO catalogs:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="literal">F5A</code> (<code class="literal">(cat) -&gt; numerr</code>): filters a catalog, modifying it in any way</p>
</li>
<li class="listitem">
<p><code class="literal">S5A</code> (<code class="literal">(cat) -&gt; numerr</code>): side-effects on a catalog (no modification)</p>
</li>
</ul>
</div>
<p>Hooks on file paths:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="literal">F6A</code> (<code class="literal">(filepath) -&gt; numerr</code>): filters a file, modifying it in any way</p>
</li>
<li class="listitem">
<p><code class="literal">S6A</code> (<code class="literal">(filepath) -&gt; numerr</code>): side-effects on a file, no modification</p>
</li>
</ul>
</div>
<p>The *2* hook series (with signatures <code class="literal">(text, msg) -&gt; ...</code>) has been skipped because no need for them was observed so far next to *3* hooks.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prhkfact" id="sec-prhkfact"></a>11.4.2.&nbsp;Hook Factories</h3>
</div>
</div>
</div>
<p>Since hooks have fixed input signatures by type, the way to customize a given hook behavior is to produce its function by another function. The hook-producing function is called a I{hook factory}. It works by preparing anything needed for the hook, and then defining the hook proper and returning it, thereby creating a lexical closure around it:</p>
<pre class="programlisting">
def hook_factory (param1, param2, ...):

    # Use param1, param2, ... to prepare for hook definition.

    def hook (...):

        # Perhaps use param1, param2, ... in the hook definition too.

    return hook
</pre>
<p>In fact, most internal Pology hooks are defined by factories.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-prhknotes" id="sec-prhknotes"></a>11.4.3.&nbsp;Further Notes on Hooks</h3>
</div>
</div>
</div>
<p>General hooks should be defined in top level modules, language-dependent hooks in <code class="literal">lang.<em class="replaceable"><code>code</code></em>.<em class="replaceable"><code>module</code></em></code>, project-dependent hooks in <code class="literal">proj.<em class="replaceable"><code>name</code></em>.<em class="replaceable"><code>module</code></em></code>, and hooks that are both language- and project-dependent in <code class="literal">lang.<em class="replaceable"><code>code</code></em>.proj.<em class="replaceable"><code>name</code></em>.<em class="replaceable"><code>module</code></em></code>. Hooks placed like this can be fetched by <a class="ulink" href="../../api/en_US/pology.getfunc-module.html#get_hook_ireq" target="_top"><code class="function">getfunc.get_hook_ireq</code></a> in various non-code contexts, in particular from Pology utilities which allow users to insert hooks into processing through command line options or configurations. If the complete module is dedicated to a single hook, the hook function (or factory) should be named same as the module, so that users can select it by giving only the hook module name.</p>
<p><a class="link" href="ch-prog.html#p-annparts">Annotated parts</a> for PO messages returned by hooks are a reduced but valid instance of highlight specifications used by reporting functions, e.g. <a class="ulink" href="../../api/en_US/pology.msgreport-module.html#report_msg_content" target="_top"><code class="function">msgreport.report_msg_content</code></a>. Annotated parts do not have the optional fourth element of a tuple in highlight specification, which is used to provide the filtered text against which spans were constructed, instead of the original text. If a validation hook constructs the list of problematic spans against the filtered text, just before returning it can apply <a class="ulink" href="../../api/en_US/pology.diff-module.html#adapt_spans" target="_top"><code class="function">diff.adapt_spans</code></a> to reconstruct the spans against the original text.</p>
<p>The documentation to a hook function should state the hook type within the short description, in square brackets at the end as <code class="literal">[type ... hook]</code>. Input parameters should be named like in the informal signatures in the taxonomy above, and should not be omitted in <code class="literal">@param:</code> Epydoc entries; but the return should be given under <code class="literal">@return:</code>, also using one of the listed return names, in order to complete the hook signature.</p>
<p>The documentation to a hook factory should have <code class="literal">[hook factory]</code> at the end of the short description. It should normally list all the input parameters, while the return value should be given as <code class="literal">@return: type ... hook</code>, and the hook signature as the <code class="literal">@rtype:</code> Epydoc field.</p>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-prascsel" id="sec-prascsel"></a>11.5.&nbsp;Writing Ascription Selectors</h2>
</div>
</div>
</div>
<p>Ascription selectors are functions used by <span class="command"><strong>poascribe</strong></span> in the translation review workflow as described in <a class="xref" href="ch-ascript.html" title="Chapter&nbsp;6.&nbsp;Ascribing Modifications and Reviews">Chapter&nbsp;6, <i>Ascribing Modifications and Reviews</i></a>. This section describes how you can write your own ascription selector, which you can then put to use by following the instructions in <a class="xref" href="ch-ascript.html#sec-asccustsels" title="6.8.1.&nbsp;Custom Review Selectors">Section&nbsp;6.8.1, “Custom Review Selectors”</a>.</p>
<p>In terms of code, an ascription selector is a function factory, which construct the actual selector function based on supplied selector arguments. It has the following form:</p>
<pre class="programlisting">
# Selector factory.
def selector_foo (args):

    # Validate input arguments.
    if (...):
        raise PologyError(...)

    # Prepare selector definition.
    ...

    # The selector function itself.
    def selector (msg, cat, ahist, aconf):

        # Prepare selection process.
        ...

        # Iterate through ascription history looking for something.
        for i, asc in enumerate(ahist):
            ...

        # Return False or True if a shallow selector,
        # and 0 or 1-based history index if history selector.
        return ...

    return selector
</pre>
<p>It is customary to name the selector function <code class="function">selector_<em class="replaceable"><code>something</code></em></code>, where <em class="replaceable"><code>something</code></em> will also be used as the selector name (in command line, etc). The input <code class="varname">args</code> parameter is always a list of strings. It should first be validated, insofar as possible without having in hand the particular message, catalog, ascription history or ascription configuration. Whatever does not depend on any of these can also be precomputed for later use in the selector function.</p>
<p>The selector function takes as arguments the message (an instance of <a class="ulink" href="../../api/en_US/pology.message.Message_base-class.html" target="_top"><code class="classname">Message_base</code></a>), the catalog (<a class="ulink" href="../../api/en_US/pology.catalog.Catalog-class.html" target="_top"><code class="classname">Catalog</code></a>) it comes from, the ascription history (list of <a class="ulink" href="../../api/en_US/pology.ascript.AscPoint-class.html" target="_top"><code class="classname">AscPoint</code></a> objects), and the ascription configuration (<a class="ulink" href="../../api/en_US/pology.ascript.AscConfig-class.html" target="_top"><code class="classname">AscConfig</code></a>). For the most part, <code class="classname">AscPoint</code> and <code class="classname">AscConfig</code> are simple attribute objects; check their API documentation for the list and description of attributes. Some of the attributes of <code class="classname">AscPoint</code> objects that you will usually inspect are <code class="varname">.msg</code> (the historical version of the message), <code class="varname">.user</code> (the user to whom the ascription was made), or <code class="varname">.type</code> (the type of the ascription, one of <code class="varname">AscPoint.ATYPE_*</code> constants). The ascription history is sorted from the latest to the earliest ascription. If the <code class="varname">.user</code> of the first entry in the history is <code class="literal">None</code>, that means that the current version of the message has not been ascribed yet (e.g. if its translation has been modified compared to the latest ascribed version). If you are writing a shallow selector, it should return <code class="literal">True</code> to select the message, or <code class="literal">False</code> otherwise. In a history selector, the return value should be a 1-based index of an entry in the ascription history which caused the message to be selected, or <code class="literal">0</code> if the message was not selected.<sup>[<a name="idp16417504" href="#ftn.idp16417504" class="footnote" id="idp16417504">57</a>]</sup></p>
<p>The entry index returned by history selectors is used to compute embedded difference from a historical to the current version of the message, e.g. on <code class="literal">poascribe diff</code>. Note that <span class="command"><strong>poascribe</strong></span> will actually take as base for differencing the first non-fuzzy historical message <span class="emphasis"><em>after</em></span> the indexed one, because it is assumed that already the historical message which triggered the selection contains some changes to be inspected. (When this behavior is not sufficient, <span class="command"><strong>poascribe</strong></span> offers the user to specify a second history selector, which directly selects the historical message to base the difference on.)</p>
<p>Most of the time the selector will operate on messages covered by a single ascription configuration, which means that the ascription configuration argument sent to it will always be the same. On the other hand, the resolution of some of the arguments to the selector factory will depend only on the ascription configuration (e.g. a list of users). In this scenario, it would be waste of performance if such arguments were resolved anew in each call to the selector. You could instead write a small caching (memoizing) resolver function, which when called for the second and subsequent times with the same configuration object, returns previously resolved argument value from the cache. A few such caching resolvers for some common arguments have been provided in the <a class="ulink" href="../../api/en_US/pology.ascript-module.html" target="_top"><code class="literal">ascript</code></a> module, functions named <code class="function">cached_*()</code> (e.g. <a class="ulink" href="../../api/en_US/pology.ascript-module.html#cached_users" target="_top"><code class="function">cached_users()</code></a>).</p>
</div>
<div class="footnotes"><br>
<hr width="100" align="left">
<div class="footnote">
<p><sup>[<a name="ftn.idp6754464" href="#idp6754464" class="para" id="ftn.idp6754464">51</a>]</sup> In Python 2 to be precise, on which Pology is based, while in Python 3 there are only Unicode strings.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.idp10991984" href="#idp10991984" class="para" id="ftn.idp10991984">52</a>]</sup> The canonical way to check if message is a plural message is <code class="literal">msg.msgid_plural is not None</code>.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.idp6614928" href="#idp6614928" class="para" id="ftn.idp6614928">53</a>]</sup> There is also the <a class="ulink" href="../../api/en_US/pology.report-module.html" target="_top"><code class="literal">report</code></a> module for reporting general strings. In fact, all code in Pology distribution is expected to use function from these modules for writing to output streams, and there should not be a <code class="function">print</code> in sight.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.idp15884352" href="#idp15884352" class="para" id="ftn.idp15884352">54</a>]</sup> This holds only for catalogs created with monitoring, i.e. no <code class="literal">monitored=True</code> constructor argument. For non-monitored <code class="function">.sync()</code> will always touch the file and report <code class="literal">True</code>.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.idp15887504" href="#idp15887504" class="para" id="ftn.idp15887504">55</a>]</sup> As opposed to <a class="link" href="ch-sieve.html#sv-find-messages" title="3.5.17.&nbsp;find-messages">the <span class="command"><strong>find-messages</strong></span> sieve</a>.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.idp15193200" href="#idp15193200" class="para" id="ftn.idp15193200">56</a>]</sup> In fact, <code class="function">.add_last()</code> does a bit more: if both non-obsolete and obsolete messages are added in mixed order, in the catalog they will be separated such that all non-obsolete come before all obsolete, but otherwise maintaining the order of addition.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.idp16417504" href="#idp16417504" class="para" id="ftn.idp16417504">57</a>]</sup> In this way the history selector can automatically behave as shallow selector as well, because simply testing for falsity on the return value will show whether the message has been selected or not.</p>
</div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left"><a accesskey="p" href="ch-combined.html">Prev</a>&nbsp;</td>
<td width="20%" align="center">&nbsp;</td>
<td width="40%" align="right">&nbsp;</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter&nbsp;10.&nbsp;Combined Arms Tactics&nbsp;</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top">&nbsp;</td>
</tr>
</table>
</div>
</body>
</html>
