<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>pology.sieve</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="pology-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="pology-module.html">Package&nbsp;pology</a> ::
        Module&nbsp;sieve
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module sieve</h1><p class="nomargin-top"></p>
<p>Helpers for catalog sieves.</p>
  <p>Pology's <code>posieve</code> script processes catalogs with 
  &quot;sieves&quot;: objects to which catalog entries are fed one by one, 
  possibly with finalization phase at the end. This module contains only 
  some common helpers used by many sieves, and the following passages 
  primarily describe how sieves are written, and how clients that use them 
  should behave.</p>
  <h1 class="heading">Sieve Layout</h1>
    <p>Every sieve module must define the <code>Sieve</code> class, with 
    some mandatory and some optional interface methods and instance 
    variables. Here is a simple sieve which just counts the number of 
    translated messages:</p>
<pre class="literalblock">
   class Sieve (object):

       def __init__ (self, params):

           self.ntranslated = 0

       def process (self, msg, cat):

           if msg.translated:
               self.ntranslated += 1

       def finalize (self):

           report(&quot;Total translated: %d&quot; % self.ntranslated)
</pre>
    <p>The constructor takes as argument an object specifying any sieve 
    parameters (more on that below). The <code>process</code> method is the
    one which gets called for each message by the client, and must take the
    message (instance of <a href="pology.message.Message_base-class.html" 
    class="link">Message_base</a>) and the catalog which contains it (<a 
    href="pology.catalog.Catalog-class.html" class="link">Catalog</a>). The
    client calls the <code>finalize</code> method after no more messages 
    will be fed to the sieve, but this method needs not be defined (clients
    should check before placing the call); also, if <code>finalize</code> 
    is defined, clients are not obligated to call it.</p>
    <p>Another optional method is <code>process_header</code>, which is 
    called by the client for the header entry:</p>
<pre class="literalblock">
   def process_header (self, hdr, cat):
       # ...
</pre>
    <p>where <code>hdr</code> is an instance of <a 
    href="pology.header.Header-class.html" class="link">Header</a>, and 
    <code>cat</code> the containing catalog. Clients should check for the 
    presence of this method, and if it is defined, should call it prior to 
    any <code>process</code> call on the messages from the given catalog. 
    I.e. it is illegal for the client to switch a catalog between two calls
    to <code>process</code>, without calling <code>process_header</code> in
    between if it exists.</p>
    <p>There is also the optional <code>process_header_last</code> method, 
    which is just like <code>process_header</code>, except that, if 
    present, clients call it <i>after</i> all <code>process</code> calls on
    the given catalog:</p>
<pre class="literalblock">
   def process_header_last (self, hdr, cat):
       # ...
</pre>
    <p>Sieve methods should not abort the program execution in case of 
    errors, but throw an exception instead. In particular, if 
    <code>process</code> method throws an instance of <a 
    href="pology.sieve.SieveMessageError-class.html" 
    class="link">SieveMessageError</a>, it means that the sieve can still 
    process other messages in the same catalog; if it throws <a 
    href="pology.sieve.SieveCatalogError-class.html" 
    class="link">SieveCatalogError</a>, then any following messages in the 
    same catalog must be skipped, but other catalogs may be processed. 
    Similarly, if <code>process_header</code> throws <a 
    href="pology.sieve.SieveCatalogError-class.html" 
    class="link">SieveCatalogError</a>, then other catalogs may be 
    processed. Any other type of exception means that the sieve should no 
    longer be used.</p>
    <p><code>process</code> and <code>process_header</code> methods should 
    return <code>None</code> or an integer exit code. Return value which is
    neither <code>None</code> nor 0 indicates that while processing was 
    successfull (no exception thrown), the processed entry should not be 
    passed further along in a sieve chain.</p>
  <h1 class="heading">Parameter Handling</h1>
    <p>The <code>params</code> argument to the sieve constructor is an 
    object with data attributes that specify parameters influencing the 
    sieve operation. The sieve module defines <code>setup_sieve</code> 
    function, which the client calls with <a 
    href="pology.subcmd.SubcmdView-class.html" class="link">SubcmdView</a> 
    object as argument, to fill in the sieve description and define all 
    mandatory and optional parameters. Suppose that a sieve takes a 
    parameter named <code>checklevel</code>, stating the number of the 
    level at which to perform some checks. Here is how that sieve would 
    define this parameter:</p>
<pre class="literalblock">
   def setup_sieve (p):

       p.set_desc(&quot;An example sieve.&quot;)
       p.add_param(&quot;checklevel&quot;, int, defval=0,
                   desc=&quot;Validity checking level.&quot;)

   class Sieve (object):

       def __init__ (self, params):

           if params.checklevel &gt;= 1:
               # ...setup some level 1 validity checks...
           if params.checklevel &gt;= 2:
               # ...setup some level 2 validity checks...
           #...
</pre>
    <p>See <a href="pology.subcmd.SubcmdView-class.html#add_param" 
    class="link">add_param()</a> method for details on defining sieve 
    parameters.</p>
    <p>Client is not obliged to call <code>setup_sieve()</code>, but must 
    make sure that the <code>params</code> argument it sends to the sieve 
    has all the instance variable according to defined parameters.</p>
  <h1 class="heading">Catalog Regime Indicators</h1>
    <p>There are two boolean instance variables that the sieve may define, 
    and which the client may check for to decide on the regime in which the
    catalogs are opened and closed:</p>
<pre class="literalblock">
   def __init__ (self, params):

       # These are the defaults:
       self.caller_sync = True
       self.caller_monitored = True
</pre>
    <p><code>caller_sync</code> instructs the client whether the catalog 
    whose messages were fed to the sieve should be synced to disk 
    afterwards. If the sieve does not define this variable, the client 
    should assume <code>True</code> and sync the catalog. This variable is 
    typically set to <code>False</code> by sieves which do not modify 
    anything, as it is better for client performance not to sync the 
    catalog.</p>
    <p><code>caller_monitored</code> tells the client whether it should 
    open catalogs in monitored mode (see <a 
    href="pology.catalog.Catalog-class.html" class="link">Catalog</a> 
    instructor). If not defined, the client should assume it 
    <code>True</code>. This is another performance enhancer for the sieves 
    which do not modify entries.</p>
    <p>Most usually, the modifying sieve will set neither of these 
    variables (i.e. catalogs will be monitored and synced by default), 
    while the checker sieve will set both to <code>False</code>. A 
    modifying sieve which knows it will modify all messages may set only 
    <code>caller_monitored</code> to <code>False</code>, while leaving 
    <code>caller_sync</code> undefined (i.e. <code>True</code>).</p>
    <p>Note that if a sieve requests no monitoring and/or no syncing, the 
    client is not obliged to satisfy these requests. On the other hand, if 
    a sieve does request monitoring and/or syncing (either explicitly or by
    not defining them), the client must provide catalogs in that regime. 
    This is because there may be several sieves operating at the same time,
    and monitoring and syncing is usually necessary for the proper 
    operation of sieves that request it.</p>
  <h1 class="heading">Miscellaneous Remarks</h1>
    <p>Monitored catalogs have modification counters (see <a 
    href="pology.catalog.Catalog-class.html" class="link">Catalog</a> and 
    <a href="pology.message.Message-class.html" class="link">Message</a>), 
    which the sieve may use within its <code>process</code> method to find 
    out if any modification really took place. The proper way to do this is
    to recorder the current counter, and check for increase:</p>
<pre class="literalblock">
   def process (self, msg, cat):

       startcount = msg.modcount

       # ...
       # ... do some stuff
       # ...

       if msg.modcount &gt; startcount:
           self.nmodified += 1
</pre>
    <p>The <i>wrong</i> way to do it would be to merely check if 
    <code>msg.modcount &gt; 0</code>, because several modification sieves 
    may be operating at the same time, each increasing the counters.</p>
    <p>If the sieve wants to remove the message from the catalog, if at all
    possible it should use <code>remove_on_sync()</code> (see <a 
    href="pology.catalog.Catalog-class.html" class="link">Catalog</a>) 
    instead of <code>remove()</code> method. This is because 
    <code>remove()</code> will probably ruin the client's iteration over 
    the catalog, so if it must be used, the sieve documentation should 
    state it clearly.</p>
    <p>The sieves should be properly documented in their module comment. 
    The module comment should contain a short one line description of the 
    sieve, followed by paragraphs explaining its functionality, followed by
    list of sieve parameters. The <code>Sieve</code> class itself should 
    not be documented in general. Only if <code>process</code> and 
    <code>process_header</code> methods are returning an exit code, this 
    should be documented in their own comments.</p>
    <p>All methods of the <code>Sieve</code> class other than the above 
    stated standard interface methods should be kept private. If the sieve 
    module contains some more widely applicable methods, they should be 
    defined at the top level, outside of the <code>Sieve</code> class, and 
    properly documented.</p>

<hr />
<div class="fields">      <dl><dt>Authors:</dt>
        <dd>
          Chusslove Illich (&#1063;&#1072;&#1089;&#1083;&#1072;&#1074; &#1048;&#1083;&#1080;&#1115;) &lt;caslav.ilic@gmx.net&gt;,
          S&#233;bastien Renard &lt;sebastien.renard@digitalfox.org&gt;,
          Nicolas Ternisien &lt;nicolas.ternisien@gmail.com&gt;
        </dd>
      </dl>
      <p><strong>License:</strong>
        GPLv3
      </p>
</div><!-- ==================== CLASSES ==================== -->
<a name="section-Classes"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Classes</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="pology.sieve.SieveError-class.html" class="summary-name">SieveError</a><br />
      Base exception class for sieve errors with special meaning.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="pology.sieve.SieveMessageError-class.html" class="summary-name">SieveMessageError</a><br />
      Exception for single messages.
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="pology.sieve.SieveCatalogError-class.html" class="summary-name">SieveCatalogError</a><br />
      Exception for single catalogs.
    </td>
  </tr>
</table>
<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Functions</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">set of strings</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pology.sieve-module.html#parse_sieve_flags" class="summary-sig-name">parse_sieve_flags</a>(<span class="summary-sig-arg">msg</span>)</span><br />
      Extract sieve flags embedded in manual comments.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Variables</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="__package__"></a><span class="summary-name">__package__</span> = <code title="'pology'"><code class="variable-quote">'</code><code class="variable-string">pology</code><code class="variable-quote">'</code></code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Function Details</span></td>
</tr>
</table>
<a name="parse_sieve_flags"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">parse_sieve_flags</span>(<span class="sig-arg">msg</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Extract sieve flags embedded in manual comments.</p>
  <p>Sieve flags are put into manual comments with the following 
  syntax:</p>
<pre class="literalblock">
   # |, flag1, flag2, ...
</pre>
  <p>Some sieves will define certain sieve flags by which their behavior 
  can be altered on a particular message.</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>msg</code></strong> (Message) - message to parse</li>
    </ul></dd>
    <dt>Returns: set of strings</dt>
        <dd>parsed flags</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="pology-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
