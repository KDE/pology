<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="ch-sieve">

<title>Sieving</title>

<para>Translator may want to apply batch-type operations to every message in a single PO file or in collection of PO files, such as searching and replacing text, computing statistics, or validating. However, batch-processing tools for general plain text (<command>grep</command>, <command>sed</command>, <command>awk</command>, etc.) are not very well suited to processing PO files. For example, when looking for a particular word, a generic search tool will not see it if it contains an <link linkend="sec-poaccel">accelerator marker</link>; or, if looking for a two-word phrase, a generic tool will miss it if it is <link linkend="sec-powrap">wrapped</link>. Therefore many tools tailored specifically for batch-processing messages in PO files have been developed, such as those bundled with <ulink url="http://www.gnu.org/software/gettext/">Gettext</ulink> (<command>msggrep</command>, <command>msgfilter</command>, <command>msgattrib</command>...), or from <ulink url="http://translate.sourceforge.net/wiki/toolkit/index">Translate Toolkit</ulink> (<command>pocount</command>, <command>pogrep</command>, <command>pofilter</command>...).</para>

<para>Pology also provides a per-message batch-processing tool, the <command>posieve</command>. What was the need for it, given the myriad of other previously available and powerful tools? In accordance with philosophy of Pology, <command>posieve</command> goes deeper than these other tools. <command>posieve</command> makes easy that which is possible but awkward by combining generic command line tools. <command>posieve</command> is modular from the ground up, such that it is never a design problem to add new functionality to it, even when it is of narrow applicability. Users who know some Python can even write own "plugins" for it. Several processing modules can be applied in a single run of <command>posieve</command>, possibly affecting each other, in ways not possible by generic shell piping and not requiring temporary intermediate files.</para>

<!-- ======================================== -->
<sect1 id="sec-svbasics">
<title>Basic Usage</title>

<para>The <command>posieve</command> script itself is actually a simple shell which applies various processing modules, called <emphasis>sieves</emphasis>, to every message in one or more PO files. Some sieves can also request to operate on the header of the PO file, which <command>posieve</command> will then feed to them. A sieve can only examine but also modify messages; if any message is modified, by default the modified PO file will be written out in place. Naturally, <command>posieve</command> has a number of options, but more interestingly, each sieve can define some parameters which determine its behavior. Pology comes with many internal sieves, which do things from general to obscure (possibly language or project specific), and users can define their own sieves.</para>

<para>Here is how you would run the <link linkend="sv-stats"><command>stats</command></link> sieve to collect statistics on all PO files in <filename>frobaz/</filename> directory:
<programlisting>
$ posieve stats frobaz/
</programlisting>
While PO files in <filename>frobaz/</filename> are being processed, you will see a progress bar with the current file and the number of files to process, and after some time the <command>stats</command> sive will present its findings in a table.</para>

<para>The first non-option argument in the <command>posieve</command> command line is the sieve name, and then any number of directory or file paths can be specified.
<command>posieve</command> will consider file path arguments to be PO files, and recursively search directory paths to collect all files ending with <filename>.po</filename> or <filename>.pot</filename>. If no paths are specified, PO files to process will be collected from the current working directory.</para>

<para>If the sieve modifies a message and the new PO file is written out in place of the old, the user will be informed by an exclamation mark followed by the file path. An example of a sieve which modifies messages is the <link linkend="sv-tag-untranslated"><command>tag-untranslated</command></link> sieve; it adds
the <literal>untranslated</literal> flag to every untranslated message, so that you can look them up in a plain text editor (as opposed to <link linkend="sec-poedlist">dedicated PO editor</link>):
<programlisting>
$ posieve tag-untranslated frobaz/
! frobaz/alfa.po
! frobaz/bravo.po
! frobaz/charlie.po
Tagged 42 untranslated messages.
</programlisting>
<command>posieve</command> itself tracks message modifications and informs about modified PO files, whereas the final line in this example has been output by the <command>tag-untranslated</command> sieve. Sieves will frequently issue such final reports of their actions.</para>

<para>If a sieve defines some parameters to control its behavior, these can be issued using the <option>-s</option>. This option takes the parameter specification as the argument, which is of the form <literal><replaceable>name</replaceable>:<replaceable>value</replaceable></literal> or just <literal><replaceable>name</replaceable></literal> for switch-type parameters. More than one parameter can be issued by repeating the <option>-s</option>. For example, the <command>stats</command> sieve can be instructed to take into account only messages with at most 5 words:
<programlisting>
$ posieve stats -s maxwords:5 frobaz/
</programlisting>
to show statistics in greater detail:
<programlisting>
$ posieve stats -s detail frobaz/
</programlisting>
or to ignore a certain accelerator marker and show bar-type statistics instead of tabular:
<programlisting>
$ posieve stats -s accel:_ -s msgbar frobaz/
</programlisting>
</para>

<para><command>posieve</command> lists and shows descriptions of its options by the usual <option>-h</option>/<option>--help</option> option. Help for a sieve can be requested by issuing the <option>-H</option>/<option>--help-sieves</option> while a sieve name is present in the command line. All available internal sieves with short descriptions are listed using <option>-l</option>/<option>--list-sieves</option>.</para>

<para>Some sieves are language-specific, which can be seen by their names being of the form <command><replaceable>langcode</replaceable>:<replaceable>name</replaceable></command>. These sieves are primarily intendedfor use on PO files translated to indicated language, but depending on particularities, may be applicable to several more closely related languages. (A sieve which is doing language-specific things, but which is applicable to many languages, is more likely to be named as a general sieve.)</para>

<para>If <link linkend="sec-cmshellcomp">shell completion</link> is active, it can be used to complete sieve names and their parameters.</para>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-svchains">
<title>Sieve Chains</title>

<para>It is possible to issue several sieves at once, by passing a comma-separated list of sieve names to <command>posieve</command> in place of single sieve name. This is called a <emphasis>sieve chain</emphasis>.</para>

<para>At minimum, chaining sieves is a performance improving measure, since each PO file is opened (and possibly written out) only once, instead of on each sieve run. For example, you can in one run compute the statistics to see how many messages need to be update and tag all untranslated messages:
<programlisting>
$ posieve stats,tag-untranslated frobaz/
! frobaz/alfa.po
! frobaz/bravo.po
! frobaz/charlie.po
... (table with statistics) ...
Tagged 42 untranslated messages.
</programlisting>
A message in the PO file is passed through each sieve in turn, in the order in which they are issued, before proceding to the next message. If a sieve modifies the message, the next sieve in the chain will operate on that modified version of the message. This means that the ordering of sieves in the command line is significant in general, and that it is interchangable only if the sieves in the chain are independent of each other (as in this example). Chain order also determines the order in which sieve reports are shown; if in this example the order had been <literal>tag-untranslated,stats</literal>, then first the tagged messages line would be written out, followed by the statistics table.</para>

<para>Other than for performance, sieve chains are useful when messages should be modified in a particular way before a sieve gets to operate on it. A good example is when statistics is to be computed on PO files which contain old <link linkend="p-embctxt">embedded contexts</link>, where if nothing would be done, contexts would add to the word count of the original text. To avoid this, a <link linkend="sv-normctxt-sep">context normalization</link> sieve (which converts embedded contexts to <varname>msgctxt</varname>) can be chained with statistics sieve, and the <command>posieve</command> instructed not to write modifications to the PO file. If the embedded context is of the single-separator type, with separator character <literal>|</literal>, the sieve chain is:
<programlisting>
$ posieve --no-sync normctxt-sep,stats -s sep:'|' frobaz/
Converted 21 separator-embedded contexts.
... (table with statistics) ...
</programlisting>
The <option>--no-sync</option> option prevents writing modified messages in the PO file on disk. Note that <literal>|</literal> as parameter value is quoted, because it would be interpreted as a shell pipe otherwise.</para>

<para>Finally, some sieves can stop messages from being pushed further through the sieve chain, so they can be used as a prefilter to other sieves. The     archetypal example of this the <link linkend="sv-find-messages"><command>find-messages</command></link>, which stops non-matched messages from further sieving. For example, to include into statistics only the messages containing the word "quasar", this would be executed:
<programlisting>
$ posieve find-messages,stats -s msgid:quasar -s nomsg
Found 12 messages satisfying the conditions.
... (table with statistics) ...
</programlisting>
The <option>msgid:</option> parameter specifies the word (actually, a regular expression) to be looked up in the original text, while <option>nomsg</option> parameter tells <command>find-messages</command> not to write out matched messages to standard output, which it would by default do. Note that no path was specified, meaning that all PO files in current working directory and below will be sieved.</para>

<para>Examples of sieve chaining so far should have raised the following question: when several sieves are issued, to which of them are the parameters specified by <option>-s</option> options passed? The answer is that a parameter is sent to all sieves which accept parameter of that name. Continuing the previous example, if message texts can contain accelerator marker <literal>&amp;</literal>, this would be specified like this:
<programlisting>
$ posieve find-messages,stats -s msgid:quasar -s nomsg -s accel:'&amp;'
</programlisting>
<command>find-messages</command> will accept <option>accel</option> in order to also match messages like <literal>"Charybdis Q&amp;uasar"</literal>, while <command>stats</command> will use it to properly split text into words for counting them.</para>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-svoptions">
<title>Options</title>

<para>
Options specific to <command>posieve</command>:
<variablelist>

<varlistentry>
<term><option>-a</option>, <option>--announce-entry</option></term>
<listitem>
<para>A sieve may be buggy and crash or keep <command>posieve</command> in infinite loop on a particular PO entry (header or message). When this option is given, each PO entry will be announced before sieving it, so that you can see exactly where the problem occurs.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-b</option>, <option>--skip-obsolete</option></term>
<listitem>
<para>By default <command>posieve</command> will process all messages in the PO file, including the obsolete. Sometimes sieving obsolete messages is not desired, for example when running translation validation sieves. This option can then be used to skip obsolete messages.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-c</option>, <option>--msgfmt-check</option></term>
<listitem>
<para>For <command>posieve</command> to process the PO file, it is only necessary that basic PO syntax is valid, i.e. that <command>msgfmt</command> can compile the file. <command>msgfmt</command> also offers stricter validation mode: to have <command>posieve</command> run this stricter validation on the PO file, issue this option. Invalid files will be reported and will not be sieved.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>--force-sync</option></term>
<listitem>
<para>When some messages in the PO file are modified, by default only those messages will be reformatted (e.g. strings wrapped as selected) when the PO file is modified on disk. This makes <command>posieve</command> friendly to version control systems. Sometimes, however, you may want that all messages are reformatted, modified or not, and then you can issue this option.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-h</option>, <option>--help</option></term>
<listitem>
<para>General help on <command>posieve</command>.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-H</option>, <option>--help-sieves</option></term>
<listitem>
<para><option>-h</option>/<option>--help</option> shows only description of <command>posieve</command> and its options, while this option shows the descriptions and available parameters of issued sieves. For example:
<programlisting>
$ posieve find-messages,stats -H
</programlisting>
would output help for <command>find-messages</command> and <command>stats</command> sieves.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>--issued-params</option></term>
<listitem>
<para>List of all sieve parameters and their values that would be issued. Used to check <link linkend="p-svparconfcmd">the interplay of command line and configuration</link> on sieve parameters.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-l</option>, <option>--list-sieves</option></term>
<listitem>
<para>List of all internal sieves, with short descriptions.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>--list-options</option>; <option>--list-sieve-names</option>; <option>--list-sieve-params</option></term>
<listitem>
<para>Simple listings of global options, internal sieve names, and parameters of issued sieves. Intended mainly for writting shell completion definitions.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-m <replaceable>OUTFILE</replaceable></option>, <option>--output-modified=<replaceable>OUTFILE</replaceable></option></term>
<listitem>
<para>If some PO files were modified by sieving, you may want to follow up with a command to process only those files. <command>posieve</command> will by default output the paths of modified PO files, but also other information, which makes parsing this output for modified paths ungainly. Instead, this option can be used to specify a file to which path of all modified PO files will be written to, one per line.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>--no-skip</option></term>
<listitem>
<para>If a sieve reports an error, <command>posieve</command> normally skips the problematic message and continues sieving the rest of the PO file, if possible. This is sometimes not desired, when this option will tell <command>posieve</command> to abort with an error message in such cases.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>--no-sync</option></term>
<listitem>
<para>All messages modified by sieves are by default written back to disk, i.e. their PO files modifed. This option prevents modification of PO files. This comes handy in two cases. One is when you want to check what effect a modifying sieve will have before actually accepting it (a "dry" run). The other case is when you use a modifying sieve as a filter for the next sieve in chain, which only needs to examine messages.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-q</option>, <option>--quiet</option></term>
<listitem>
<para><command>posieve</command> normally shows the progress of sieving, which can be cancelled by this option. (Sieves will still output their own lines.)</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-s <replaceable>PARAM</replaceable>[:<replaceable>VALUE</replaceable>]</option></term>
<listitem>
<para>The central option of <command>posieve</command>, which is used to issue parameters to sieves.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-S <replaceable>PARAM</replaceable></option></term>
<listitem>
<para>When a sieve parameter is issued <link linkend="p-confsvpar">through user configuration</link>, this option can be used to cancel it for one particular run.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>--version</option></term>
<listitem>
<para>Release and copyright information on <command>posieve</command>.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-v</option>, <option>--verbose</option></term>
<listitem>
<para>More verbose output, where <command>posieve</command> shows the sieving modes, lists files which are being sieved, etc.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>
Options common with other Pology tools:
<variablelist>

<xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
            href="stdopt-filesfrom.docbook"/>

<xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
            href="stdopt-incexc.docbook"/>

<xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
            href="stdopt-colors.docbook"/>

</variablelist>
</para>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-svconfig">
<title>Configuration</title>

<para>The following <link linkend="sec-cmconfig">configuration</link> fields can be used to modify general behavior of <command>posieve</command>:
<variablelist>

<varlistentry>
<term><literal>[posieve]/skip-on-error=[*yes|no]</literal></term>
<listitem>
<para>Setting to <literal>no</literal> is counterpart to <option>--no-skip</option> command line option.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><literal>[posieve]/msgfmt-check=[yes|*no]</literal></term>
<listitem>
<para>Setting to <literal>yes</literal> is counterpart to <option>-c</option>/<option>--msgfmt-check</option> command line option.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><literal>[posieve]/skip-obsolete=[yes|*no]</literal></term>
<listitem>
<para>Setting to <literal>yes</literal> is counterpart to <option>-b</option>/<option>--skip-obsolete</option> command line option.</para>
</listitem>
</varlistentry>

</variablelist>
For configuration fields that have counterpart command line options, the command line option always takes precedence if issued.</para>

<para id="p-confsvpar">Configuration can also be used to issue sieve parameters, by specifying <literal>[posieve]/param-<replaceable>name</replaceable></literal> fields. For example, parameters <option>transl</option> (a switch) and <option>accel</option> (with value <literal>&amp;</literal>) are issued to all sieves that accept them by writing:
<programlisting>
[posieve]
param-transl = yes
param-accel = &amp;
</programlisting>
</para>

<para>To issue parameters only to certain sieves, parameter name can be followed
by a sieve list of the form <literal>/<replaceable>sieve1</replaceable>,<replaceable>sieve2</replaceable>,...</literal>; to <emphasis>prevent</emphasis> the parameter from being issued only to certain sieves, prepend <literal>~</literal> to the sieve list. For example:
<programlisting>
[posieve]
param-transl/find-messages = yes  # only for find-messages
param-accel/~stats = &amp;            # not for stats
</programlisting>
</para>

<para>Same parameters can sometimes be repeated in the command line, when it is logically meaningfull to provide several values of that type to a sieve. However, same-name fields cannot be used in configuration to supply several values, because they override each other. Instead, a dot and a unique string (within the sequence) can be appended to the parameter name to make it a unique configuration field:
<programlisting>
[posieve]
param-accel.0 = &amp;
param-accel.1 = _
</programlisting>
Strings after the dot can be anything, but a sequence of numbers or letters in alphabetical order is the least confusing choice.</para>

<para id="p-svparconfcmd">Sieve parameters should be issued from the configuration only as a matter of convenience, when they are almost always used in sieve runs. But occasionaly the parameter issued from the configuration is not appropriate for the given run. Instead of going to configuration and commenting the parameter out temporarily, it can be cancelled in the command line using the <option>-S</option> option (note capital S) followed by the parameter name. You can use <option>--issued-params</option> option to confirm which parameters will be issued after both the command line and the configuration have been taken into account.</para>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-svinternal">
<title>Internal Sieves</title>

<para>This section describes the sieves which are contained in Pology distribution and provides instruction for their use.</para>

<para><!--Some sieve parameters are mandatory, i.e. they have to be issued when the sieve is run. Parameters for which this is the case will have (*) added to their header in the parameter list.--> Parameters which take a value (which are not switches) may or may not have a default value, and when they do, it will be given in square brackets (<literal>[...]</literal>) in the header.</para>

<sect2 id="sv-apply-filter">
<title><command>apply-filter</command></title>

<para><command>apply-filter</command> is used to pipe translation through one or several <emphasis>hooks</emphasis> (see <xref linkend="sec-cmhooks"/>). The hooks may modify the translation, validate it, or do something else. More precisely, the following hook types are applicable:
<itemizedlist>
<listitem>
<para>F1A, F3A, F3C, to modify the translation and write changes back to the PO file;</para>
</listitem>
<listitem>
<para>V1A, V3A, V3C, to validate the translation, with standard validation output (highlighted spans and problem messages);</para>
</listitem>
<listitem>
<para>S1A, S3A, S3C, for any side-effect processing on translation (but no modification).</para>
</listitem>
</itemizedlist>
</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>filter:<replaceable>hookspec</replaceable></option></term>
<listitem>
<para>The hook specification. Can be repeated to add several hooks, which are then applied in the order of specification.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>showmsg</option></term>
<listitem>
<para>Report every modified message to standard output. (For validation hooks, message is automatically reported if not valid.)</para>
</listitem>
</varlistentry>

</variablelist>
</para>

</sect2>

<sect2 id="sv-apply-header-filter">
<title><command>apply-header-filter</command></title>

<para><command>apply-header-filter</command> is the counterpart to <command>apply-filter</command> to operate on headers instead of messages. Here the applicable hook types are accordingly F4B, V4B, S4B.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>filter:<replaceable>hookspec</replaceable></option></term>
<listitem>
<para>The hook specification. Can be repeated to add several hooks, which are then applied in the order of specification.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

</sect2>

<sect2 id="sv-bad-patterns">
<title><command>bad-patterns</command></title>

<para>Sometimes it is possible to use simple pattern matching to discover things that should never appear in the text, such as common grammar or orthographical errors. <command>bad-patterns</command> can apply such patterns to translation, either as plain substring matching or <link linkend="sec-cmregex">regular expressions</link>. Patterns can be given as parameters, or more conveniently, read from files.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>pattern:<replaceable>string</replaceable></option></term>
<listitem>
<para>The pattern to search for. Can be repeated to search for several patterns.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>fromfile:<replaceable>path</replaceable></option></term>
<listitem>
<para>Read patterns to search for from the file. Each line contains one pattern. If line starts with <literal>#</literal>, it is treated as comment. Empty lines are ignored. Trailing and leading whitespace is removed from patterns; if it is significant, it can be given inside <literal>[...]</literal> regex operator. This parameter can be repeated to read patterns from several files.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>rxmatch</option></term>
<listitem>
<para>By default patterns are treated as plain substrings. This parameter requests to treat patterns as regular expressions.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>casesens</option></term>
<listitem>
<para>By default patterns are case-sensitive. This parameter make them case-insensitive.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<caution><para>This sieve is deprecated. Use <link linkend="sv-check-rules"><command>check-rules</command></link> instead, which applies Pology's <link linkend="sec-lgrules">validation rules</link>.</para></caution>

</sect2>

<sect2 id="sv-check-docbook4">
<title><command>check-docbook4</command></title>

<para><command>check-docbook4</command> checks PO files extracted from Docbook 4.x files. Docbook is an XML format, typically used for documenting software.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>showmsg</option></term>
<listitem>
<para>Instead of just showing the message location and problem description, also show the complete message with problematic segments higlighted.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>lokalize</option></term>
<listitem>
<para>Open the PO file on reported messages in Lokalize.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>Currently performed checks:
<itemizedlist>

<listitem>
<para>Markup validity. Docbook is a complex XML format, and nothing short of full validation of XML files generated from translated PO files can show if the translation is technically valid. Therefore <command>check-docbook4</command> checks only well-formedness, whether tags are defined by Docbook, and some nesting constraints, and that on the level of single message. But this is already enough to catch great majority of usual translation errors.</para>

<para>This check can be skipped on a message by adding to it the <literal>no-check-markup</literal> <link linkend="p-trflag">translator flag</link>.</para>
</listitem>

<listitem>
<para>Message insertion placeholders. Some extractors of Docbook split out into standalone messages contextually separate units that are found in the middle of flowing paragraphs (e.g. footnotes). When that happens, a special placeholder is left in the originating message, so that the markup can be reconstructed when the translated Docbook file is built. Such placeholders must be carried into translation.</para>
</listitem>

</itemizedlist>
</para>

</sect2>

<sect2 id="sv-check-grammar">
<title><command>check-grammar</command></title>

<para><command>check-grammar</command> checks translation with LanguageTool, an open source grammar and style checker (<ulink url="http://www.languagetool.org/">http://www.languagetool.org/</ulink>). LanguageTool supports a number of languages to greater or smaller extent, which you can check on <ulink url="http://www.languagetool.org/languages/">its web site</ulink>.</para>

<para>LanguageTool can be run as standalone program or in client-server mode, and this sieve expects the latter. This means that LanguageTool has to be up and running before this sieve is run. Messages in which problems are discovered are reported to standard output.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>lang:<replaceable>code</replaceable></option></term>
<listitem>
<para>The language code for which to apply the rules. If not given, it will be read from each PO file in turn, and if not found there either, an error will be signaled.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>host:<replaceable>hostname</replaceable></option> [<literal>localhost</literal>]</term>
<listitem>
<para>Name of the host where the LanguageTool server is running. The default value of <literal>localhost</literal> means that it is running on the same computer where the sieve is run.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>port:<replaceable>number</replaceable></option> [<literal>8081</literal>]</term>
<listitem>
<para>TCP port of the host on which the LanguageTool server listens for queries.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

</sect2>

<sect2 id="sv-check-kde4">
<title><command>check-kde4</command></title>

<para><command>check-kde4</command> checks PO files extracted from program code based on KDE4 library and its translation system. Note that this really means what it says; this sieve should <emphasis>not</emphasis> be used to check just any PO file which happens to be part of the KDE project (e.g. PO files covering .desktop files, pure Qt code, etc.).</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>strict</option></term>
<listitem>
<para>Partly due to historical reasons, and partly due to programmers being sloppy, the original text itself is sometimes not valid by some checks. By default, when the original is not valid, the translation is not expected to be valid either, i.e. it is not checked. This parameter requires that the translation is always checked, regardless of the validity of the original (problems can almost always be avoided in the translation).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>lokalize</option></term>
<listitem>
<para>Open the PO file on reported messages in Lokalize.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>Currently performed checks:
<itemizedlist>

<listitem>
<para>Markup validity. KDE4 messages can contain a mix of <ulink url="http://techbase.kde.org/Development/Tutorials/Localization/i18n_Semantics">KUIT</ulink> and <ulink url="http://doc.qt.nokia.com/4.6/richtext-html-subset.html">Qt rich text</ulink> markup. Although Qt rich text does not have to be well-formed in XML sense, this check expects well-formedness to be preserved in translation if the original is such (also see the <option>strict</option> parameter).</para>

<para>This check can be skipped on a message by adding to it the <literal>no-check-markup</literal> <link linkend="p-trflag">translator flag</link>.</para>
</listitem>

</itemizedlist>
</para>

</sect2>

<sect2 id="sv-check-rules">
<title><command>check-rules</command></title>

<para><command>check-rules</command> applies language- and project-dependent Pology <emphasis>validation rules</emphasis> to translation. See <xref linkend="sec-lgrules"/> for detailed discussion on writing and applying rules.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>lang:<replaceable>code</replaceable></option></term>
<listitem>
<para>The language code for which to apply the rules. If not given, it will be each PO file in turn, and if not found there either, an will be signaled.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>env:<replaceable>environment></replaceable></option></term>
<listitem>
<para>The language environment for which to apply the rules (see <xref linkend="sec-lglangenv"/>). Several environments can be given as comma-separated list, in which case the later environment in the list takes precedence on conflicted rules. If not given, it may also be read from PO files (see <link linkend="hdr-x-environment"><literal>X-Environment</literal></link> in <xref linkend="sec-cmheader"/>).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>envonly</option></term>
<listitem>
<para>When language environment is given, only the rules explicitly belonging to it are applied, while general rules for the selected language are ignored.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>rule:<replaceable>identifiers</replaceable></option></term>
<listitem>
<para>Comma-separated list of rule identifiers, to apply only those rules. If a rule selected in this way is disabled in its definition, this enables it.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>rulerx:<replaceable>regexes</replaceable></option></term>
<listitem>
<para>Like <option>rule</option>, but the values are interpreted as regular expressions by which to match rule identifiers.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>norule:<replaceable>identifiers</replaceable></option></term>
<listitem>
<para>Inverse of the <option>rule</option> parameter: selected rules are not applied, and all other are applied.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>norulerx:<replaceable>regexes</replaceable></option></term>
<listitem>
<para>Inverse of the <option>rulerx</option> parameter: selected rules are not applied, and all other are applied.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>stat</option></term>
<listitem>
<para>Rules can take time to apply to all sieved PO files, and this parameter requests to write out some statistics of rule application at the end of sieving.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>accel:<replaceable>characters</replaceable></option></term>
<listitem>
<para>Characters to consider as <link linkend="sec-poaccel">accelerator markers</link>. If not given, they may be read from sieved PO files. Note that this parameter in itself does nothing: it only makes it possible for a particular rule or group of rules to remove the accelerator before matching.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>markup:<replaceable>types</replaceable></option></term>
<listitem>
<para>The type of text markup used in messages, by keyword. It can also be a comma-separated list of keywords. If not given, it may be read from sieved PO files. See description of <link linkend="hdr-x-text-markup"><literal>X-Text-Markup</literal></link> in <xref linkend="sec-cmheader"/> for the list of markup keywords currently known to Pology. Similarly to <option>accel</option> parameter, this parameter only enables rules to remove the markup (or do something else) before matching.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>xml:<replaceable>file</replaceable></option></term>
<listitem>
<para>By default, messages failed by rules are reported to standard output, and this parameter requests that they be written into a custom (but simple) XML format.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>rfile:<replaceable>file</replaceable></option></term>
<listitem>
<para>By default internal Pology rules are applied, and this parameter can be used to apply external rules instead, defined in the given rule file.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>rdir:<replaceable>directory</replaceable></option></term>
<listitem>
<para>Like <option>rfile</option>, but external rules are read from a directory containing any number of rule files.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>branch:<replaceable>branch</replaceable></option></term>
<listitem>
<para>Apply rules only to messages from given branch (<link linkend="ch-summit">summit</link>).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>showfmsg</option></term>
<listitem>
<para>Rules are sometimes applied to the filtered instead of the original message, and when such message is failed, it may not be obvious what triggered the rule. This parameter requests that the filtered message is written out too when the original message is reported.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>nomsg</option></term>
<listitem>
<para>When a message is failed, by default it is output in full together with the problem description. This parameter requests that only the problem description is output.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>lokalize</option></term>
<listitem>
<para>Open the PO file on reported messages in Lokalize.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>One or more rules can be disabled on a particular message in the PO file itself, by adding a special translator comment that starts with <literal>skip-rule:</literal> and continues with comma-separated list of rule identifiers:
<programlisting>
# skip-rule: <replaceable>ruleid1</replaceable>, <replaceable>ruleid2</replaceable>, ...
</programlisting>
</para>

</sect2>

<sect2 id="sv-check-spell">
<title><command>check-spell</command></title>

<para><command>check-spell</command> checks spelling of translation by splitting it into words and passing them through GNU Aspell (<ulink url="http://aspell.net/">http://aspell.net/</ulink>). This sieve is a more specific counterpart to <link linkend="sv-check-spell-ec"><command>check-spell-ec</command></link>, which exposes some options specific to Aspell and requires no external Python modules, only the Aspell installation. Also read <xref linkend="sec-lgspell"/> for details on spell-checking in Pology.</para>

<para><command>check-spell</command> behaves mostly the same as <command>check-spell-ec</command>, and accepts all the same parameters with same meanings; the exception is the <option>provider</option> parameter, which is not present here since Aspell is the fixed provider. Only the parameters specific to this sieve are described in the following:
<variablelist>

<varlistentry>
<term><option>enc:<replaceable>encoding</replaceable></option></term>
<listitem>
<para>The encoding in which the text should be sent to Aspell.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>var:<replaceable>variety</replaceable></option></term>
<listitem>
<para>The variety of the Aspell dictionary, if any.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>xml:<replaceable>file</replaceable></option></term>
<listitem>
<para>By default, messages with unknown words are reported to standard output, and this parameter requests that they be written into a custom (but simple) XML format.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>Aspell can be configured for use in Pology through user configuration, so that it is not necessary to issue some parameters on every run. See <xref linkend="sec-cmcfgaspell"/>.</para>

</sect2>

<sect2 id="sv-check-spell-ec">
<title><command>check-spell-ec</command></title>

<para><command>check-spell-ec</command> uses the Enchant library (<ulink url="http://www.abisource.com/projects/enchant/">http://www.abisource.com/projects/enchant/</ulink>) through PyEnchant Python module (<ulink url="http://pyenchant.sourceforge.net">http://pyenchant.sourceforge.net</ulink>) to provide uniform access to different spell-checkers, such as Aspell, Ispell, Hunspell, etc. Translation is first split into words, possibly eliminating markup and other literal content, and the words are then fed to spell-checker. Messages containing unknown words are reported to standard output, with list of replacement suggestions.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>provider:<replaceable>keyword</replaceable></option></term>
<listitem>
<para>The spell-checker that Enchant should use. The value is one of keywords defined by Enchant (e.g. <literal>aspell</literal>, <literal>hunspell</literal>...), and can be seen by running <command>enchant-lsmod</command> command (only providers available on the system are shown). If not given either by this parameter or in user configuration, Enchant will try to select a provider on its own.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>lang:<replaceable>code</replaceable></option></term>
<listitem>
<para>The language code for which the spelling is checked. If not given, it will be read from each PO file in turn, and if not found there either, an error will be signaled.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>env:<replaceable>environment></replaceable></option></term>
<listitem>
<para>The language environment for which to include supplemental dictionaries (see <xref linkend="sec-lglangenv"/>). Several environments can be given as comma-separated list, in which case the union of their dictionaries is used. If not given, environments may be read from PO files (see <link linkend="hdr-x-environment"><literal>X-Environment</literal></link> in <xref linkend="sec-cmheader"/>) or from user configuration.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>accel:<replaceable>characters</replaceable></option></term>
<listitem>
<para>Characters to consider as <link linkend="sec-poaccel">accelerator markers</link>, to remove them before splitting text into words. If not given, they may be read from PO files (see <link linkend="hdr-x-accelerator-marker"><literal>X-Acclerator-Marker</literal></link> in <xref linkend="sec-cmheader"/>).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>markup:<replaceable>types</replaceable></option></term>
<listitem>
<para>The type of text markup used in messages, by keyword. It can also be a comma-separated list of keywords. If not given, it may be read from PO files (see <link linkend="hdr-x-text-markup"><literal>X-Text-Markup</literal></link> in <xref linkend="sec-cmheader"/>; there the list of markup keywords currently known to Pology is given as well).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>skip:<replaceable>regex</replaceable></option></term>
<listitem>
<para>Words matched by this regular expression are not sent to spell-checker.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>filter:<replaceable>hookspec</replaceable></option></term>
<listitem>
<para>The hook to modify the text before splitting into words and spell-checking them (see <xref linkend="sec-cmhooks"/>). The hook type must be F1A, F3A, or F3C. The parameter can be repeated to add several hooks, which are then applied in the order of specification.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>suponly</option></term>
<listitem>
<para>By default, internal supplemental spelling dictionaries are added to the system dictionary of the selected spell-checker. This parameter can be issued to instead use only internal dictionaries and not the system dictionary.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>list</option></term>
<listitem>
<para>By default, when an unknown word is found, the complete message is output, with the problematic word highlighted and possibly the replacement suggestions. With this parameter, only a plain sorted list of unknown words, one per line, is output at the end of sieving. This is useful when a lot of false positives are expected, to quickly add them to the supplemental dictionary.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>lokalize</option></term>
<listitem>
<para>Open the PO file on messages containing unknown words in Lokalize.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para><command>check-spell-ec</command> may be told to skip checking specific messages and words, and it may use internal supplemental spelling dictionaries. See <xref linkend="sec-lgspell"/> for these and other details on spell-checking in Pology.</para>

<para>Enchant can be configured for use in Pology through user configuration, so that it is not necessary to issue some parameters on every run. See <xref linkend="sec-cmcfgenchant"/>.</para>

</sect2>

<sect2 id="sv-check-tp-kde">
<title><command>check-tp-kde</command></title>

<para>The <ulink url="http://l10n.kde.org/">KDE Translation Project</ulink> contains a great number of PO files extracted from various types of sources. This results in that for each message, there are things that the translation can, must or must not contain, for the translation to be technically valid. When run over PO files within the KDE TP, <command>check-tp-kde</command> will first try to determine the type of each message and then apply appropriate technical checks to it. Message type is determined based on file location, file header, message flags and contexts; even a particular message in a particular file may be checked for some very specific issue.</para>

<para id="p-techprob">"Technical" issues are those which should be fixed regardless of the language and style of translation, because they can lead to loss of functionality, information or presentation to the user. For example, a technical issue would be badly paired XML tags in translation, when in the original they were well paired; a non-technical issue (and thus not checked) would be when the original ends with a certain punctuation, but translation does not -- whether such details are errors or not, depends on the target language and translation style.</para>

<para>For the sieve to function properly, it needs to detect the project subdirectory of each PO file up to topmost division within the branch, e.g. <filename>messages/kdebase</filename> <filename>docmessages/kdegames</filename>. This means that the local copy of the repository tree needs to follow the repository layout up to that point, e.g. <filename>kde-trunk-ui/kdebase</filename> and <filename>kde-trunk-doc/kdegames</filename> would not be valid local paths.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>strict</option></term>
<listitem>
<para>Sometimes the original text itself may not be valid against a certain check. When this is the case, by default the translation is not expected to be valid either, and the check is skipped. Issuing this parameter will force all checks on translation, regardless of whether the original is valid or not. It may still be possible to avoid some checks on those messages that just cannot be repared through translation, if those checks define their own mechanism of cancelation (like adding a special translator comment).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>check:<replaceable>keywords</replaceable></option></term>
<listitem>
<para>Comma-separated list of checks to apply, by keyword, instead of all. Available checks are listed below.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>showmsg</option></term>
<listitem>
<para>By default, when the message does not pass a check, only its location and the problem are reported. This parameter requests that message is reported in total, possibly with problematic segments of translation highlighted.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>lokalize</option></term>
<listitem>
<para>Open the PO file on reported messages in Lokalize.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>Currently available checks (keyword in parenthesis):
<itemizedlist>

<listitem>
<para>KDE4 markup checking (<literal>kde4markup</literal>).</para>
</listitem>

<listitem>
<para>Qt markup checking (<literal>qtmarkup</literal>).</para>
</listitem>

<listitem>
<para>Docbook markup checking (<literal>dbmarkup</literal>)</para>
</listitem>

<listitem>
<para>No translation scripting in "dumb" messages (<literal>nots</literal>). Translations fetched at runtime by KDE4 translation system may use <ulink url="http://techbase.kde.org/Localization/Concepts/Transcript">translation scripting</ulink>. This check will make sure that scripting is not attempted for other types of messages (used by Qt-only code, for .desktop files, etc.).</para>
</listitem>

<listitem>
<para>Qt datetime format messages (<literal>qtdt</literal>). A message is considered to be in this format if it contains the string <literal>qtdt-format</literal> in its <varname>msgctxt</varname> string or among flags.</para>
</listitem>

<listitem>
<para>Validity of translator credits (<literal>trcredits</literal>). PO files may contain meta-messages to input translator credits, which should have both valid translations on their own and some congruence between them.</para>
</listitem>

<listitem>
<para>Query placeholders in Plasma runners (<literal>plrunq</literal>). Messages in Plasma runners may contain special query placeholder <literal>:q:</literal>, which should be present in translation too.</para>
</listitem>

<listitem>
<para>File-specific checking (<literal>catspec</literal>). Certain messages in certain PO files have special validity requirements, and this check activates all such file-specific checks.</para>
</listitem>

</itemizedlist>
</para>

<para>All markup checks can be skipped on a message by adding the <literal>no-check-markup</literal> <link linkend="p-trflag">translator flag</link>.</para>

</sect2>

<sect2 id="sv-check-tp-wesnoth">
<title><command>check-tp-wesnoth</command></title>

<para>PO files of <ulink url="http://www.wesnoth.org/">The Battle of Wesnoth</ulink> contain a mix of well-known and custom markup and format directives. <command>check-tp-wesnoth</command> heuristically determines the type of each message in a Wesnoth PO file and applies appropriate technical checks to it (where "technical" has the same meaning as in <link linkend="p-techprob">the <command>check-tp-kde</command> sieve</link>).</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>check:<replaceable>keywords</replaceable></option></term>
<listitem>
<para>Comma-separated list of checks to apply, by keyword, instead of all. Available checks are listed below.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>showmsg</option></term>
<listitem>
<para>Instead of just showing the message location and problem description, also show the complete message, possibly with higlighted problematic segments.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>lokalize</option></term>
<listitem>
<para>Open the PO file on reported messages in Lokalize.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>Currently available checks (keyword in parenthesis):
<itemizedlist>

<listitem>
<para> (<literal></literal>).</para>
</listitem>

<listitem>
<para>Stray context separators in translation (<literal>ctxtsep</literal>). Wesnoth is still embedding disambiguating context into <varname>msgid</varname>, by putting it in front of the actual text and separated by <literal>^</literal>. An unwary translator will sometimes mistakes such context for part of the original text, and translate it too.</para>
</listitem>

<listitem>
<para>Congruence of WML interpolations (<literal>interp</literal>). WML interpolations look like <literal>"...side $side_number is..."</literal> and normally must match between the original and translation, or else the player would loose information. Only in very rare cases (e.g. some plurals and Markov chain generators) some interpolations may be missing in translation, and then they can be listed space-separated in a translator comment to silence the check:
<programlisting>
# ignore-interpolations: <replaceable>interp1</replaceable> <replaceable>interp2</replaceable> ...
</programlisting>
(the <literal>$</literal> character is not necessary in the list).
</para>
</listitem>

<listitem>
<para>WML markup checking (<literal>wml</literal>). If WML in translation is not valid, player may see some visual artifacts. Also, links in WML must match between original and translation, to avoid loss of information.</para>
</listitem>

<listitem>
<para>Pango markup checking (<literal>pango</literal>). Pango is used in some places for visual text markup instead of WML.</para>
</listitem>

<listitem>
<para>Congruence of leading and trailing space (<literal>space</literal>). For many languages, significant leading and trailing space from the original should be preserved. A heuristic is used to determine when leading or trailing space is significant. Only languages explicitly specified internally are checked for this.</para>
</listitem>

<listitem>
<para>Docbook validity (<literal>docbook</literal>). Docbook is actually not used as a source format anywhere in Wesnoth, but the Wesnoth manual is converted into Docbook specifically to facilitate translation (weird as it may sound).</para>
</listitem>

</itemizedlist>
</para>

</sect2>

<sect2 id="sv-collect-pmap">
<title><command>collect-pmap</command></title>

<para><emphasis>Property maps</emphasis> (or <emphasis>pmaps</emphasis> for short) are one way in which arbitrary properties of language phrases can be defined for use in scripted translations, such as provided by <ulink url="http://techbase.kde.org/Localization/Concepts/Transcript">Transcript</ulink>, the translation scripting system in KDE 4.</para>

<para>A property map is a text file with a number of entries, each defining the properties of a certain phrase. A pmap entry starts with one or more keys and continues with arbitrary number of key-value properties. An example entry would be grammar declinations of a noun:
<programlisting>
=/Athens/Atina/nom=Atina/gen=Atine/dat=Atini/acc=Atinu//
</programlisting>
The first two characters define, in order, the key-value separator (here <literal>=</literal>) and the property separator (here <literal>/</literal>) for the current entry. The two separators can be any non-alphanumeric characters, and must be different. Then follows a number of entry keys, delimited by property separators, and then a number of key-value properties, each internaly delimited by the key-value separator. The entry is terminated by double property separator. Properties of an entry can be fetched in the translation scripting system by any of the entry keys; keys are case- and whitespace-insensitive.</para>

<para><command>collect-pmap</command> will parse pmap entries from manual comments in messages, collect them, and write out a property map file. It is not necessary to explicitly specify entry keys, since the contents of <varname>msgid</varname> and <varname>msgstr</varname> are automatically added as keys. Since each manual comment is one line, it is also allowed to drop
the final double separator which would normally terminate the entry.
The above example would thus look like this in a PO message:
<programlisting>
# pmap: =/nom=Atina/gen=Atine/dat=Atini/acc=Atinu/
msgctxt "Greece/city"
msgid "Athens"
msgstr "Atina"
</programlisting>
The manual comment starts with <literal>pmap:</literal> keyword, which is followed by a normal pmap entry, except for missing keys (but additional keys can be specified when <varname>msgid</varname> and <varname>msgstr</varname> are not sufficient). It is also possible to split the entry into several comments,
with only condition that all share the same set of separators:
<programlisting>
# pmap: =/nom=Atina/gen=Atine/
# pmap: =/dat=Atini/acc=Atinu/
</programlisting>
After collecting pmap entries from all processed PO files, if two or more entries end up having same keys, they are all removed from the collection and a warning is reported.</para>

<para>Pmap entries are collected only from translated, non-plural messages.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>outfile:<replaceable>file</replaceable></option></term>
<listitem>
<para>File path into which the property map should be written. If not given, nothing is written out; this is useful for validating entries.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>propcons:<replaceable>file</replaceable></option></term>
<listitem>
<para>Path to the file which defines constraints on property keys and values, used to validate parsed entries (see <xref linkend="sec-svvalpmap"/>).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>extrakeys</option></term>
<listitem>
<para>By default, it is actually not possible to add any aditional entry keys besides the automatically added <varname>msgid</varname> and <varname>msgstr</varname>. This gives extra safety against errors, such as translator mistyping the key-value pair. If additional keys are actually needed, this parameter can be issued to accept them.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>derivs:<replaceable>file</replaceable></option></term>
<listitem>
<para>Path to the file which defines derivators for synder entries (see <xref linkend="sec-svsynder"/>).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>pmhead:<replaceable>string</replaceable></option></term>
<listitem>
<para>Default <literal>pmap:</literal> as entry prefix may not be the most convenient; for example, when the language of translation is not written with Latin script. This parameter makes makes it possibly to use an arbitrary string for the entry prefix.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>sdhead:<replaceable>string</replaceable></option></term>
<listitem>
<para>Like <option>pmhead</option>, but for prefix to synder entries, instead of the default <literal>synder:</literal> (see <xref linkend="sec-svsynder"/>).</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<sect3 id="sec-svsynder">
<title>Derivating Entries</title>

<para>There is another, more succint way to define pmap entries in comments. Instead of writting out all key-value combinations, it is possible instead to generate them by using <emphasis>syntagma derivators</emphasis> (or <emphasis>synders</emphasis>) for short. From the earlier example:
<programlisting>
# pmap: =/nom=Atina/gen=Atine/dat=Atini/acc=Atinu/
</programlisting>
it can be observed that each form has the same root, <literal>Atin</literal>, followed by the appropriate ending for that form type. This makes it convenient
to reformulate it as a syntagma derivation:
<programlisting>
# synder: Atin|a
</programlisting>
Here <literal>|a</literal> is a <emphasis>derivator</emphasis>; all derivators are defined in a separate synder file (with <filename>.sd</filename> extension by convention) and made known to the sieve through the <option>derivs</option> parameter. The derivator in this example would be defined like this:
<programlisting>
|a: nom=a, gen=e, dat=i, acc=u
</programlisting>
First comes the derivator name, starting with <literal>|</literal> and ending with <literal>:</literal>, and then the comma-separated list of key-value pairs  similar as in the pmap entry, except that now only the endings for the given form are specified. Synders are actually a standalone subsystem of Pology, see <xref linkend="sec-lgsynder"/> for all details.</para>

<para>It is possible to mix pmap (<literal># pmap: ...</literal>) and synder (<literal># synder: ...</literal>) entries in translator comments. For example, synder entries may be used to cover majority of cases, which follow the general language rules, while pmap entries can be used for exceptions.</para>

<para>On the other hand, every pmap entry can be reformulated as a synder entry which does not refer to an external derivator:
<programlisting>
# synder: nom=Atina, gen=Atine, dat=Atini, acc=Atinu
</programlisting>
This begs the question of what is the need for pmap entries at all, if synder entries can be used in the same capacity and beyond? Pmap entries are still useful because synders have a lot of special syntax and rules to keep in mind (e.g. what if the phrase itself contains a comma?), while raw pmaps have none past what was described above.</para>

</sect3>

<sect3 id="sec-svvalpmap">
<title>Validating Entries</title>

<para>The <literal>propcons</literal> parameter can be used to specify a file which defines constraints on acceptable property keys, and on values by each key. Its format is the following:
<programlisting>
# Full-line comment.
/key_regex_1/value_regex_1/flags # a trailing comment
/key_regex_2/value_regex_2/flags
:key_regex_3:value_regex_3:flags # different separator
# etc.
</programlisting>
Regular expressions for keys and values are delimited by a separator defined by first non-whitespace character in the line, which must also be non-alphanumeric. Before being compiled, regular expressions are automatically wrapped as <literal>^(<replaceable>regex</replaceable>)$</literal>, so that an expression to require a certain prefix is given as <literal><replaceable>prefix</replaceable>.*</literal> and a suffix as <literal>.*<replaceable>suffix</replaceable></literal>. A property key must match one of the key regexs, or else it is considered invalid. Value to that property must then match the value regexes attached to all matched key regexes.</para>

<para>For example, a constraint file defining no constraints on either
property keys or values is:
<programlisting>
/.*/.*/
</programlisting>
while a file explicitly listing all allowed property keys, and constraining values to some of them, would be:
<programlisting>
/nom|gen|dat|acc/.*/
/gender/m|f|n/
/number/s|p/
</programlisting>
</para>

<para>The last separator in the constraint can be followed by a string of single-character flags. These flags are currently defined:
<itemizedlist>
<listitem>
<para><literal>i</literal>: case-insensitive matching for the value.</para>
</listitem>
<listitem>
<para><literal>I</literal>: case-insensitive matching for the key.</para>
</listitem>
<listitem>
<para><literal>t</literal>: the value must both match the regular expression and be equal to <varname>msgstr</varname>. If <literal>i</literal> flag is added too, equality check is also case-insensitive.</para>
</listitem>
<listitem>
<para><literal>r</literal>: regular expression for the key must match at least one key among all defined properties.</para>
</listitem>
</itemizedlist>
</para>

<para>Constraint definition file must be encoded with UTF-8.</para>

</sect3>

</sect2>

<sect2 id="sv-diff-previous">
<title><command>diff-previous</command></title>

<para>When PO files are merged with <option>--previous</option> option to <command>msgmerge</command>, fuzzy messages will retain the previous version of original text (<varname>msgctxt</varname>, <varname>msgid</varname> and <varname>msgid_plural</varname>) under <literal>#|</literal> comments. Then <command>diff-previous</command> can be used to embedded differences from previous to current original into previous original strings. For example, the message:
<programlisting>
#: main.c:110
#, fuzzy
#| msgid "The Record of The Witch River"
msgid "Records of The Witch River"
msgstr "Beleška o Veštičjoj reci"
</programlisting>
will become after sieving:
<programlisting>
#: main.c:110
#, fuzzy
#| msgid "{-The Record-}{+Records+} of The Witch River"
msgid "Records of The Witch River"
msgstr "Beleška o Veštičjoj reci"
</programlisting>
Text editors may even provide highlighting for the wrapped difference segments
(e.g. Kwrite/Kate).</para>

<para>This sieve is very useful if your PO editor does not show differences in the original by itself. To be able to easily see exactly what was changed in the original is important both for efficiency and for quality. Think of a long paragraph in which only one word was changed: without a diff it will take you time to reread it, and you may even miss that changed word.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>strip</option></term>
<listitem>
<para>Instead of embedding diffs, remove them from messages, recovering the original form of previous strings. This is useful if you did not update all fuzzy messages but you anyway want to send the PO file away (commit it to the repository, etc.).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>branch:<replaceable>branch</replaceable></option></term>
<listitem>
<para>Embed diffs only into messages from given branch (<link linkend="ch-summit">summit</link>).</para>
</listitem>
</varlistentry>

</variablelist>
</para>

</sect2>

<sect2 id="sv-empty-fuzzies">
<title><command>empty-fuzzies</command></title>

<para>For every fuzzy message, <command>empty-fuzzies</command> removes the translation and fuzzy data (the <literal>fuzzy</literal> flag, previous strings). Translator comments are kept by default, but they can be removed as well. Obsolete fuzzy messages are completely removed.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>rmcomments</option></term>
<listitem>
<para>Also remove translator comments from fuzzy messages.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>noprev</option></term>
<listitem>
<para>Empty only those fuzzy messages which do not have previous strings (i.e. when the PO file was merged without <option>--previous</option> option to <command>msgmerge</command>).</para>
</listitem>
</varlistentry>

</variablelist>
</para>

</sect2>

<sect2 id="sv-equip-header-tp-kde">
<title><command>equip-header-tp-kde</command></title>

<para><command>equip-header-tp-kde</command> applies <link linkend="hk-proj-kde-header-equip-header">the <literal>kde%header/equip-header</literal> hook</link> to headers of PO files within the KDE Translation Project.</para>

<caution><para>This sieve is deprecated. Use <link linkend="sv-apply-header-filter"><command>apply-header-filter</command></link> instead, with parameter <literal>filter:kde%header/equip-header</literal>.</para></caution>

</sect2>

<sect2 id="sv-fancy-quote">
<title><command>fancy-quote</command></title>

<para>Ordinary ASCII quotes are easy to type on most keyboard layouts, and these quotes are frequently encountered in non-typeset English texts, rather than proper English quotes. These proper quotes are sometimes called "fancy" quotes. When translating from English, translators can thus be easily moved to use ASCII quotes themselves, instead of the fancy quotes appropriate for their language. To somewhat correct this, <command>fancy-quote</command> can be used to replace ASCII quotes in the translation with selected pairs of fancy quotes.</para>

<para>ASCII quotes that are part of text markup (e.g. attribute values in XML-like tags) must not be replaced, and this sieve will use heuristics to determine such places. In fact, it will replace quotes rather conservatively. Nevertheless, unless some sort of automatic validation is available, converted text should be manually inspected for correctness.</para>

<para>Parameters:
<variablelist>

<varlistentry>
<term><option>single:<replaceable>quotes</replaceable></option></term>
<listitem>
<para>Opening and closing quote to replace ASCII single quotes (i.e. <replaceable>quotes</replaceable> is a two-character string). If not given, single quotes are not replaced (but see the <option>longsingle</option> parameter).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>single:<replaceable>quotes</replaceable></option></term>
<listitem>
<para>Opening and closing quote to replace ASCII double quotes. If not given, double quotes are not replaced (but see the <option>longdouble</option> parameter).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>longsingle:<replaceable>open</replaceable>,<replaceable>close</replaceable></option></term>
<listitem>
<para>Alternative to <option>single</option>, if opening and closing quotes are not single characters. The value are the opening quote string and the closing quote string, separated by comma.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>longdouble:<replaceable>open</replaceable>,<replaceable>close</replaceable></option></term>
<listitem>
<para>Alternative to <option>double</option>, if opening and closing quotes are not single characters.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

</sect2>

<sect2 id="sv-find-messages">
<title><command>find-messages</command></title>

<para></para>

</sect2>

<sect2 id="sv-generate-xml">
<title><command>generate-xml</command></title>

<para></para>

</sect2>

<sect2 id="sv-merge-corr-tree">
<title><command>merge-corr-tree</command></title>

<para></para>

</sect2>

<sect2 id="sv-normalize-header">
<title><command>normalize-header</command></title>

<para></para>

</sect2>

<sect2 id="sv-normctxt-delim">
<title><command>normctxt-delim</command></title>

<para></para>

</sect2>

<sect2 id="sv-normctxt-sep">
<title><command>normctxt-sep</command></title>

<para></para>

</sect2>

<sect2 id="sv-remove-fuzzy-comments">
<title><command>remove-fuzzy-comments</command></title>

<para></para>

</sect2>

<sect2 id="sv-remove-obsolete">
<title><command>remove-obsolete</command></title>

<para></para>

</sect2>

<sect2 id="sv-remove-previous">
<title><command>remove-previous</command></title>

<para></para>

</sect2>

<sect2 id="sv-resolve-aggregates">
<title><command>resolve-aggregates</command></title>

<para></para>

</sect2>

<sect2 id="sv-resolve-alternatives">
<title><command>resolve-alternatives</command></title>

<para></para>

</sect2>

<sect2 id="sv-resolve-entities">
<title><command>resolve-entities</command></title>

<para></para>

</sect2>

<sect2 id="sv-set-header">
<title><command>set-header</command></title>

<para></para>

</sect2>

<sect2 id="sv-stats">
<title><command>stats</command></title>

<para></para>

</sect2>

<sect2 id="sv-tag-untranslated">
<title><command>tag-untranslated</command></title>

<para></para>

</sect2>

<sect2 id="sv-unfuzzy-context-only">
<title><command>unfuzzy-context-only</command></title>

<para></para>

</sect2>

<sect2 id="sv-unfuzzy-ctxmark-only">
<title><command>unfuzzy-ctxmark-only</command></title>

<para></para>

</sect2>

<sect2 id="sv-unfuzzy-inplace-only">
<title><command>unfuzzy-inplace-only</command></title>

<para></para>

</sect2>

<sect2 id="sv-update-header">
<title><command>update-header</command></title>

<para></para>

</sect2>

<sect2 id="sv-fr:setUbsp">
<title><command>fr:setUbsp</command></title>

<para></para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-svexternal">
<title>Using External Sieves</title>

<para></para>

</sect1>

</chapter>
