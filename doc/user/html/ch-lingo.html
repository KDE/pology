<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy for Linux (vers 25 March 2009), see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Chapter&nbsp;8.&nbsp;Language Validation and Derivation</title>
<link rel="stylesheet" href="data/style.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="index.html" title="Pology User Manual">
<link rel="up" href="index.html" title="Pology User Manual">
<link rel="prev" href="ch-misctools.html" title="Chapter&nbsp;7.&nbsp;Miscellaneous Tools">
<link rel="next" href="ch-common.html" title="Chapter&nbsp;9.&nbsp;Common Functionality">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr>
<th colspan="3" align="center">Chapter&nbsp;8.&nbsp;Language Validation and Derivation</th>
</tr>
<tr>
<td width="20%" align="left"><a accesskey="p" href="ch-misctools.html">Prev</a>&nbsp;</td>
<th width="60%" align="center">&nbsp;</th>
<td width="20%" align="right">&nbsp;<a accesskey="n" href="ch-common.html">Next</a></td>
</tr>
</table>
<hr></div>
<div class="chapter">
<div class="titlepage">
<div>
<div>
<h2 class="title"><a name="ch-lingo" id="ch-lingo"></a>Chapter&nbsp;8.&nbsp;Language Validation and Derivation</h2>
</div>
</div>
</div>
<p>Pology was designed with strong language-specific support in mind, and this chapter describes the currently available features in the direction of validation and derivation of translation as whole and various bits in it.</p>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-lglangenv" id="sec-lglangenv"></a>8.1.&nbsp;The Notion of Language in Pology</h2>
</div>
</div>
</div>
<p>A versatile translation-supporting tool has to have some language-specific functionality. But, it is difficult to agree on what is a language and what is a dialect, what is standard and what is jargon, what is derived from what, how any of these are named, and there are many witty remarks about existing classifications. Therefore, Pology takes a rather simple and non-formal approach to the definition of "language", but such that should provide good technical leverage for constructing language-specific functionality.</p>
<p>There are two levels of language-specificity in Pology.</p>
<p>The first level is simply the "language". In linguistic sense this can be a language proper (whatever that means), a dialect, a variant written in different script, etc. Each language in this sense is assigned a code in Pology, when first elements of support for that language are introduced. By convention this code should be an <a class="ulink" href="http://en.wikipedia.org/wiki/ISO_639" target="_top">ISO 639</a> code (either two- or three-digit) if applicable, but in principle can be anything. Another convenient source of language codes is the GNU C library. For example, Portugese language spoken in Portugal would have the code <code class="literal">pt</code> (ISO 639) while Portugese spoken in Brazil would be <code class="literal">pt_BR</code> (GNU C library).</p>
<p>The second level of language-specificity is the "environment". In linguistic terms this could be whatever distinct but minor variations in vocabulary, style, tone, or ortography, which are specific to certain groups of people within a single language community. Within Pology, this level is used to support variations between specific translation environments, such as long-standing translation projects and their teams. Although translating into the same language, translation teams will almost inevitably have some differences in terminology, style guidelines, etc. Environments also have codes assigned.</p>
<p>In every application in Pology, the language and its environments have a hierarchical relation. In general, language-specific elements defined outside of a specific environment ("environment-agnostic" elements) are a sort of a relaxed least common denominator, and specific environments add their own elements to that. Relaxed means that environment-agnostic elements can sometimes include that which holds for most but not all environments, while each environment can override what it needs to. This prevents the environment-agnostic language support from getting too limited just to cater for perculiarities in certain environments.</p>
<p>When processing PO files, it is necessary to somehow convey to Pology tools to which language and environment the PO files belong. The most effective way of doing this is by adding the necessary information to PO headers. All Pology tools that deal with language-specific elements will check the header of the PO file they process for the language and environment. Some Pology tools will also consult the user configuration (typically with lower priority than PO headers) or provide appropriate command line options (typically giving them higher priority). See <a class="xref" href="ch-common.html#sec-cmheader" title="9.9.&nbsp;Influential Header Fields">Section&nbsp;9.9, “Influential Header Fields”</a> and <a class="xref" href="ch-common.html#sec-cmconfig" title="9.2.&nbsp;User Configuration">Section&nbsp;9.2, “User Configuration”</a> for details.</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="id388796" id="id388796"></a>8.1.1.&nbsp;Supported Languages and Environments</h3>
</div>
</div>
</div>
<p>The following languages and environments within those languages currently have some level of support in Pology (assigned code in parenthesis, "t.t." stands for translation team):</p>
<div class="informaltable">
<table border="1">
<colgroup>
<col width="30%">
<col width="70%"></colgroup>
<thead>
<tr>
<th>Language</th>
<th>Environments</th>
</tr>
</thead>
<tbody>
<tr>
<td>Catalan (<code class="literal">ca</code>)</td>
<td class="auto-generated">&nbsp;</td>
</tr>
<tr>
<td>French (<code class="literal">fr</code>)</td>
<td class="auto-generated">&nbsp;</td>
</tr>
<tr>
<td>Galician (<code class="literal">gl</code>)</td>
<td class="auto-generated">&nbsp;</td>
</tr>
<tr>
<td>Japanese (<code class="literal">ja</code>)</td>
<td class="auto-generated">&nbsp;</td>
</tr>
<tr>
<td>Low Saxon (<code class="literal">nds</code>)</td>
<td class="auto-generated">&nbsp;</td>
</tr>
<tr>
<td>Norwegian Nynorsk (<code class="literal">nn</code>)</td>
<td class="auto-generated">&nbsp;</td>
</tr>
<tr>
<td>Serbian (<code class="literal">sr</code>)</td>
<td>
<table width="100%" border="0">
<colgroup>
<col></colgroup>
<tbody>
<tr>
<td>KDE t.t. (<code class="literal">kde</code>)</td>
</tr>
<tr>
<td>The Battle for Wesnoth t.t. (<code class="literal">wesnoth</code>)</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td>Spanish (<code class="literal">es</code>)</td>
<td class="auto-generated">&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-lgspell" id="sec-lgspell"></a>8.2.&nbsp;Spell Checking</h2>
</div>
</div>
</div>
<p>Pology can employ various well-known spell-checkers to check the translation in PO files. Currently there is standalone support for <a class="ulink" href="http://aspell.net/" target="_top">Aspell</a>, and unified support for many spell-checkers (including Aspell) through <a class="ulink" href="http://www.abisource.com/projects/enchant/" target="_top">Enchant, the spell-checking wrapper library</a> (more precisely, through <a class="ulink" href="http://pyenchant.sourceforge.net" target="_top">Python bindings</a> for Enchant).</p>
<p>Spell-checking of one PO file or a collection of PO files can be performed directly by <a class="link" href="ch-sieve.html" title="Chapter&nbsp;3.&nbsp;Sieving">sieving</a> them through one of <a class="link" href="ch-sieve.html#sv-check-spell" title="3.5.8.&nbsp;check-spell"><span class="command"><strong>check-spell</strong></span></a> (Aspell) or <a class="link" href="ch-sieve.html#sv-check-spell-ec" title="3.5.9.&nbsp;check-spell-ec"><span class="command"><strong>check-spell-ec</strong></span></a> sieves. The sieve will report each unknown word, possibly with a list of suggestions, and the location of the message (file and line/entry numbers). It can also be requested to show the full message, with unknown words in the translation highlighted.</p>
<p>Also provided are several <a class="link" href="ch-common.html#hk-spell">spell-checking hooks</a>, which can be used as building blocks in custom translation validation chains. For example, a spell-checking hook can be used to define the spell-checking rule within Pology's <a class="link" href="ch-lingo.html#sec-lgrules" title="8.5.&nbsp;Validation Rules">validation rules</a> collection for a given language.</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgspdicts" id="sec-lgspdicts"></a>8.2.1.&nbsp;Internal Spelling Dictionaries</h3>
</div>
</div>
</div>
<p>Pology collects internal language-specific word lists as supplements to system spelling dictionaries. One use of internal dictionaries is to record those words which are omitted in the system spelling dictionaries, but are actually proper words in the given language. Such words should be added into internal dictionaries only as an immediate fix for false spelling warnings, with an eye towards integrating them into the upstream spelling dictionaries of respective spell-checkers.</p>
<p>More importantly, internal dictionaries serve to collect words specific to a given environment, i.e. the words which are deemed too specific to be part of the upstream, general spelling dictionaries for the language. For example, this can be technical jargon, with newly coined terms which are yet to be more widely accepted. Another example could be translation of fiction, in books or computer games, where it is common-place to make up words for fictional objects, animals, places, etc. which are not even intended to be more widely used.</p>
<p>In Pology source tree, internal spelling dictionaries by language are located in <code class="filename">lang/<em class="replaceable"><code>lang</code></em>/spell/</code> directories. This directory can contain arbitrary number of dictionary files, which are all automatically picked up by Pology when spelling-checking for that language is done. Dictionary files directly in this directory are environment-agnostic, and should contain only the words which are standard (or standard derivations) in the language, but happen to be missing from the system spelling dictionary. Subdirectories represent specific environments, they are named with the environment code, and can also contain any number of dictionaries. An example of internal dictionary tree with environments:</p>
<pre class="programlisting">
lang/
    sr/
        spell/
            colors.aspell
            fruit.aspell
            ...
            science.aspell
            kde/
                general.aspell
            wesnoth/
                general.aspell
                propernames.aspell
</pre>
<p>Dictionary files are in the Aspell word list format (regardless of the spell-checker actually used), and must have <code class="filename">.aspell</code> extension. This is a simple plain text format, listing one word per line. Only the first line is special, the header, which states the language code, number of words in the list, and the encoding. For example:</p>
<pre class="programlisting">
personal_ws-1.1 fr 1234 UTF-8
apricot
banana
cherry
...
</pre>
<p>Actually the only significant element of the header is the encoding. Language code and number of words can be arbitrary, as Pology will not use them.</p>
<p>Pology provides the <span class="command"><strong>organizeDict.py</strong></span> script which sorts word list files alphabetically (and corrects the word count in the header, even if not important), so that you do not have to manually insert new words in proper order. The script is simply run with arbitrary number of word list files as arguments, and modifies them in place. In case of duplicate words, it will report duplicates and eliminate them. In case of words with invalid characters (e.g. space), the script will output a warning, but it will not remove them; automatic removal of invalid words can be requested with <code class="option">-r</code>/<code class="option">--remove-invalid</code> option.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgspskip" id="sec-lgspskip"></a>8.2.2.&nbsp;Skipping Messages and Words</h3>
</div>
</div>
</div>
<p>Sometimes a message or a few words in it should not be spell-checked. This can be, for example, when the message is dense computer input (like a command line synopsis), or when a word is part of a literal phrase (such as an email address). It may be possible to filter the text to remove some of the non-checkable words prior to spell-checking (especially when spell-checking is done as a <a class="link" href="ch-lingo.html#sec-lgrules" title="8.5.&nbsp;Validation Rules">validation rule</a>), but not all such words can be automatically detect. For example, especially problematic are onomatopoeic constructs ("Aaargh! Who released the beast?!").</p>
<p>For this reason it is possible to manually skip spell-checking on a message, or on certain words within a message, by adding a <a class="link" href="ch-common.html#sec-cmskipcheck" title="9.11.&nbsp;Skipping and Selecting Checks">special translator comment</a>. The whole message is skipped by adding the <code class="literal">no-check-spell</code> translator flag to it:</p>
<pre class="programlisting">
# |, no-check-spell
</pre>
<p>Words within the message are skipped by listing them in <code class="literal">well-spelled:</code> translator comment, comma- or space-separated:</p>
<pre class="programlisting">
# well-spelled: Aaarg, gaaah, khh
</pre>
<p>Which of these two levels of skipping to use depends on the nature of the text. For example, if most of the text is composed of proper words, and there are only a few which should not be checked, it is probably better to list those words explicitly instead of skipping the whole message.</p>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-lggrammar" id="sec-lggrammar"></a>8.3.&nbsp;Grammar Checking</h2>
</div>
</div>
</div>
<p>With Pology you can use <a class="ulink" href="http://www.languagetool.org/" target="_top">LanguageTool</a>, a free grammar and style checker, to check translation in PO files. At the moment LanguageTool is applicable only through <a class="link" href="ch-sieve.html#sv-check-grammar" title="3.5.5.&nbsp;check-grammar">the <span class="command"><strong>check-grammar</strong></span> sieve</a>, so look up the details in its documentation.</p>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-lguirefs" id="sec-lguirefs"></a>8.4.&nbsp;Automatic Insertion of UI Labels</h2>
</div>
</div>
</div>
<p>In program documentation, but also in help texts in running programs, frequently labels from user interface are mentioned. Here are two such messages, one a UI tooltip, the other a Docbook paragraph:</p>
<pre class="programlisting">
#: comic.cpp:466
msgid "Press the \"Get New Comics...\" button to install comics."
msgstr ""

#: index.docbook:157
msgid ""
"&lt;guimenuitem&gt;Selected files only&lt;/guimenuitem&gt; extracts only "
"the files which have been selected."
msgstr ""
</pre>
<p>In the usual translation process, an embedded UI label is manually translated just like the surrounding text. You could directly translate the label, hoping that the original UI message was translated in the same way, but this will frequently not be the case (especially for longer labels). To be thorough, you could look up the UI message in its PO file, or run the program, to see how it was actually translated. There are two problems with being thorough in this way: it takes time to look up original UI messages, and worse, translation of a UI message might change in the future (e.g. after a review) and leave the referencing message out of date.</p>
<p>An obvious solution to these problems, in principle, would be to leave embedded UI labels untranslated but properly marked (such as with <code class="literal">&lt;gui*&gt;</code> tags in Docbook), and have an automatic system fetch their translations from original UI messages and insert them into referencing messages. However, there could be many implementational variations of this approach (like at which stage of the translation chain the automatic insertion happens), with some significant details to get right.</p>
<p>At present, Pology approaches automatic insertion of UI labels in a generalized way, which does not mandate any particular organization of PO files or translation workflow. It defines a syntax for wrapping and disambiguating UI references, for linking referencing and originating PO files, and provides a series of <a class="link" href="ch-common.html#hk-uiref-resolve-ui">hooks to resolve and validate UI references</a>. A UI reference resolving hook will simply replace a properly equipped non-translated UI label with its translation. This implies that PO files which are delivered must not be the same PO files which are directly translated, because resolving UI references in directly translated PO files would preclude their automatic update in the future<sup>[<a name="id443596" href="#ftn.id443596" class="footnote" id="id443596">21</a>]</sup>. It is upon the translator or the translation team to establish the separation between delivered and translated PO files. One way is by translating in summit (see <a class="xref" href="ch-summit.html" title="Chapter&nbsp;5.&nbsp;Summitting Translation Branches">Chapter&nbsp;5, <i>Summitting Translation Branches</i></a>), which by definition provides the desired separation, and setting UI reference resolving hooks as filters on scatter.</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lguiformat" id="sec-lguiformat"></a>8.4.1.&nbsp;Wrapping UI References</h3>
</div>
</div>
</div>
<p>If UI references are inserted into the text informally (even if relying on certain ortographic or typographic conventions), then they must be manually wrapped in the translation using an explicit UI reference directive. For example:</p>
<pre class="programlisting">
#: comic.cpp:466
msgid "Press the \"Get New Comics...\" button to install comics."
msgstr "Pritisnite dugme „~%/Get New Comics/“ da instalirate stripove."
</pre>
<p>Explicit UI reference directives are of the format <em class="replaceable"><code>head</code></em>/<em class="replaceable"><code>reference-text</code></em>/. The directive head is <code class="literal">~%</code> in this example, which is the default, but another head may be specified as parameter to UI resolving hooks. Delimiting slashes in the UI reference directive can be replaced with any other character consistenly (e.g. if the UI text itself contains a slash). Note that the directive head must be fixed for a collection of PO files (though more than one head can be defined), while delimiting character can be freely chosen from one to another directive.</p>
<p>The other the type are implicit UI references, which do not require special directive, made possible when UI text is indicated in the text through formal markup. This is the case, for example, in PO files coming from Docbook documenation:</p>
<pre class="programlisting">
#: index.docbook:157
msgid ""
"&lt;guimenuitem&gt;Selected files only&lt;/guimenuitem&gt; extracts only "
"the files which have been selected."
msgstr ""
"&lt;guimenuitem&gt;Selected files only&lt;/guimenuitem&gt; raspakuje samo "
"datoteke koje su izabrane."
</pre>
<p>Here the translation contains nothing special, save for the fact that the UI reference is not translated. UI resolving hooks can be given a list of tags to be considered as UI references, and for some common formats (such as Docbook) there are predefined specialized hooks which already list all UI tags.</p>
<p>If the message of the UI text is unique by its <code class="varname">msgid</code> string in the originating PO file, then it can be wrapped simply as in previous examples. This means that even if it has the <code class="varname">msgctxt</code> string, the reference will still be resolved. But, if there are several UI messages with same <code class="varname">msgid</code> (implying different <code class="varname">msgctxt</code>), then the <code class="varname">msgctxt</code> string has to be manually added to the reference. This is done by puting the context into the prefix of the reference, separated by the pipe <code class="literal">|</code> character. For example, if the PO file has these two messages:</p>
<pre class="programlisting">
msgctxt "@title:menu"
msgid "Columns"
msgid "Kolone"

msgctxt "@action:inmenu View Mode"
msgid "Columns"
msgstr "kolone"
</pre>
<p>then the correct one can be selected in an implicit UI reference like this:</p>
<pre class="programlisting">
msgid ""...&lt;guibutton&gt;Columns&lt;/guibutton&gt;..."
msgstr "...&lt;guibutton&gt;@title:menu|Columns&lt;/guibutton&gt;..."
</pre>
<p>In the very unlikely case of <code class="literal">|</code> character being part of the context string itself, the <code class="literal">¦</code> character ("broken bar") can be used as the context separator instead.</p>
<p>If the UI reference equipped with context does not resolve to a message through direct match on context, the given context string will next be tried as regular expression match on <code class="varname">msgctxt</code> strings of the messages with matching <code class="varname">msgid</code> (matching will be case-insensitive). If this results in exactly one matched message, the reference is resolved. This matching sequence allows simplification and robustness in case of longer contexts, which would look ungainly in the UI reference and may slightly change over time.</p>
<p>If two UI messages have equal <code class="varname">msgid</code> but are not part of the same PO file, that is not a conflict because one of those PO files has the priority (see <a class="xref" href="ch-lingo.html#sec-lguilink" title="8.4.3.&nbsp;Linking to Originating PO Files">Section&nbsp;8.4.3, “Linking to Originating PO Files”</a>).</p>
<p>If of UI two messages with equal <code class="varname">msgid</code> one has <code class="varname">msgctxt</code> and the other does not, the message without context can be selected by adding the context separator in front of the text with nothing before it (i.e. as if the context is "empty").</p>
<p>Sometimes, though rarely, it happens that the referenced UI text is not statically complete, that is, that it contains a format directive which is resolved at runtime. In such cases, the reference must be transformed to exactly an existing <code class="varname">msgid</code>, and the arguments are substituted with special syntax. If the UI message is:</p>
<pre class="programlisting">
msgid "Configure %1..."
msgstr "Podesi %1..."
</pre>
<p>then it can be used in an implicit UI reference like this:</p>
<pre class="programlisting">
msgid "...&lt;guimenuitem&gt;Configure Foobar...&lt;/guimenuitem&gt;..."
msgstr "...&lt;guimenuitem&gt;Configure %1...^%1:Foobar&lt;/guimenuitem&gt;..."
</pre>
<p>Substitution arguments follow after the text, separated with the <code class="literal">^</code> character. Each argument specifies the format directive it replaces and the argument text, separated by <code class="literal">:</code>. In the unlikely case that <code class="literal">^</code> is part of the <code class="varname">msgid</code> itself, the <code class="literal">ª</code> ("feminine ordinal indicator") can be used instead as the argument separator.</p>
<p>If there are several format directives in the UI reference, they are by default considered "named". This means that all same format directives will be replaced by the same argument. This is the right thing to do for some formats, e.g. <code class="literal">python-format</code> or <code class="literal">kde-format</code> messages, but not for all formats. In <code class="literal">c-format</code>, if there are two <code class="literal">%s</code> in the text, to replace just one of them with the current argument, the format directive attached to the argument must be preceded with <code class="literal">!</code>:</p>
<pre class="programlisting">
#, c-format
msgid "...&lt;guilabel&gt;This Foo or that Bar&lt;/guilabel&gt;..."
msgstr "...&lt;guilabel&gt;This %s or that %s.^!%s:foo^!%s:bar&lt;/guilabel&gt;..."
</pre>
<p>In general, but especially with implicit references, the text wrapped as reference may actually contain several references in form of UI path (<code class="literal">"...go to Foo-&gt;Bar-&gt;Baz, and click on..."</code>). To handle such cases, if it is not possible or it is not convenient to wrap each element of the UI path separately, UI reference resolving hooks can be given one or more UI path separators (e.g. <code class="literal">-&gt;</code>) to split and resolve the element references on their own.</p>
<p>Sometimes the UI reference in the original text is not valid, i.e. such message no longer exists in the program. This can happen due to slight interpunction mismatch, small style changes, etc., such that you can easily locate the correct UI message and use its <code class="varname">msgid</code> as the reference. However, if the UI reference is not valid due to documentation being outdated, there is no correct UI message to use in translation. This should most certainly be reported to the authors, but up until they fix it, it presents a problem for immediate resolution of UI references. For this reason, a UI reference can be temporarily translated in place, by preceding it with twin context separators:</p>
<pre class="programlisting">
msgid "...<span class="guilabel">An Outdated Label</span>..."
msgstr "...<span class="guilabel">||Zastarela etiketa</span>..."
</pre>
<p>This will resolve into the verbatim text of the reference (i.e. context separators will simply be removed), without the hook complaining about an unresolvable reference.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lguinorm" id="sec-lguinorm"></a>8.4.2.&nbsp;Normalization of UI Text</h3>
</div>
</div>
</div>
<p>The text of the UI message may contain some characters and substrings which should not be carried over into the text which references the message, or should be modified. To cater for this, UI PO files are normalized after being opened and before UI references are looked up in them. In fact, UI references are written precisely in this normalized form, rather than using the true original <code class="varname">msgid</code> from the UI PO file. This is both for convenience and for necessity.</p>
<p>One typical thing to handle in normalization is the accelerator marker. UI reference resolving hooks eliminate accelerator markers automatically, by for that they need to known what the accelerator marker character is. To find this out, hooks will read <a class="link" href="ch-common.html#hdr-x-accelerator-marker">the <code class="literal">X-Accelerator-Marker</code> header field</a>.</p>
<p>Another problem is when UI messages contain subsections which would invalidate the target format which is being translated in the referencing PO file, e.g. malformed XML in Docbook catalogs. For example, literal <code class="literal">&amp;</code> must be represented as <code class="literal">&amp;amp;</code> in Docbook markup, thus this UI message:</p>
<pre class="programlisting">
msgid "Scaled &amp; Cropped"
msgstr ""
</pre>
<p>would be referenced as:</p>
<pre class="programlisting">
msgid "...&lt;guimenuitem&gt;Scaled &amp;amp; Cropped&lt;/guimenuitem&gt;..."
msgstr "...&lt;guimenuitem&gt;Scaled &amp;amp; Cropped&lt;/guimenuitem&gt;..."
</pre>
<p>Resolving hooks have parameters for specifying the type of escaping needed by the target format.</p>
<p>Normalization may flatten several different messages from the UI PO file into one. Example of this is when <code class="varname">msgid</code> fields are equal but for the accelerator marker. If this happens and normalized translations are not equal for all flattened messages, a special "tail" is added to their contexts, consisting of a tilde and several alphanumeric characters. The first run of the resolving (or validation) hook will report ambiguities of this kind, as well as assigned contexts, so that proper context can be copied and pasted over into the UI reference. The alphanumeric context tail is computed from the non-normalized <code class="varname">msgid</code> alone, so it will not change if, for example, messages in the UI PO file get reordered.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lguilink" id="sec-lguilink"></a>8.4.3.&nbsp;Linking to Originating PO Files</h3>
</div>
</div>
</div>
<p>In general, the UI message may not be present in the same PO file in which it is referenced in another messages. This is always the case for documentation PO files. Therefore UI reference resolving hooks need to know two things: the list of all UI PO files (those from which UI references may be drawn), and, for each PO file which contains UI references, the list of PO files from which it may draw UI references.</p>
<p>The list of UI PO files can be given to resolving hooks explicitly, as list of PO file paths (or directory paths to search for PO files). This can, however, be inconvenient, as it implies either that the resolution script must be invoked in a specific directory (if paths are relative), or that UI PO files must reside in a fixed directory on the system where the resolution script is run (if paths are absolute). Therefore there is another way of specifying paths to UI PO files, through an environment variable which contains a colon-separated list of directory paths. Both the explict list of paths and the environment variable which contains the paths can be given as parameters to hooks.</p>
<p>By default, for a given PO file, UI references are looked for only in the PO file of the same name, assuming that it is found among UI PO files. This may be sufficient, for example, for UI references in tooltips, but it is frequently not sufficient for documentation PO files, which may have a different names from corresponding UI PO file names. Therefore a PO file can be manually linked to UI PO files from which it draws UI references, through a special header field <code class="literal">X-Associated-UI-Catalogs</code>. This field specifies only the PO domain names, as space- or comma-separated list:</p>
<pre class="programlisting">
msgid ""
msgstr ""
"Project-Id-Version: foobar\n"
"..."
"X-Associated-UI-Catalogs: foobar libfoobar libqwyx\n"
</pre>
<p>The order of domain names in the list is important: if the referenced UI message exists in more than one linked PO file, the translation is taken from the one which appears earlier in the list. Knowing PO domain names, resolving hooks can look up the exact file paths in the supplied list of paths.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lguinotes" id="sec-lguinotes"></a>8.4.4.&nbsp;Notes on UI Reference Resolution</h3>
</div>
</div>
</div>
<p>When a UI reference cannot be resolved, for whatever reason -- it does not exist, there is a context conflict, the message is not translated, etc. -- resolving hooks will output warnings and fallback to original text.</p>
<p>For each resolving hook there exists the counterpart validation hook. Validation hooks may be used in a "dry run" before starting to build PO files for delivery, or they may be built into a general translation validation framework (such as Pology's <a class="link" href="ch-lingo.html#sec-lgrules" title="8.5.&nbsp;Validation Rules">validation rules</a>).</p>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-lgrules" id="sec-lgrules"></a>8.5.&nbsp;Validation Rules</h2>
</div>
</div>
</div>
<p>There are great many possible mistakes to be made when translating. Some of these mistakes can only be observed and corrected by a human reviewer<sup>[<a name="id500443" href="#ftn.id500443" class="footnote" id="id500443">22</a>]</sup>, and review is indeed an important part of the translation workflow. However, many mistakes, especially those more technical in nature, can be fully or partially detected by automatic means.</p>
<p>A number of tools are available to perform various checks on translation in PO files. The basic one is Gettext's <span class="command"><strong>msgfmt</strong></span> command, which, when run with <code class="option">-c</code>/<code class="option">--check</code> option, will detect many "hard" technical problems. These are the kind of problems which may cause the program that uses translation to crash, or that may cause loss of information to the program user. Another is <a class="ulink" href="http://translate.sourceforge.net/wiki/toolkit/pofilter" target="_top">Translate Toolkit's <span class="command"><strong>pofilter</strong></span> command</a>, which applies heuristic checks to detect common (and not so common) stylistic and semantic slips in translation. Dedicated PO editors may also provide some checks of their own, or make use of external batch tools.</p>
<p>One commonality of existing validation tools is that they aim for generality, that is, try to apply a fixed battery of checks to all <a class="link" href="ch-lingo.html#sec-lglangenv" title="8.1.&nbsp;The Notion of Language in Pology">languages and environments</a> (although some differentiation by translation projects may be present, such as in <span class="command"><strong>pofilter</strong></span>). Another commonality, unavoidable in heuristic approaches, is wrong detection of valid translation as invalid, the so called "false positives". These two elements produce combined negative effect: since the number and specificity of checks is not that great compared to what a dedicated translator could come up with for given language and environment, and since many reported errors are false positives without possibility for cancelation, the motivation to apply automatic checks sharply decreases; the more so the greater the amount of translation.</p>
<p>Pology therefore provides a system for users to assemble collections of <span class="emphasis"><em>validation rules</em></span> adapted to their language and environment, with multi-level facilities for applying or skipping rules in certain contexts, pre-filtering of text before applying rules, and post-filtering and opening problematic messages in PO editors. Rules can be written and tuned in the course of translation, and false positives can be systematically canceled, such that over time the collection of rules becomes both highly specific and highly accurate. Since Pology supports language and environment variations from the ground up, such rule collections can be committed to Pology source distribution, so that anyone may use them when applicable.</p>
<p>Validation rules are primarily based on pattern matching with <a class="link" href="ch-common.html#sec-cmregex" title="9.3.&nbsp;Regular Expressions">regular expressions</a>, but they can in principle contain any Python code through Pology's <a class="link" href="ch-common.html#sec-cmhooks" title="9.10.&nbsp;Processing Hooks">hook system</a>. For example, since there are spell-checking hooks provided, spell-checking can be easily made into one validation rule. One could even aim to integrate every available check into the validation rule system, such that it becomes the single and uniform source of all automatic checks in the translation workflow.</p>
<p>The primary tool in Pology for applying validation rules is <a class="link" href="ch-sieve.html#sv-check-rules" title="3.5.7.&nbsp;check-rules">the <span class="command"><strong>check-rules</strong></span> sieve</a>. This section describes how to write rules, how to organize rule collections, and, importantly, how to handle false positives.</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrltour" id="sec-lgrltour"></a>8.5.1.&nbsp;Guided Tour of the Rule System</h3>
</div>
</div>
</div>
<p>There are many nuances to the validation rule system in Pology, so it is best to start off with an example-based exposition of the main elements. Subsequent sections will then look into each element in detail.</p>
<p>Rules are defined in rule files, with flat structure and minimalistic syntax, since the idea is to write the rules during the translation (or the translation review). Here is one rule file with two rules:</p>
<pre class="programlisting">
# Personal rules of Horatio the Indefatigable.

[don't|can't|isn't|aren't|won't|shouldn't|wouldn't]i
id="gram-contr"
hint="Do not use contractions."

{elevator}i
id="term-elevator"
hint="Translate 'elevator' as 'lift'."
valid msgstr="lift"
</pre>
<p>A rule file should begin with a comment telling something about the rules defined in the file. Then the rules follow, normally separated by one or more blank lines. Each rule starts with a <span class="emphasis"><em>trigger pattern</em></span>, of which there are several types. The trigger pattern can sometimes be everything there is to the rule, but it is usually followed by a number of <span class="emphasis"><em>subdirectives</em></span>.</p>
<p>The first rule above starts with a regular expression pattern on the translation, which is denoted by the <code class="literal">[...]</code> syntax. The regular expression matches English contractions, case-insensitively as indicated by trailing <code class="literal">i</code> flag. The trigger pattern is followed by the <code class="literal">id</code> subdirective, which specifies an identifier for the rule (here <code class="literal">gram-contr</code> is short for "grammar, contractions"). The identifier does not have to be present, and does not even have to be unique if present (uses of rule identifiers will be explained later). If the rule matches a message, the message is reported to the user as problematic, along with a note provided in the <code class="literal">hint</code> subdirective.</p>
<p>The second rule starts with a regular expression pattern on the original (rather than the translation), for which the <code class="literal">{...}</code> syntax is reserved. Then the <code class="literal">id</code> and <code class="literal">hint</code> subdirectives follow, as in the first rule. But unlike the first rule, up to this point the second rule would be somewhat strange: report a problem whenever the word "elevator" is found in the original text? That is where the final <code class="literal">valid</code> subdirective comes in, by specifying a condition on translation (<code class="literal">msgstr=</code>) which cancels the trigger pattern. So this rule efectively states "report every message which has the word 'elevator' in the original, but not the word 'lift' in the translation", making it a terminology assertion rule.</p>
<p>If the given example rule file is saved as <code class="filename">personal.rules</code>, it can be applied to a collection of PO files by the <span class="command"><strong>check-rules</strong></span> sieve in the following way:</p>
<pre class="programlisting">
$ posieve check-rules -s rfile:<em class="replaceable"><code>pathto</code></em>/personal.rules <em class="replaceable"><code>PATHS...</code></em>
</pre>
<p>The path to the rule file to apply is given by the <code class="option">rfile:</code> sieve parameter. All messages which are "failed" by rules will be output to the terminal, with spans of the text that triggered the rule highlighted and the note attached to the rule displayed after the message. Additionally, one of the parameters for automatically opening messages in the PO editor can be issued, to make correcting problems (or canceling false positives) that more comfortable.</p>
<p>The <code class="option">rfile:</code> sieve parameter can be repeated to add several rule files. If all rule files put into one directory (and its subdirectories), a single <code class="option">rdir:</code> parameter can be used to specify the path to that directory, and all files with <code class="filename">.rules</code> extension will be recursively collected from it and applied. Finally, if rule files are put into Pology's rule directory for the given language, at <code class="filename">lang/<em class="replaceable"><code>lang</code></em>/rules/</code>, then <span class="command"><strong>check-rules</strong></span> will automatically pick them up when neither <code class="option">rfile:</code> nor <code class="option">rdir:</code> parameters are issued. This is a simple way to test the rules if the intention is to include them into Pology distribution.</p>
<p>Instead of applying all defined rules, parameters <code class="option">rule:</code>, <code class="option">rulerx:</code>, <code class="option">norule:</code>, <code class="option">norulerx:</code> of <span class="command"><strong>check-rules</strong></span> can be used to select specific rules to apply or to not apply, by their identifiers. To apply only the no-contractions rule:</p>
<pre class="programlisting">
$ posieve check-rules -s rfile:<em class="replaceable"><code>pathto</code></em>/personal.rules -s rule:gram-contr <em class="replaceable"><code>PATHS...</code></em>
</pre>
<p>and to apply all but terminology rules, assuming that their identifiers start with <code class="literal">term-</code>:</p>
<pre class="programlisting">
$ posieve check-rules -s rfile:<em class="replaceable"><code>pathto</code></em>/personal.rules -s norulerx:term-.* <em class="replaceable"><code>PATHS...</code></em>
</pre>
<p>When the rule trigger pattern is a regular expression, it can always be made more or less specific. The previous example of matching English contractions could be generalized like this:</p>
<pre class="programlisting">
[\w+'t\b]i
</pre>
<p>This regular expression will match one or more word-characters (<code class="literal">\w+</code>) followed by 't (<code class="literal">'t</code>) which is positioned at the word boundary (<code class="literal">\b</code>). More general patterns increase the likelyhood of false positives, but this is not really a problem, since tweaking the rules in the course of translation is expected. It is a bigger problem if the pattern is made too specific at first, such that it misses out some cases. It is therefore recommended to start with "greedy" patterns, and then constrain them as false positivies are observed.</p>
<p>However, tweaking trigger patterns can only go so far.<sup>[<a name="id500843" href="#ftn.id500843" class="footnote" id="id500843">23</a>]</sup> The workhorse of rule flexibility is instead the mentioned <code class="literal">valid</code> subdirective. Within a single <code class="literal">valid</code> directive there may be several tests, and many types of tests are provided. The trigger will be canceled if all the tests in the <code class="literal">valid</code> subdirective are satisfied (boolean AND linking). There may be several <code class="literal">valid</code> subdirectives, each with its own battery of tests, and then the trigger is canceled if any of the <code class="literal">valid</code> subdirectives are satisfied (boolean OR linking). For example, to disallow a certain word in translation unless used in few specific constructs, the following set of <code class="literal">valid</code> subdirectives can be used:</p>
<pre class="programlisting">
[foo]i
id="style-nofoo"
hint="The word 'foo' is allowed only in '*goo foo' and 'foo bar*' constructs."
valid after="goo "
valid before=" bar"
</pre>
<p>The first <code class="literal">valid</code> subdirective cancels the rule if the trigger pattern matched just after a "goo " segment, and the second if it matched just before a " bar" segment. Another example would be a terminology assertion rule where a certain translation is expected in general, but another translation as well is allowed in a specific PO file:</p>
<pre class="programlisting">
{foobar}i
id="term-foobar"
hint="Translate 'foobar' as 'froobaz' (somewhere 'groobaz' allowed too)."
valid msgstr="froobaz"
valid msgstr="groobaz" cat="gfoo"
</pre>
<p>Here the second <code class="literal">valid</code> subdirective uses the <code class="literal">cat=</code> test to specify the other possible translation in the specific PO file. Tests can be negated by prepending <code class="literal">!</code> to them, so to require the specific PO file to have <span class="emphasis"><em>only</em></span> the other translation:</p>
<pre class="programlisting">
valid msgstr="froobaz" !cat="gfoo"
valid msgstr="groobaz" cat="gfoo"
</pre>
<p>When a regular expression is not sufficient as the rule trigger, a validation hook can be used instead (one of V* hook types). See <a class="xref" href="ch-common.html#sec-cmhooks" title="9.10.&nbsp;Processing Hooks">Section&nbsp;9.10, “Processing Hooks”</a> for general discussion on hooks in Pology. For example, since there are spell-checking hooks already available, the complete rule for spell-checking could be:</p>
<pre class="programlisting">
*hook name="spell/check-spell-sp" on="msgstr"
id="spelling"
hint="Misspelled words detected."
</pre>
<p>The <code class="literal">name=</code> field specifies the hook, and the <code class="literal">on=</code> field what parts of the message it should operate on. The parts given by <code class="literal">on=</code> field must be appropriate for the hook type; since <code class="literal">spell/check-spell-sp</code> is a V3A hook, it can operate on any string in the message, including the translation as requested here. Validation hooks can provide some notes of their own (here list of replacement suggestions for a faulty word), which will be shown next to the note given by rule's <code class="literal">hint=</code> subdirective.</p>
<p>Examples so far all suffer from one basic problem: the trigger pattern will fail to match a word which has an accelerator marker inside it.<sup>[<a name="id420639" href="#ftn.id420639" class="footnote" id="id420639">24</a>]</sup> This is actually an instance of a broader problem, that some rules should operate on a somewhat modified, filtered text, instead on the original text. This is why the rule system in Pology also provides extensive filtering capabilities. If the accelerator marker is <code class="literal">_</code> (the underscore), here is how it could be removed before applying the rules:</p>
<pre class="programlisting">
# Personal rules of Horatio the Indefatigable.

addFilterRegex match="_" repl="" on="pmsgid,pmsgstr"

# Rules follow...
</pre>
<p>The <code class="literal">addFilterRegex</code> directive sets a regular expression filter that will be applied to messages before applying any of the rules that follow. <code class="literal">match=</code> field provides the pattern, <code class="literal">repl=</code> what to replace it with, and <code class="literal">on=</code> which parts of the message to filter.</p>
<p>The accelerator marker filter from the previous example is quite crude. It fixes the accelerator marker character, and it will simply remove all of them from the text. Filters too can be hooks instead of regular expressions, and in this case it is better to use the dedicated accelerator marker removal hook:</p>
<pre class="programlisting">
# Personal rules of Horatio the Indefatigable.

addFilterHook name="remove/remove-accel-msg" on="msg"

# Rules follow...
</pre>
<p><a class="link" href="ch-common.html#hk-remove-remove-accel">The <code class="literal">remove/remove-accel-msg</code> hook</a> is an F4A hook, and therefore the <code class="literal">on=</code> field specifies the whole message as the target of filtering. This hook will use information from PO file headers and respect command line overrides to determine the accelerator marker character, and then remove them only from valid accelerator positions.</p>
<p>Filters to not have to be given as global directives, influencing all the rules below them, but they can be defined for a single rule, using one of rule subdirectives. The other way around, global filters can also have a handle assigned (using the <code class="literal">handle=</code> field), and then this handle can be used to remove the filter on a specific rule.</p>
<p>The last important concept in the Pology's validation rule system are rule environments. The examples so far defined rules for a given language, which means that they in principle apply to any PO file of that language. This is generally insufficient (e.g. terminology differences between translation projects), so rules too can be made to support Pology's <a class="link" href="ch-lingo.html#sec-lglangenv" title="8.1.&nbsp;The Notion of Language in Pology">language and environment</a> hierarchy. Going back to the initial rule file example, let us assume that while "elevator" should always become "lift", but that English contractions are not accepted only in more formal translations. Then, the rule file could be modified to:</p>
<pre class="programlisting">
# Personal rules of Horatio the Indefatigable.

[don't|can't|isn't|aren't|won't|shouldn't|wouldn't]i
environment formal
...

{elevator}i
...
</pre>
<p>The first rule now has the <code class="literal">environment</code> subdirective, which sets this rule's environment to <code class="literal">formal</code>. If <span class="command"><strong>check-rules</strong></span> is now run as before, only the second rule will be applied, as it is environment-agnostic. To apply the first rule as well, the <code class="literal">formal</code> environment must be requested through the <code class="option">env:</code> sieve parameter:</p>
<pre class="programlisting">
$ posieve check-rules -s rfile:<em class="replaceable"><code>pathto</code></em>/personal.rules -s env:formal <em class="replaceable"><code>PATHS...</code></em>
</pre>
<p>Another way to request the environment is to specify it inside the PO file itself, through the <a class="link" href="ch-common.html#hdr-x-environment">the <code class="literal">X-Environment:</code> header field</a>. This is generally preferable, because it both reduces the amount of command line arguments (which may be accidentaly omitted sometimes), other parts of Pology too can make use of the environment information in the PO header, and, most importantly, it makes possible that not all PO files processed in a single run belong to the same environment.</p>
<p>If all the rules which belong to the formal environment are grouped at the end of the rule file, then the global <code class="literal">environment</code> directive can be used to set the environment for all of them, instead of the subdirective on each of them:</p>
<pre class="programlisting">
# Personal rules of Horatio the Indefatigable.

{elevator}i
...

environment formal

[don't|can't|isn't|aren't|won't|shouldn't|wouldn't]i
...
</pre>
<p>A more usual application of the global <code class="literal">environment</code> directive is to split environment-specific rules into a separate file, and then put the <code class="literal">environment</code> directive at the top. Most flexibly, <code class="literal">valid</code> subdirectives provide the <code class="literal">env=</code> test, so that the rule trigger can be canceled in a condition including the environment. In the running example, this could be used as:</p>
<pre class="programlisting">
# Personal rules of Horatio the Indefatigable.

[don't|can't|isn't|aren't|won't|shouldn't|wouldn't]i
...
valid !env="formal"

{elevator}i
...
</pre>
<p>It depends on the particular organization of rule files, and on types of rules, which method of environment-sensitivity should be used. Filters too are sensitive to environments, either conforming to global environment directives same as rules, or using their own <code class="literal">env=</code> fields.</p>
<p>When requesting environments in validation runs (through <code class="option">env:</code> sieve parameter or <code class="literal">X-Environment:</code> header field), more than one environment can be specified. Then the rules from all those environments, plus the environment-agnostic rules, will be applied. Here comes another function of rule identifiers (provided with the <code class="literal">id=</code> rule subdirective): if two rules in different environments have same identifier, then the rule from the more specific environment overrides the rule from the less specific environment. The more specific environment is normally taken to be the one encountered later in the requested environment list.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrlfiles" id="sec-lgrlfiles"></a>8.5.2.&nbsp;Layout of Rule Files</h3>
</div>
</div>
</div>
<p>Rule files are kept simple, to facilitate easy editing without verbose syntax getting in the way. A rule file has the following layout:</p>
<pre class="programlisting">
# Title of the rule collection.
# Author name.
# License.

# Directives affecting all the rules.
<em class="replaceable"><code>global-directive</code></em>
...
<em class="replaceable"><code>global-directive</code></em>

# Rule 1.
<em class="replaceable"><code>trigger-pattern</code></em>
<em class="replaceable"><code>subdirective-1</code></em>
...
<em class="replaceable"><code>subdirective-n</code></em>

# Rule 2.
<em class="replaceable"><code>trigger-pattern</code></em>
<em class="replaceable"><code>subdirective-1</code></em>
...
<em class="replaceable"><code>subdirective-n</code></em>

...

# Rule N.
<em class="replaceable"><code>trigger-pattern</code></em>
<em class="replaceable"><code>subdirective-1</code></em>
...
<em class="replaceable"><code>subdirective-n</code></em>
</pre>
<p>The rather formal top comment (licence, etc.) is required for the rule files inside Pology distribution. In most contexts rule files are expected to have the <code class="filename">.rules</code> extension, so it is best to always use it (mandatory for internal rules files). Rule files must be UTF-8 encoded.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrltrigpat" id="sec-lgrltrigpat"></a>8.5.3.&nbsp;Rule Triggers</h3>
</div>
</div>
</div>
<p>The rule trigger is most often a regular expression pattern, given within curly or square brackets, <code class="literal">{...}</code> or <code class="literal">[...]</code>, to match the original or the translation part of the message, respectively. The closing bracket may be followed by single-character matching modifiers, as follows:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="literal">i</code>: case-sensitive matching for <span class="emphasis"><em>all</em></span> patterns in the rule, including but not limited to the trigger pattern. Default matching is case-insensitive.</p>
</li>
</ul>
</div>
<p>Bracketed patterns are the shorthand notation, which are sufficient most of the time. There is also the more verbose notation <code class="literal">*<em class="replaceable"><code>message-part</code></em>/<em class="replaceable"><code>regex</code></em>/<em class="replaceable"><code>modifiers</code></em></code>, where instead of <code class="literal">/</code> any other non-letter character can be used consistently as separator. The verbose notation is needed when some part of the message other than the original or the translation should be matched, or when brackets would cause balancing issues (e.g. when a closing curly bracket without the opening bracket is a part of the match for the original text). For all messages, <code class="literal"><em class="replaceable"><code>message-part</code></em></code> can be one of the following keywords:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="literal">msgid</code>: match on original</p>
</li>
<li class="listitem">
<p><code class="literal">msgstr</code>: match on translation</p>
</li>
<li class="listitem">
<p><code class="literal">msgctxt</code>: match on disambiguating context</p>
</li>
</ul>
</div>
<p>For example, <code class="literal">{foobar}i</code> is equivalent to <code class="literal">*msgid/foobar/i</code>.</p>
<p>For plural messages, <code class="literal">msgid/.../</code> (and conversely <code class="literal">{...}</code>) tries to match either the <code class="varname">msgid</code> or the <code class="varname">msgid_plural</code> string, whereas <code class="literal">msgstr/.../</code> (and <code class="literal">[...]</code>) try to match any <code class="varname">msgstr</code> string. If only particular of these strings should be matched, the following keywords can be used as well:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="literal">msgid_singular</code>: match only the <code class="varname">msgid</code> string</p>
</li>
<li class="listitem">
<p><code class="literal">msgid_plural</code>: match only the <code class="varname">msgid_plural</code> string</p>
</li>
<li class="listitem">
<p><code class="literal">msgstr_<em class="replaceable"><code>N</code></em></code>: match only the <code class="varname">msgstr</code> string with index <code class="literal"><em class="replaceable"><code>N</code></em></code></p>
</li>
</ul>
</div>
<p><a name="p-triggerhooks" id="p-triggerhooks"></a>When regular expressions on message strings are not sufficient as rule triggers, a hook can be used instead. Hooks are described in <a class="xref" href="ch-common.html#sec-cmhooks" title="9.10.&nbsp;Processing Hooks">Section&nbsp;9.10, “Processing Hooks”</a>. Since hooks are Python functions, in principle any kind of test can be performed by them. A rule with the hook trigger is defined as follows:</p>
<pre class="programlisting">
*hook name="<em class="replaceable"><code>hookspec</code></em>" on="<em class="replaceable"><code>part</code></em>" casesens="[yes|no]"
# Rule subdirectives follow...
</pre>
<p>The <code class="literal">name=</code> field provides the hook specification. Only V* type (validation) hooks can be used in this context. The <code class="literal">on=</code> field defines on which part of the message the hook will operate, and needs to conform to the hook type. The following message parts can be specified, with associated hook types:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="literal">msg</code>: the hook applies to the complete message; for type V4A hooks.</p>
</li>
<li class="listitem">
<p><code class="literal">msgid</code>: the hook applies to the original text (<code class="varname">msgid</code>, <code class="varname">msgid_plural</code>), but considering other parts of the message; for type V3A and V3B hooks.</p>
</li>
<li class="listitem">
<p><code class="literal">msgstr</code>: the hook applies to the translation text (all <code class="varname">msgstr</code> strings), but considering other parts of the message; for type V3A and V3C hooks.</p>
</li>
<li class="listitem">
<p><code class="literal">pmsgid</code>: the hook applies to the original text, without considering the rest of the message; for type V1A hooks.</p>
</li>
<li class="listitem">
<p><code class="literal">pmsgstr</code>: the hook applies to the translation, without considering the rest of the message; for type V1A hooks.</p>
</li>
</ul>
</div>
<p>The <code class="literal">casesens=</code> field in trigger hook specification controls whether the patterns in the rest of the rule (primarily in <code class="literal">valid</code> subdirectives) are case-sensitive or not. This field can be omitted, and then patterns are case-sensitive.</p>
<p>If the rule trigger pattern matches (or the trigger hook reports some problems), the message is by default considered "failed" by the rule. The message may be still passed by subdirectives that follow, which test if some additional conditions hold.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrlsubdirs" id="sec-lgrlsubdirs"></a>8.5.4.&nbsp;Rule Subdirectives</h3>
</div>
</div>
</div>
<p>There are several types of rule subdirectives. The main subdirective is <code class="literal">valid</code>, which provides additional tests to pass the message failed by the trigger pattern. The tests are given by a list of <code class="literal"><em class="replaceable"><code>name</code></em>="<em class="replaceable"><code>pattern</code></em>"</code> entries. For a <code class="literal">valid</code> directive to pass the message, all its tests must hold, and if any of the <code class="literal">valid</code> directives passes the message, then the rule as whole passes it. Effectively, this means the boolean AND relationship within a directive, and OR across directives.</p>
<p>The following tests are currently available in <code class="literal">valid</code> subdirectives:</p>
<div class="variablelist">
<dl>
<dt><span class="term"><code class="literal">msgid="<em class="replaceable"><code>REGEX</code></em>"</code></span></dt>
<dd>
<p>The original text (<code class="varname">msgid</code> or <code class="varname">msgid_plural</code> string) must match the regular expression.</p>
</dd>
<dt><span class="term"><code class="literal">msgstr="<em class="replaceable"><code>REGEX</code></em>"</code></span></dt>
<dd>
<p>The translation (any <code class="varname">msgstr</code> string) must match the regular expression.</p>
</dd>
<dt><span class="term"><code class="literal">ctx="<em class="replaceable"><code>REGEX</code></em>"</code></span></dt>
<dd>
<p>The disambiguating context (<code class="varname">msgctxt</code> string) must match the regular expression.</p>
</dd>
<dt><span class="term"><code class="literal">srcref="<em class="replaceable"><code>REGEX</code></em>"</code></span></dt>
<dd>
<p>The file path of one of the source references (in <code class="literal">#: ...</code> comment) must match the regular expression</p>
</dd>
<dt><span class="term"><code class="literal">comment="<em class="replaceable"><code>REGEX</code></em>"</code></span></dt>
<dd>
<p>One of the extracted or translator comments (<code class="literal">#. ...</code> or <code class="literal"># ...</code>) must match the regular expression.</p>
</dd>
<dt><span class="term"><code class="literal">span="<em class="replaceable"><code>REGEX</code></em>"</code></span></dt>
<dd>
<p>The text segment matched by the trigger pattern must match this regular expression as well.</p>
</dd>
<dt><span class="term"><code class="literal">before="<em class="replaceable"><code>REGEX</code></em>"</code></span></dt>
<dd>
<p>The text segment matched by the trigger pattern must be placed exactly before one of the text segments matched by this regular expression.</p>
</dd>
<dt><span class="term"><code class="literal">after</code></span></dt>
<dd>
<p>The text segment matched by the trigger pattern must be placed exactly after one of the text segments matched by this regular expression.</p>
</dd>
<dt><span class="term"><code class="literal">cat="<em class="replaceable"><code>DOMAIN1</code></em>,<em class="replaceable"><code>DOMAIN2</code></em>,..."</code></span></dt>
<dd>
<p>The PO domain name (i.e. MO file name without <code class="filename">.mo</code> extension) must be contained in the given comma-separated list of domain names.</p>
</dd>
<dt><span class="term"><code class="literal">catrx="<em class="replaceable"><code>REGEX</code></em></code></span></dt>
<dd>
<p>The PO domain name must match the regular expression.</p>
</dd>
<dt><span class="term"><code class="literal">env="<em class="replaceable"><code>ENV1</code></em>,<em class="replaceable"><code>ENV2</code></em>,..."</code></span></dt>
<dd>
<p>The operating environment must be contained in the given comma-separated list of environment keywords.</p>
</dd>
<dt><span class="term"><code class="literal">head="/<em class="replaceable"><code>FIELD-REGEX</code></em>/<em class="replaceable"><code>VALUE-REGEX</code></em>"</code></span></dt>
<dd>
<p>The PO file header must contain the field and value combination, each specified by a regular expression pattern. Instead of <code class="literal">/</code>, any other character may be used consistently as delimiter for the field regular expression.</p>
</dd>
</dl>
</div>
<p>Each test can be negated by prefixing it with <code class="literal">!</code>. For example, <code class="literal">!cat="foo,bar"</code> will match if the PO domain name is neither <code class="literal">foo</code> nor <code class="literal">bar</code>. Tests are "short-circuiting", so it is good for performance to put simple direct matching tests (e.g. <code class="literal">cat=</code>, <code class="literal">env=</code>) before more more expensive regular expression tests (<code class="literal">msgid=</code>, <code class="literal">msgstr=</code>, etc.).</p>
<p>Subdirectives other than <code class="literal">valid</code> set states and properties of the rule. The property directives are written simply as <code class="literal"><em class="replaceable"><code>property</code></em>="<em class="replaceable"><code>value</code></em>"</code>. These include:</p>
<div class="variablelist">
<dl>
<dt><span class="term"><code class="literal">hint</code></span></dt>
<dd>
<p>A note to show to the user when the rule fails a message.</p>
</dd>
<dt><span class="term"><code class="literal">id</code></span></dt>
<dd>
<p>An "almost unique" identifier for the rule (see <a class="xref" href="ch-lingo.html#sec-lgrlenvs" title="8.5.6.&nbsp;Effect of Rule Environments">Section&nbsp;8.5.6, “Effect of Rule Environments”</a>).</p>
</dd>
</dl>
</div>
<p>State directives are given by the directive name, possibly followed by keyword parameters: <code class="literal"><em class="replaceable"><code>directive</code></em> <em class="replaceable"><code>arg1</code></em> ...</code>. These can be:</p>
<div class="variablelist">
<dl>
<dt><span class="term"><code class="literal">validGroup <em class="replaceable"><code>GROUPNAME</code></em></code></span></dt>
<dd>
<p>Includes a previously defined standalone group of <code class="literal">valid</code> subdirectives.</p>
</dd>
<dt><span class="term"><code class="literal">environment <em class="replaceable"><code>ENVNAME</code></em></code></span></dt>
<dd>
<p>Sets the environment in which the rule is applied.</p>
</dd>
<dt><span class="term"><code class="literal">disabled</code></span></dt>
<dd>
<p>Disables the rule, so that it is no longer applied to messages. Disabled rule can still be applied by direct request (e.g. using the <code class="option">rule:</code> parameter of <span class="command"><strong>check-rules</strong></span> sieve).</p>
</dd>
<dt><span class="term"><code class="literal">addFilterRegex</code>, <code class="literal">addFilterHook</code>, <code class="literal">removeFilter</code></span></dt>
<dd>
<p>A group of subdirectives to define filters which are applied to messages before the rule is applied to them. See <a class="xref" href="ch-lingo.html#sec-lgrlfilter" title="8.5.7.&nbsp;Filtering Messages">Section&nbsp;8.5.7, “Filtering Messages”</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrlglobdirs" id="sec-lgrlglobdirs"></a>8.5.5.&nbsp;Global Directives in Rule Files</h3>
</div>
</div>
</div>
<p>Global directives are typically placed at the beginning of a rule file, before any rules. They define common elements for all rules to use, or set state for all rules below them. A global directive can also be placed in the middle of the rule file, between two rules, when it will affect all the rules that follow it, but not those that precede it. The following global directives are defined:</p>
<div class="variablelist">
<dl>
<dt><span class="term"><code class="literal">validGroup</code></span></dt>
<dd>
<p>Defines common groups of <code class="literal">valid</code> subdirectives, which can be included by any rule using the <code class="literal">validGroup</code> subdirective:</p>
<pre class="programlisting">
# Global validity group.
validGroup passIfQuoted
valid after="“" before="”"
valid after="‘" before="’"

....

# Rule X.
{...}
validGroup passIfQuoted
valid ...
...

# Rule Y.
{...}
validGroup passIfQuoted
valid ...
...
</pre></dd>
<dt><span class="term"><code class="literal">environment</code></span></dt>
<dd>
<p>Sets a specific environment for the rules that follow, unless overriden with the namesake rule subdirective:</p>
<pre class="programlisting">
# Global environment.
environment FOO

...

# Rule X, belongs to FOO.
{...}
...

# Rule Y, overrides to BAR.
{...}
environment BAR
...
</pre>
<p>See <a class="xref" href="ch-lingo.html#sec-lgrlenvs" title="8.5.6.&nbsp;Effect of Rule Environments">Section&nbsp;8.5.6, “Effect of Rule Environments”</a> for details on use of environments.</p>
</dd>
<dt><span class="term"><code class="literal">include</code></span></dt>
<dd>
<p>Used to include files into rule files:</p>
<pre class="programlisting">
include file="foo.something"
</pre>
<p>If the file to include is specified by relative path, it is taken as relative to the file which includes it.</p>
<p>The intent behind <code class="literal">include</code> directive is not to include one rule file into another (files with <code class="filename">.rules</code> extension), because normally all rule files in a directory are automatically included by the rule applicator (e.g. <span class="command"><strong>check-rules</strong></span> sieve). Instead, files that are included should have an extension different from <code class="filename">.rules</code>, and contain a number of directives needed in several rule files; for example, a set of <a class="link" href="ch-lingo.html#sec-lgrlfilter" title="8.5.7.&nbsp;Filtering Messages">filters</a>.</p>
</dd>
<dt><span class="term"><code class="literal">addFilterRegex</code>, <code class="literal">addFilterHook</code>, <code class="literal">removeFilter</code></span></dt>
<dd>
<p>A group of directives to define filters which are applied to messages before the rules are applied. See <a class="xref" href="ch-lingo.html#sec-lgrlfilter" title="8.5.7.&nbsp;Filtering Messages">Section&nbsp;8.5.7, “Filtering Messages”</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrlenvs" id="sec-lgrlenvs"></a>8.5.6.&nbsp;Effect of Rule Environments</h3>
</div>
</div>
</div>
<p>When there are no <code class="literal">environment</code> directives in a rule file, either global or as rule subdirectives, then all rules in that rule file are considered as being "environment-agnostic". When applying a rule set (e.g. with the <span class="command"><strong>check-rules</strong></span> sieve), the applicator may be put into one or more <span class="emphasis"><em>operating environments</em></span>, either by specifying them as arguments (e.g. in command line) or in PO file headers. If one or more operating environments are given and the rule is environment-agnostic, it will be applied to the message irrespective of the operating environments. However, if there were some <code class="literal">environment</code> directives in the rule file, some rules will be environment-specific. An environment-specific rule will be applied only if its environment matches one of the set operating environments.</p>
<p>Rule environments are used to control application of rules between different translation environments (projects, teams, people). Some rules may be common to all environments, some may be somewhat common, and some not common at all. Common rules would than be made environment-agnostic (i.e. not covered by any <code class="literal">environment</code> directive), while entirely non-common rules would be provided in separate rule files per environment, with one global <code class="literal">environment</code> directive in each.</p>
<p>How to handle "somewhat" common rules depends on circumstances. They could simply be defined as environment-specific, just like non-common rules, but this may reduce the amount of common rules too much for the sake of perculiar environments. Another way would be to define them as environment-agnostic, and then override them in certain environments. This is done by giving the environment-specific rule the same identifier (<code class="literal">id</code> subdirective) as that of the environment-agnostic rule. It may also happen that the bulk of the rule is environment-agnostic, except for a few tests in <code class="literal">valid</code> subdirectives which are not. In this case, <code class="literal">env=</code> and <code class="literal">!env=</code> tests can be used to differentiate between environments.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrlfilter" id="sec-lgrlfilter"></a>8.5.7.&nbsp;Filtering Messages</h3>
</div>
</div>
</div>
<p>It is frequently advantageous to apply a set of rules not on the message as it is, but on a suitably filtered variant. For example, if rules are used for terminology checks, it would be good to remove any markup from the text; otherwise, an <code class="literal">&lt;email&gt;</code> tag in the original could be understood as a real word, and a warning issued for missing the expected counterpart in the translation.</p>
<p>Filters sets are created using <code class="literal">addFilter*</code> directives, global or within rules:</p>
<pre class="programlisting">
# Remove XML-like tags.
addFilterRegex match="&lt;.*?&gt;" on="pmsgid,pmsgstr"
# Remove long command-line options.
addFilterRegex match="--[\w-]+" on="pmsgid,pmsgstr"

# Rule A will act on a message filtered by previous two directives.
{...}
...

# Remove function calls like foo(x, y).
addFilterRegex match="\w+\(.*?\)" on="pmsgid,pmsgstr"

# Rule B will act on a message filtered by previous three directives.
{...}
...
</pre>
<p>Filters are added cumulatively to the filter set, and the current set is affecting all the rules below it.<sup>[<a name="id433807" href="#ftn.id433807" class="footnote" id="id433807">25</a>]</sup> If a <code class="literal">addFilter*</code> directive appears within the rule, it adds a filter only to the filter set of that rule:</p>
<pre class="programlisting">
# Rule C, with an additional filter just for itself.
{...}
addFilterRegex match="grep\(1\)" on="pmsgstr"
...

# Rule D, sees only previous global filter additions.
{...}
...
</pre>
<p>These examples illustrate use of the <code class="literal">addFilterRegex</code> directive, which is described in more detail below, as well as other <code class="literal">addFilter*</code> directives.</p>
<p>All <code class="literal">addFilter*</code> have the <code class="literal">on=</code> field. It specifies the message part on which the filter should operate, similar to the <code class="literal">on=</code> field in hook rule triggers. Unlike in triggers, in filters it is possible to state several parts to filter, as comma-separated list. The following message parts are exposed for filtering:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p><code class="literal">msg</code>: filter the "complete" message. What this means exactly depends on the particular filter directive.</p>
</li>
<li class="listitem">
<p><code class="literal">msgid</code>: filter the original text (<code class="varname">msgid</code>, <code class="varname">msgid_plural</code>), but possibly taking into account other parts of the message.</p>
</li>
<li class="listitem">
<p><code class="literal">msgstr</code>: filter the translation (all <code class="varname">msgstr</code> strings), but possibly taking into account other parts of the message.</p>
</li>
<li class="listitem">
<p><code class="literal">pmsgid</code>: filter the original text.</p>
</li>
<li class="listitem">
<p><code class="literal">pmsgstr</code>: filter the translation.</p>
</li>
<li class="listitem">
<p><code class="literal">pattern</code>: a quasi-part, to filter not the message, but all matching patterns (regular expressions, substring tests, equality tests) in the rules themselves.</p>
</li>
</ul>
</div>
<p>Not all filter directives can filter on all of these parts. Admissible parts are listed with each filter directive.</p>
<p>To remove a filter from the current filter set, <code class="literal">addFilter*</code> directives can define the filter <span class="emphasis"><em>handle</em></span>, which can then be given to a <code class="literal">removeFilter</code> directive:</p>
<pre class="programlisting">
addFilterRegex match="&lt;.*?&gt;" on="pmsgid,pmsgstr" handle="tags"

# Rule A, "tags" filter applies to it.
{...}
...

# Rule B, removes "tags" filter only for itself.
{...}
removeFilter handle="tags"
...

# Rule C, "tags" filter applies to it again.
{...}
...

removeFilter handle="tags"

# Rule D, "tags" filter does not apply to it and any following rule.
{...}
...
</pre>
<p>Several filters may share the same handle, in which case the <code class="literal">removeFilter</code> directive removes all of them from the current filter set. One filter can have more than one handle, given as comma-separated list of handles in <code class="literal">handle=</code> field, and then it can be removed from the filter set by any of those handles. Likewise, the <code class="literal">handle=</code> field in <code class="literal">removeFilter</code> directive can state several handles by which to remove filters. <code class="literal">removeFilter</code> as rule subdirective influences the complete rule, regardless of its position among other subdirectives.</p>
<p><code class="literal">clearFilters</code> directive is used to completely clear the filter set. It has no fields. Like <code class="literal">removeFilter</code>, it can be issued either globally, or as rule subdirective.</p>
<p>A filter may be added or removed only in certain environments, specified by the <code class="literal">env=</code> field in <code class="literal">addFilter*</code> and <code class="literal">removeFilter</code> directives.</p>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="sec-lgrlfiltdirs" id="sec-lgrlfiltdirs"></a>8.5.7.1.&nbsp;Filter Directives</h4>
</div>
</div>
</div>
<p>Currently the following directives for adding filters are available:</p>
<div class="variablelist">
<dl>
<dt><span class="term"><code class="literal">addFilterRegex</code></span></dt>
<dd>
<p>Parts of the text to remove are determined by a regular expression match. The pattern is given by the <code class="literal">match=</code> field. If instead of simple removal of the matched segment the replacement is wanted, the <code class="literal">repl=</code> field is used to specify the replacement string (it can include backreferences to regex groups in the pattern):</p>
<pre class="programlisting">
# Replace in translation the %&lt;number&gt; format directives with a tilde.
addFilterRegex match="%\d+" repl="~" on="pmsgstr"
</pre>
<p>Case-sensitivity of matching can be changed by adding the <code class="literal">casesens=[yes|no]</code> field; default is case-sensitive matching.</p>
<p>Applicable (<code class="literal">on=</code> field) to <code class="literal">pmsgid</code>, <code class="literal">pmsgstr</code>, and <code class="literal">pattern</code>.</p>
</dd>
<dt><span class="term"><code class="literal">addFilterHook</code></span></dt>
<dd>
<p>Text is processed with a filtering hook (F* hook types). The hook specification is given by the <code class="literal">name=</code> field. For example, to remove accelerator markers from UI messages in a smart way, while checking various sources for the exact accelerator marker character (command line, PO file header), this filter can be set:</p>
<pre class="programlisting">
addFilterHook name="remove/remove-accel-msg" on="msg"
</pre>
<p>Applicable (<code class="literal">on=</code> field) to <code class="literal">msg</code> (for F4A hooks), <code class="literal">msgid</code> (F3A, F3B), <code class="literal">msgstr</code> (F3A, F3C), <code class="literal">pmsgid</code> (F1A), <code class="literal">pmsgstr</code> (F1A), and <code class="literal">pattern</code> (F1A).</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="sec-lgrlfiltercost" id="sec-lgrlfiltercost"></a>8.5.7.2.&nbsp;Cost of Filtering</h4>
</div>
</div>
</div>
<p>Filtering may be run-time expensive, and it normally is in practical uses. Therefore the rule applicator will try to create and apply as few unique filter sets as possible, by considering their signatures -- a hash of ordering, type, and fields in the filter set for the given rule. Each message will be filtered only as many times as there are different filter sets, rather than once for every rule. The appropriate filtered version of the message will be given to each rule according to its filter set.</p>
<p>This means that you should be careful when adding and removing filters, in order to have as few filter sets as really necessary. For example, you may know that filters P and Q can be applied in any order, and in one rule file specify P followed by Q, but in another rule file Q followed by P. However, the rule applicator must assume that the order of filters is significant, so it will create two filter sets, PQ and QP, and spend twice as much time in filtering.</p>
<p>For big filter sets which are needed in several rule files, the best is to split them out in a separate file and use the <code class="literal">include</code> global directive to include them at the beginning of rule files.</p>
</div>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrlquotesc" id="sec-lgrlquotesc"></a>8.5.8.&nbsp;Quoting and Escaping</h3>
</div>
</div>
</div>
<p>In all the examples so far, ASCII double quotes were used as value delimiters (<code class="literal">"..."</code>). However, just as in the verbose notation for trigger patterns (<code class="literal">*msgid/.../</code>, etc.), all quoted values can in fact consistently use any other non-alphanumeric character (e.g. single quote, slash, etc.). On the other hand, literal quotes inside a value can be escaped by prefixing them with <code class="literal">\</code> (backslash). Values which are regular expression are sent to the regular expression engine without resolving any escapes other than for the quote character itself.</p>
<p>The general statement terminator in a rule file is the newline, but if a line would be too long, it can be continued into the next line by putting <code class="literal">\</code> (backslash) in the last column.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgrlfalse" id="sec-lgrlfalse"></a>8.5.9.&nbsp;Canceling False Positives</h3>
</div>
</div>
</div>
<p>As it was explained earlier, it is very important to have a through system of handling false positives in validation rules. There are several levels on which false positives can be canceled, and they will be described in the following, going from the nearest to the furthest from the rule definition itself. Some guidelines on when to use which level will also be provided, but you should keep in mind that this is far from a well-examined topic.</p>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="sec-lgrlfpdisable" id="sec-lgrlfpdisable"></a>8.5.9.1.&nbsp;Disabling a Rule</h4>
</div>
</div>
</div>
<p>The <code class="literal">disable</code> subdirective can be added to the rule to disable its application. This may seem a quaint method of "handling false positivies", but it is not outright ridiculous, because a disabled rule can still be applied by directly requesting it (e.g. <code class="option">rule:</code> parameter of <span class="command"><strong>check-rules</strong></span>). This is useful for rules which produce too many false positivies to be applied as part of a rule set, but which are still better than ad-hoc searches. In other words, such rules can be understood as codified special searches, to be run only when the user has enough time to wade through all the false positives in search for the few real problems.</p>
</div>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="sec-lgrlfptrigger" id="sec-lgrlfptrigger"></a>8.5.9.2.&nbsp;Restricting the Rule Trigger</h4>
</div>
</div>
</div>
<p>The first real way of canceling false positives is by making the regular expression pattern for the rule trigger less greedy. For example, the trigger pattern for the terminology rule on "tool" could be written at first as:</p>
<pre class="programlisting">
{\btool}i
</pre>
<p>This will match any word that starts with <code class="literal">tool</code>, due to <code class="literal">\b</code> word boundary token at pattern start. The word boundary is not repeated at the end with the intention to also catch the plural form of the word, "tools". But, this pattern will also match the word "toolbar", which may have its own rule. Then, the pattern can be restricted to really match only "tool" and "tools", in several ways, for example:</p>
<pre class="programlisting">
{\btools?\b}i
</pre>
<p>Now the word boundary is placed at the end as well, but also the optional letter 's' is inserted (<code class="literal">?</code> means "zero or one appearance of the preceding element"). Another way would be to write out both forms in full:</p>
<pre class="programlisting">
{\b(tool|tools)\b}i
</pre>
<p>The brackets are needed because the OR-operator <code class="literal">|</code> has lower priority than word boundary <code class="literal">\b</code>, so without brackets the meaning would be "word which starts with 'tool' or ends with 'tools'".</p>
</div>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="sec-lgrlfpvaldir" id="sec-lgrlfpvaldir"></a>8.5.9.3.&nbsp;Adding <code class="literal">valid</code> Subdirectives to the Rule</h4>
</div>
</div>
</div>
<p>Python's regular expressions, used in rule patterns, have rich special features, but which are frequently better not used in rules. For example, the trigger for the terminology rule on "line" (of text) could be written at first as:</p>
<pre class="programlisting">
{\blines?\b}i
</pre>
<p>But this would also catch the phrase "command line", which as a standalone concept, may have its own rule. To avoid this match, a proficient user of regular expressions may think of adding a <span class="emphasis"><em>negative lookbehind</em></span> to the trigger pattern:</p>
<pre class="programlisting">
{(?&lt;!command )\blines?\b}i
</pre>
<p>However, it much less cryptic and more extensible to add a <code class="literal">valid</code> subdirective instead:</p>
<pre class="programlisting">
{\blines?\b}i
valid after="command "
</pre>
<p>This cancels the rule if the word "line" was matched just after the word "command", while clearly showing the special-case context.</p>
<p><code class="literal">valid</code> subdirectives are particularly useful for wider rule cancelations, such as by PO domain (catalog) name. For example, the word "wizard" could be translated differently when denoting a step-by-step dialog in a utilitarian program and a learned magic wielding character in a computer game. Then the <code class="literal">cat=</code> test can be used to allow the other term in the game's PO file:</p>
<pre class="programlisting">
{\bwizard}i
valid msgstr="<em class="replaceable"><code>term-for-step-by-step-dialog</code></em>
valid cat="foodungeon" msgstr="<em class="replaceable"><code>term-for-magician</code></em>"
</pre>
<p>This requires specifying the domain names of all games with wizard characters to which the rule set is applied, which may not be that comfortable. Another way could be to introduce the <code class="literal">fantasy</code> environment and use the <code class="literal">env=</code> test:</p>
<pre class="programlisting">
{\bwizard}i
valid msgstr="<em class="replaceable"><code>term-for-step-by-step-dialog</code></em>"
valid env="fantasy" msgstr="<em class="replaceable"><code>term-for-magician</code></em>"
</pre>
<p>and to add the <code class="literal">fantasy</code> environment <a class="link" href="ch-common.html#hdr-x-environment">into the header</a> of the PO file that needs it.</p>
</div>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="sec-lgrlfpskip" id="sec-lgrlfpskip"></a>8.5.9.4.&nbsp;Skipping the Rule on a Message</h4>
</div>
</div>
</div>
<p>Sometimes there is just a single strange message that falsely triggers the rule, such that there is nothing to generalize about the false positive. You could still cancel this false positivie in the rule definition itself, by adding a <code class="literal">valid</code> directive with the <code class="literal">cat=</code> test for the PO domain name and <code class="literal">msgid=</code> test to single out the troublesome message:</p>
<pre class="programlisting">
{\bfroobaz}i
id="term-frobaz"
valid msgstr="..."
valid cat="foo" msgid="the amount of froobaz-HX which led to"
</pre>
<p>However, rules are supposed to be at least somewhat general, and singling out a particular message in the rule is as excessive non-generality as it gets. It is also a maintenance problem: the message may dissapear in the future, leaving cruft in the rule file, or it may change slightly, but enough for the <code class="literal">msgid=</code> test not to match it any more.</p>
<p>A much better way of skipping a rule on a particular message is by adding a special translator comment to that message, in the PO file:</p>
<pre class="programlisting">
# skip-rule: term-froobaz
msgid "...the amount of froobaz-HX which led to..."
msgstr "..."
</pre>
<p>The comment starts with <code class="literal">skip-rule:</code>, and is followed by a comma-separated list of rules to skip, by their identifiers (defined by <code class="literal">id=</code> in the rule).</p>
<p>There is a catch to the translator comment approach, though. When a with <code class="literal">skip-rule:</code> comment message becomes fuzzy, it depends on the new text of the message whether the comment should be kept or removed. This means that on fuzzy messages translators have to observe and adapt translator comments just as they adapt the <code class="varname">msgstr</code> strings. Unfortunatelly, some translators do not pay sufficient attention to translator comments, which is further exacerbate by some PO editors, which underrepresent translator comments in the user interface (or even do not enable editing them!). However, from the point of view of PO translation workflow, not giving full attention to translator comments is plainly an error: translators should be told better, and PO editors should be upgraded.<sup>[<a name="id401924" href="#ftn.id401924" class="footnote" id="id401924">26</a>]</sup></p>
</div>
<div class="sect3">
<div class="titlepage">
<div>
<div>
<h4 class="title"><a name="sec-lgrlfpreworig" id="sec-lgrlfpreworig"></a>8.5.9.5.&nbsp;Rewriting Original Text of a Message</h4>
</div>
</div>
</div>
<p>Sometimes it is possible to do better than plainly skipping a rule on a message. Consider the following message:</p>
<pre class="programlisting">
#: dialogs/ScriptManager.cpp:498
msgid "Please refer to the console debug output for more information."
msgstr "Pogledajte ispravljački izlaz u školjci za više podataka."
</pre>
<p>An observant translator could conclude that "console" is not the best choice of term in the original text, that "shell" (or "terminal") would be more accurate, and translate the message as if the more accurate term was used in the original. However, this could cause the terminology rule for "console" (in its accurate meaning) to complain about the proper term missing in translation. Adding <code class="literal">skip-rule: term-console</code> comment would indeed cancel this false positive, but what about the terminology rule on "shell"? There is nothing in the original text to trigger it and check for the proper term in translation.</p>
<p>This example is an instance of the general case where the translator would formulate the original text somewhat differently, and make the translation based on that reformulation. Or, when the mere style of the original causes a rule to be falsely triggered, while diferently worded original would be just fine. In such cases, instead of adding a comment to crudely skip a rule, translator can add a comment to <span class="emphasis"><em>rewrite</em></span> the original text before applying rules to it:</p>
<pre class="programlisting">
# rewrite-msgid: /console/shell/
#: dialogs/ScriptManager.cpp:498
msgid "Please refer to the console debug output for more information."
msgstr "Pogledajte ispravljački izlaz u školjci za više podataka."
</pre>
<p>The rewrite directive comment starts with <code class="literal">rewrite-msgid:</code> and is followed by search regular expression and replacement strings, delimited with <code class="literal">/</code> or another non-alphanumeric character. With this rewrite, the wrong terminology rule, for "console", will not be triggered, while the correct rule, for "shell", will be.</p>
<p>At the moment, unlike <code class="literal">skip-rule:</code>, <code class="literal">rewrite-msgid:</code> is not an integral part of the rule system. It is instead implemented as a filtering hook. So to use it, add this filter into rule files (or into the filter set file included by rule files):</p>
<pre class="programlisting">
addFilterHook name="remove/rewrite-msgid" on="msg"
</pre>
<p>Sometimes it is not quite clear whether to skip a rule or rewrite the original, that is, whether to use <code class="literal">skip-rule:</code> or <code class="literal">rewrite-msgid:</code> comment. A guideline could be as follows. If the concept covered by the falsely triggered rule is present but somewhat camouflaged in the original, or one concept is switched for another (such as "console" with "shell" in the example above), then <code class="literal">rewrite-msgid:</code> should be used to "normalize" the original text. If the original text has nothing to do with the concept covered by the triggered rule, then <code class="literal">skip-rule:</code> should be used. An example of the latter would be such a message from a game:</p>
<pre class="programlisting">
# skip-rule: term-shell
# src/tanks_options.cpp:249
msgid "Fire shells upward"
</pre>
<p>Here the word "shell" denotes a cannon shell, which has nothing to do with <code class="literal">term-shell</code> rule for the operating system shell, and the rule is therefore skipped.</p>
</div>
</div>
</div>
<div class="sect1">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both"><a name="sec-lgsynder" id="sec-lgsynder"></a>8.6.&nbsp;Syntagma Derivation</h2>
</div>
</div>
</div>
<p>Consider a message extracted from a .desktop file, representing the name of a GUI utility:</p>
<pre class="programlisting">
#. field: Name
#: data/froobaz.desktop:5
msgid "Froobaz Image Examiner"
msgstr ""
</pre>
<p>Program names from .desktop files can be read and presented to the user by any other program. For example, when an image is right-clicked in a file browser, it could offer to open the file with the utility named with this message. In the PO file of that file browser, the message for the menu item could be:</p>
<pre class="programlisting">
#. TRANSLATORS: %s is a program name, to open a file with.
#: src/contextmenu.c:5
msgid "Open with %s"
msgstr ""
</pre>
<p>In languages featuring noun inflection, it is likely that the program name in this message should have the grammar case different from the nominative (basic) case. This means that simply inserting the name read from the .desktop file, into directly translated text, will produce a grammatically incorrect phrase. Translator may try to adapt the message to the nominative form of the name (by shuffling words, adding "helper" words, adding punctuation), but this will produce stylistically suboptimal phrase. That is, style will be sacrificed for grammar. In order not to have to make such compromises, now and in the future certain <span class="emphasis"><em>translation scripting</em></span> systems may be available atop the PO format<sup>[<a name="id434079" href="#ftn.id434079" class="footnote" id="id434079">27</a>]</sup>, which would, in this example, enable the translator to specify which non-nominative form of the program name to fetch and insert.</p>
<p>Whatever the shape the translation scripting system takes, different forms of phrases have to be derived somehow for use by that system. Given the nuances of spoken languages, fully automatic derivation is probably not going to be possible<sup>[<a name="id434106" href="#ftn.id434106" class="footnote" id="id434106">28</a>]</sup>. Pology therefore provides the <span class="emphasis"><em>syntagma<sup>[<a name="id434122" href="#ftn.id434122" class="footnote" id="id434122">29</a>]</sup> derivator</em></span> system (<span class="emphasis"><em>synder</em></span> for short), which allows manual derivation of phrase forms and properties with minimal verbosity, using macro expansion based on partial regularities in the grammar.</p>
<p>Syntagma derivations can be written and maintained in a standalone plain text file, although currently Pology provides no end-user functionality to convert such files (i.e. derive all forms defined by them) to formats which a target translation system could consume. Instead, one can make use of the <code class="classname">Synder</code> class from the <span class="package">pology.synder</span> module to construct a custom converters. Of course, in the future, such converters may become part of Pology. There are already syntax highlighting definitions for the synder file format, for some text editors, in the <code class="filename">syntax/</code> directory of Pology distribution.</p>
<p>What is provided right now in terms of end-user functionality is <a class="link" href="ch-sieve.html#sv-collect-pmap" title="3.5.12.&nbsp;collect-pmap">the <span class="command"><strong>collect-pmap</strong></span> sieve</a>. It enables translators to write syntagma derivations in translator comments in PO messages, and then extract them (deriving all forms) into a file in the appropriate format for the target translation system. The example message above from the .desktop file could be equipped with a synder entry like this:</p>
<pre class="programlisting">
# synder: Frubaz|ov ispitiv|ač slika
#. field: Name
#: data/froobaz.desktop:5
msgid "Froobaz Image Examiner"
msgstr "Frubazov ispitivač slika"
</pre>
<p>The translator comment starts with the keyword <code class="literal">synder:</code>, and is followed by the synder entry which defines all the needed forms of the translated name. What you can see is that the synder entry is quite compact, exactly two characters longer than the pure translated name, and yet it defines over a dozen forms and some properties (gender, number) of the name.</p>
<p>The rest of this section describes the syntax of synder entries, and the layout and organization of synder files. As an example application, we consider a dictionary of proper names, where for each name in the source language we want to define the basic name and some of its forms and properties in the target language.</p>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsdbasic" id="sec-lgsdbasic"></a>8.6.1.&nbsp;Basic Derivations</h3>
</div>
</div>
</div>
<p>For the name in source language <span class="emphasis"><em>Venus</em></span> and in target language <span class="emphasis"><em>Venera</em></span>, we could write the following simplest derivation, which defines only the basic form in the target language:</p>
<pre class="programlisting">
Venus: =Venera
</pre>
<p><code class="literal">Venus</code> is the <span class="emphasis"><em>key syntagma</em></span> or the <span class="emphasis"><em>derivation key</em></span>, and it is separated by the colon (<code class="literal">:</code>) from the properties of the syntagma. Properties are written as <code class="literal"><em class="replaceable"><code>key</code></em>=<em class="replaceable"><code>value</code></em></code> pairs, and separated by commas; in <code class="literal">=Venera</code>, the <span class="emphasis"><em>property key</em></span> is the empty string, and the <span class="emphasis"><em>property value</em></span> is <code class="literal">Venera</code>.</p>
<p>We would now like to define some grammar cases in the target language. <span class="emphasis"><em>Venera</em></span> is the nominative (basic) case, so instead of the empty string we set <code class="literal">nom</code> as its property key. Other cases that we want to define are genitive (<code class="literal">gen</code>) <span class="emphasis"><em>Venere</em></span>, dative (<code class="literal">dat</code>) <span class="emphasis"><em>Veneri</em></span>, and accusative (<code class="literal">acc</code>) <span class="emphasis"><em>Veneru</em></span>. Then we can write:</p>
<pre class="programlisting">
Venus: nom=Venera, gen=Venere, dat=Veneri, acc=Veneru
</pre>
<p>By this point, everything is written out manually, there are no "macro derivations" to speak of. But observe the difference between different grammar cases of <span class="emphasis"><em>Venera</em></span> -- only the final letter is changing. Therefore, we first write the following <span class="emphasis"><em>base derivation</em></span> for this system of case endings alone, called <code class="literal">declension-1</code>:</p>
<pre class="programlisting">
|declension-1: nom=a, gen=e, dat=i, acc=u
</pre>
<p>A base derivation is normally also <span class="emphasis"><em>hidden</em></span>, by prepending <code class="literal">|</code> (pipe) to its key syntagma. We make it hidden because it should be used only in other derivations, and does not represent a proper entry in our dictionary example. In the processing stage, derivations with hidden key syntagmas will not be offered on queries into dictionary. We can now use this base derivation to shorten the derivation for <span class="emphasis"><em>Venus</em></span>:</p>
<pre class="programlisting">
Venus: Vener|declension-1
</pre>
<p>Here <code class="literal">Vener</code> is the <span class="emphasis"><em>root</em></span>, and <code class="literal">|declension-1</code> is the <span class="emphasis"><em>expansion</em></span>, which references the previously defined base derivation. The final forms are derived by inserting the property values found in the expansion (<code class="literal">a</code> from <code class="literal">nom=a</code>, <code class="literal">e</code> from <code class="literal">gen=e</code>, etc.) at the position where the expansion occurs, for each of the property keys found in the expansion, thus obtaining the desired properties (<code class="literal">nom=Venera</code>, <code class="literal">gen=Venere</code>, etc.) for the current derivation.</p>
<p>Note that <code class="literal">declension-1</code> may be a too verbose name for the base derivation. If the declension type can be identified by the stem of the nominative case (here <code class="literal">a</code>), to have much more natural derivations we could write:</p>
<pre class="programlisting">
|a: nom=a, gen=e, dat=i, acc=u
Venus: Vener|a
</pre>
<p>Now the derivation looks just like the nominative case alone, only having the root and the stem separated by <code class="literal">|</code>.</p>
<p>The big gain of this transformation is, of course, when there are many syntagmas having the same declension type. Other such source-target pairs could be <span class="emphasis"><em>Earth</em></span> and <span class="emphasis"><em>Zemlja</em></span>, <span class="emphasis"><em>Europe</em></span> and <span class="emphasis"><em>Evropa</em></span>, <span class="emphasis"><em>Rhea</em></span> and <span class="emphasis"><em>Reja</em></span>, so we can write:</p>
<pre class="programlisting">
|a: nom=a, gen=e, dat=i, acc=u
Venus: Vener|a
Earth: Zemlj|a
Europe: Evrop|a
Rhea: Rej|a
</pre>
<p>From this it can also be seen that derivations are terminated by newline. If necessary, single derivation can be split into several lines by putting a <code class="literal">\</code> character (backslash) at the end of each line but the last.</p>
<p>Expansions are implicitly terminated by a whitespace or a comma, or by another expansion. If these characters are part of the expansion itself (i.e. of the key syntagma of the derivation that the expansion refers to), or the text continues right after the expansion without a whitespace, curly brackets can be used to explicitly delimit the expansion:</p>
<pre class="programlisting">
Alpha Centauri: Alf|{a}-Kentaur
</pre>
<p>Any character which is special in the current context may be escaped with a backslash. Only the second colon here is the separator:</p>
<pre class="programlisting">
Destination\: Void: Odredišt|{e}: ništavilo
</pre>
<p>because the first colon is escaped, and the third colon is not in the context where colon is a special character.</p>
<p>A single derivation may state more than one key syntagma, comma-separated. For example, if the syntagma in source language has several spellings:</p>
<pre class="programlisting">
Iapetus, Japetus: Japet|
</pre>
<p>The key syntagma can also be an empty string. This is useful for base derivations when the stem-naming is used and the stem happens to be null -- such as in the previous example. The derivation to which this empty expansion refers to would be:</p>
<pre class="programlisting">
|: nom=, gen=a, dat=u, acc=
</pre>
<p>Same-valued properties do not have to be repeated, but instead several property keys can be linked to one value, separated with <code class="literal">&amp;</code> (ampersand). In the previous base derivation, <code class="literal">nom=</code> and <code class="literal">acc=</code> properties could be unified in this way, resulting in:</p>
<pre class="programlisting">
|: nom&amp;acc=, gen=a, dat=u
</pre>
<p>Synder files may contain comments, starting with <code class="literal">#</code> and continuing to the end of line:</p>
<pre class="programlisting">
# A comment.
Venus: Vener|a # another comment
</pre></div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsdmulexp" id="sec-lgsdmulexp"></a>8.6.2.&nbsp;Multiple Expansions</h3>
</div>
</div>
</div>
<p>A single derivation may contain more than one expansion. There are two distinct types of multiple expansion, <span class="emphasis"><em>outer</em></span> and <span class="emphasis"><em>inner</em></span>.</p>
<p>Outer multiple expansion is used when it is advantageous to split derivations by grammar classes. The examples so far were only deriving grammar cases of nouns, but we may also want to define possesive adjectives per noun. For <span class="emphasis"><em>Venera</em></span>, the possesive adjective in nominative case is <span class="emphasis"><em>Venerin</em></span>. Using the stem-naming of base derivations, we could write:</p>
<pre class="programlisting">
|a: …  # as above
|in: …  # posessive adjective
Venus: Vener|a, Vener|in
</pre>
<p>Expansions are resolved from left to right, with the expected effect of derived properties accumulating along the way. The only question is what happens if two expansions produce properties with same keys but different values. In this case, the value produced by the last (rightmost) expansion overrides previous values.</p>
<p>Inner multiple expansion is used on multi-word syntagmas, when more than one word needs expansion. For example, the source syntagma <span class="emphasis"><em>Orion Nebula</em></span> has the target pair <span class="emphasis"><em>Orionova maglina</em></span>, in which the first word is a possesive adjective, and the second word a noun. The derivation for this is:</p>
<pre class="programlisting">
|a: …  # as above
|ova&gt;: …  # posessive adjective as noun, &gt; is not special here
Orion Nebula: Orion|ova&gt; maglin|a
</pre>
<p>Inner expansions are resolved from left to right, such everything on the right of the expansion currently resolved is treated as literal text. If all expansions define same properties by key, then the total derivation will have all those properties, with values derived as expected. However, if there is some difference in property sets, then the total derivation will get their intersection, i.e. only those properties found in all expansions.</p>
<p>Both outer and inner expansion may be used in a single derivation.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsdexpmask" id="sec-lgsdexpmask"></a>8.6.3.&nbsp;Expansion Masks</h3>
</div>
</div>
</div>
<p>An expansion can be made not to include all the properties defined in the refered to derivation, but only a subset of them. It can also be made to modify the property keys from the refered to derivation.</p>
<p>Recall the example of <span class="emphasis"><em>Orion Nebula</em></span> and <span class="emphasis"><em>Orionova maglina</em></span>. Here the possesive adjective <span class="emphasis"><em>Orionova</em></span> has to be matched in both case and gender to the noun <span class="emphasis"><em>maglina</em></span>, which is of feminine gender. Earlier we defined a special adjective-as-noun derivation <code class="literal">|ova&gt;</code>, specialized for feminine gender nouns, but now we want to make use of the full posessive adjective derivation, which is not specialized to any gender. Let the property keys of this derivation be of the form <code class="literal">nommas</code> (nominative masculine), <code class="literal">genmas</code> (genitive masculine), …, <code class="literal">nomfem</code> (nominative feminine), <code class="literal">genfem</code> (genitive feminine), …. If we use the stem of nominative masculine form, <span class="emphasis"><em>Orionov</em></span>, to name the possesive adjective base derivation, we get:</p>
<pre class="programlisting">
|ov: nommas=…, genmas=…, …, nomfem=…, genfem=…, …
Orion Nebula: Orion|ov~...fem maglin|a
</pre>
<p><code class="literal">|ov~...fem</code> is a <span class="emphasis"><em>masked</em></span> expansion. It specifies to include only those properties with keys starting with any three characters and ending in <code class="literal">fem</code>, as well as to drop <code class="literal">fem</code> (being a constant) from the resulting property keys. This precisely selects only the feminine forms of the possesive adjective and transforms their keys into noun keys needed to match with those of <code class="literal">|a</code> expansion.</p>
<p>We could also use this same masked expansion as the middle step, to produce the feminine-specialized adjective-as-noun base derivation:</p>
<pre class="programlisting">
|ov: nommas=…, genmas=…, …, nomfem=…, genfem=…, …
|ova&gt;: |ov~...fem
Orion Nebula: Orion|ova&gt; maglin|a
</pre>
<p>A special case of masked expansion is when there are no variable characters in the mask (no dots). In the pair <span class="emphasis"><em>Constellation of Cassiopeia</em></span> and <span class="emphasis"><em>Sazvežđe Kasiopeje</em></span>, the <span class="emphasis"><em>of Cassiopeia</em></span> is translated as single word in genitive case, <span class="emphasis"><em>Kasiopeje</em></span>, avoiding the need for preposition. If standalone <span class="emphasis"><em>Cassiopeia</em></span> has its own derivation, then we can use it like this:</p>
<pre class="programlisting">
Cassiopeia: Kasiopej|a
Constellation of Cassiopeia: Sazvežđ|e |Cassiopeia~gen
</pre>
<p><code class="literal">|e</code> is the usual nominative-stem expansion. The <code class="literal">|Cassiopeia~gen</code> expansion produces only the genitive form of <span class="emphasis"><em>Cassiopeia</em></span>, but with the empty property key. If this expansion would be treated as normal inner expansion, it would cancel all properties produced by <code class="literal">|e</code> expansion, since none of them has an empty key. Instead, when an expansion produces a single property with empty key, its value is treated as literal text and concatenated to all property values produced up to that point. Just as if we had written:</p>
<pre class="programlisting">
Constellation of Cassiopeia: Sazvežđ|e Kasiopeje
</pre>
<p>Sometimes the default modification of propety keys, removal of all fixed characters in the mask, is not what we want. This should be a rare case, but if it happens, the mask can also be given a <span class="emphasis"><em>key extender</em></span>. For example, if we would want to select only feminine forms of the <code class="literal">|ov</code> expansion, but preserve the <code class="literal">fem</code> ending of the resulting keys, we would write:</p>
<pre class="programlisting">
Foobar: Fubar|ov~...fem%*fem
</pre>
<p>The key extender in this expansion is <code class="literal">%*fem</code>. For each resulting property, the final key is constructed by substituting every <code class="literal">*</code> with the key resulting from the <code class="literal">~...fem</code> mask. Thus, the <code class="literal">fem</code> ending is readded to every key, as desired.</p>
<p>Expanded values can have their capitalization changed. By prepending <code class="literal">^</code> (circumflex) or <code class="literal">`</code> (backtick) to the syntagma key of the expansion, the first letter in fetched values is uppercased or lowercased, respectively. We could derive the pair <span class="emphasis"><em>Distant Sun</em></span> and <span class="emphasis"><em>Udaljeno sunce</em></span> by using the pair <span class="emphasis"><em>Sun</em></span> and <span class="emphasis"><em>Sunce</em></span> (note the case difference in <span class="emphasis"><em>Sunce</em></span>/<span class="emphasis"><em>sunce</em></span>) like this:</p>
<pre class="programlisting">
Sun: Sunc|e  # this defines uppercase first letter
Distant Sun: Dalek|o&gt; |`Sun  # this needs lowercase first letter
</pre></div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsdspecprop" id="sec-lgsdspecprop"></a>8.6.4.&nbsp;Special Properties</h3>
</div>
</div>
</div>
<p>Property keys may be given several endings, to make these properties behave differently from what was described so far. These ending are not treated as part of the property key itself, so they should not be given when querying derivations by syntagma and property key.</p>
<p><span class="emphasis"><em>Cutting</em></span> properties are used to avoid the normal value concatenation on expansion. For example, if we want to define the gender of nouns through base expansions, we could come up with:</p>
<pre class="programlisting">
|a: nom=a, gen=e, dat=i, acc=u, gender=fem
Venus: Vener|a
</pre>
<p>However, this will cause the <code class="literal">gender</code> property in expansion to become <code class="literal">Venerafem</code>. For the <code class="literal">gender</code> property to be taken verbatim, without concatenting segments from the calling derivation, we make it a cutting property by appending <code class="literal">!</code> (exclamation mark) to its key:</p>
<pre class="programlisting">
|a: nom=a, gen=e, dat=i, acc=u, gender!=fem
</pre>
<p>Now when dictionary is queried for <code class="literal">Venus</code> syntagma and <code class="literal">gender</code> property, we will get the expected <code class="literal">fem</code> value.</p>
<p>Cutting properties also behave differently in multiple inner expansions. Instead of being canceled when not all inner expansions define it, simply the rightmost value is taken -- just like in outer expansions.</p>
<p><span class="emphasis"><em>Terminal</em></span> properties are those hidden with respect to expansion, i.e. they are not taken into the calling derivation. A property is made terminal by appending <code class="literal">.</code> (dot) to its key. For example, if some derivations have the short description property <code class="literal">desc</code>, we typically do not want it to propagate into calling derivations which happen not to override it by outer expansion:</p>
<pre class="programlisting">
Mars: Mars|, desc.=planet
Red Mars: Crven|i&gt; |Mars  # a novel
</pre>
<p><span class="emphasis"><em>Canceling</em></span> properties will cause a previously defined property with the same key to be removed from the collection of properties. Canceling property is indicated by ending its key with <code class="literal">^</code> (circumflex). The value of canceling property has no meaning, and can be anything. Canceling is useful in expansions and alternative derivations (more on that later), where some properties introduced by expansion or alternative fallback should be removed from the final collection of properties.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsdtags" id="sec-lgsdtags"></a>8.6.5.&nbsp;Text Tags</h3>
</div>
</div>
</div>
<p>Key syntagmas and property values can be equipped with arbitrary simple tags, which start with the tag name in the form <code class="literal">~<em class="replaceable"><code>tag</code></em></code> and extend to the next tag or the end of syntagma. For example, when deriving people names, we may want to tag their first and last name, using tags <code class="literal">~fn</code> and <code class="literal">~ln</code> respectively:</p>
<pre class="programlisting">
~fn Isaac ~ln Newton: ~fn Isak| ~ln Njutn|
</pre>
<p>In default queries to the dictionary, tags are simply ignored, syntagmas and property values are reported as if there were no tags. However, custom derivators (based on the <code class="classname">Synder</code> class from <span class="package">pology.synder</span>) can define transformation functions, to which tagged text segments will be passed, so that they can treat them specially when producing the final text.</p>
<p>Tag is implicitly terminated by whitespace or comma (or colon in key syntagmas), but if none of these characters can be put after the tag, the tag name can be explicitly delimited with curly brackets, as <code class="literal">~{<em class="replaceable"><code>tag</code></em>}</code>.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsdalts" id="sec-lgsdalts"></a>8.6.6.&nbsp;Alternative Derivations</h3>
</div>
</div>
</div>
<p>Sometimes there may be several alternative derivations to the given syntagma. The default derivation (in some suitable sense) is written as explained so far, and alternative derivations are written under named <span class="emphasis"><em>environments</em></span>.</p>
<p>For example, if deriving a transcribed person's name, there may be several versions of the transcription. <span class="emphasis"><em>Isaac Newton</em></span>, as the name of the Renaissance scientist, may be normally used in its traditional transcription <span class="emphasis"><em>Isak Njutn</em></span>, while a contemporary person of that name would be transcribed in the modern way, as <span class="emphasis"><em>Ajzak Njuton</em></span>. Then, in the entry of Newton the scientist, we could also mention what the modern transcription would be, under the environment <code class="literal">modern</code>:</p>
<pre class="programlisting">
Isaac Newton: Isak| Njutn|
    @modern: Ajzak| Njuton|
</pre>
<p>Alternative derivations are put on their own lines after the default derivation, and instead of the key syntagma, they begin with the environment name. The environment name starts with <code class="literal">@</code> and ends with colone, and then the usual derivation follows. It is conventional, but not mandatory, to add some indent to the environment name. There can be any number of non-default environments.</p>
<p>The immediate question that arises is how are expansions treated in non-default environments. In the previous example, what does <code class="literal">|</code> expansion resolve to in <code class="literal">modern</code> environment? This depends on how the synder file is processed. By default, it is required that derivations referenced by expansions have matching environments. If <code class="literal">|</code> were defined as:</p>
<pre class="programlisting">
|: nom=, gen=a, dat=u, acc=
</pre>
<p>then the expansion of <span class="emphasis"><em>Isaac Newton</em></span> in <code class="literal">modern</code> environment would fail. Instead, it would be necessary to define the base derivations as:</p>
<pre class="programlisting">
|: nom=, gen=a, dat=u, acc=
    @modern: nom=, gen=a, dat=u, acc=
</pre>
<p>However, this may not be a very useful requirement. As can be seen in this example already, in many cases base derivations are likely to be same for all environments, so they would be needlessly duplicated. It is therefore possible to define <span class="emphasis"><em>environment fallback</em></span> chain in processing, such that when a derivation in certain environment is requested but not available, environments in the fallback chain are tried in order. In this example, if the chain would be given as <code class="literal">("modern", "")</code> (the empty string is the name of default environment), then we could write:</p>
<pre class="programlisting">
|: nom=, gen=a, dat=u, acc=
Isaac Newton: Isak| Njutn|
    @modern: Ajzak| Njuton|
Charles Messier: Šarl| Mesje|
</pre>
<p>When derivation of <span class="emphasis"><em>Isaac Newton</em></span> in <code class="literal">modern</code> environment is requested, the default expansion for <code class="literal">|</code> will be used, and the derivation will succeed. Derivation of <span class="emphasis"><em>Charles Messier</em></span> in <code class="literal">modern</code> environment will succeed too, because the environment fallback chain is applied throughout; if <span class="emphasis"><em>Charles Messier</em></span> had different modern transcription, we would have explicitly provided it.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsdwspace" id="sec-lgsdwspace"></a>8.6.7.&nbsp;Treatment of Whitespace</h3>
</div>
</div>
</div>
<p>ASCII whitespace in derivations, namely the space, tab and newline, is not preserved as-is, but by default it is <span class="emphasis"><em>simplified</em></span> in final property values. The simplification consists of removing all leading and trailing ASCII whitespace, and replacing all inner sequences of ASCII whitespace with a single space. Thus, these two derivations are equivalent:</p>
<pre class="programlisting">
Venus: nom=Venera
Venus  :  nom =  Venera
</pre>
<p>but these two are not:</p>
<pre class="programlisting">
Venus: Vener|a
Venus: Vener  |a
</pre>
<p>because the two spaces between the root <code class="literal">Vener</code> and expansion <code class="literal">|a</code> become inner spaces in resulting values, so they get converted into a single space.</p>
<p>Non-ASCII whitespace, on the other hand, is preserved as-is. This means that significant whitespace, like non-breaking space, zero width space, word joiners, etc. can be used normally.</p>
<p>It is possible to have different treatment of whitespace, through an optional parameter to the derivator object (<code class="classname">Synder</code> class). This parameter is a transformation function to which text segments with raw whitespace are passed, so that anything can be done with them.</p>
<p>Due to simplifaction of whitespace, indentation of key syntagmas and environment names is not significant, but it is nevertheless enforced to be consistent. This will not be accepted as valid syntax:</p>
<pre class="programlisting">
Isaac Newton: Isak| Njutn|
    @modern: Ajzak| Njuton|
 George Washington: Džordž| Vašington|  # inconsitent indent
  @modern: Džordž| Vošington|  # inconsitent indent
</pre>
<p>Consistent indenting is enforced both for stylistic reasons when several people are working on the same synder file, and to discourage indentation styles unfriendly to version control systems, such as:</p>
<pre class="programlisting">
Isaac Newton: Isak| Njutn|
     @modern: Ajzak| Njuton|
George Washington: Džordž| Vašington|
          @modern: Džordž| Vošington|  # inconsitent indent
</pre>
<p>Unfriendliness to version control comes from the need to reindent lines which are otherwise unchanged, merely in order to keep them aligned to lines which were actually changed.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsdorg" id="sec-lgsdorg"></a>8.6.8.&nbsp;Uniqueness, Ordering, and Inclusions</h3>
</div>
</div>
</div>
<p>Within single synder file, each derivation must have at least one unique key syntagma, because they are used as keys in dictionary lookups. These two derivations are in conflict:</p>
<pre class="programlisting">
Mars: Mars|  # the planet
Mars: mars|  # the chocholate bar
</pre>
<p>There are several possibilities to resolve key conflicts. The simplest possibility is to use keyword-like key syntagmas, if key syntagmas themselves do not need to be human readable:</p>
<pre class="programlisting">
marsplanet: Mars|
marsbar: mars|
</pre>
<p>If key syntagmas have to be human readable, then one option is to extend them in human readable way as well:</p>
<pre class="programlisting">
Mars (planet): Mars|
Mars (chocolate bar): mars|
</pre>
<p>This method too is not acceptable if key syntagmas are intended to be of equal weight to derived syntagmas, like in a dictionary application. In that case, the solution is to add a hidden keyword-like syntagma to both derivations:</p>
<pre class="programlisting">
Mars, |marsplanet: Mars|
Mars, |marsbar: mars|
</pre>
<p>Processing will now silently eliminate <code class="literal">Mars</code> as the key to either derivation, because it is conflicted, and leave only <code class="literal">marsplanet</code> as key for the first and <code class="literal">marsbar</code> as key for the second derivation. These remaining keys must also used in expansions, to reference the appropriate derivation. However, when querying the dictionary for key syntagmas by key <code class="literal">marsplanet</code>, only <span class="emphasis"><em>Mars</em></span> will be returned, because <code class="literal">marsplanet</code> is hidden; likewise for <code class="literal">marsbar</code>.</p>
<p>Ordering of derivations is not important. The following order is valid, although the expansion <code class="literal">|Venus~gen</code> is seen before the derivation of <span class="emphasis"><em>Venus</em></span>:</p>
<pre class="programlisting">
Merchants of Venus: Trgovc|i&gt; s |Venus~gen
Venus: Vener|a
</pre>
<p>This enables derivations to be ordered naturally, e.g. alphabetically, instead of the order being imposed by dependencies.</p>
<p>It is possible to include one synder file into another. A typical use case would be to split out base derivations into a separate file, and include it into other synder files. If basic derivations are defined in <code class="filename">base.sd</code>:</p>
<pre class="programlisting">
|: nom=, gen=a, dat=u, acc=, gender!=mas
|a: nom=a, gen=e, dat=i, acc=u, gender!=fem
…
</pre>
<p>then the file <code class="filename">solarsys.sd</code>, placed in the same directory, can include <code class="filename">base.sd</code> and use its derivations in expansions like this:</p>
<pre class="programlisting">
&gt;base.sd
Mercury: Merkur|
Venus: Vener|a
Earth: Zemlj|a
…
</pre>
<p><code class="literal">&gt;</code> is the inclusion directive, followed by the absolute or relative path to file to be included. If the path is relative, it is considered relative to the including file, and not to some externaly defined set of inclusion paths.</p>
<p>If the including and the included file contain a derivation with same key syntagmas, these two derivations are <span class="emphasis"><em>not</em></span> a conflict. On expansion, first the derivations from the current file are checked, and if the referenced derivation is not there, then the included files are checked in reverse of the inclusion order. In this way, it is possible to override some of base derivations in one or few including files.</p>
<p>Inclusions are "shallow": only the derivations in the included file itself are visible (available for use in expansions) in the including file. In other words, if file A includes file B, and file B includes file C, then derivations from C are not automatically visible in A; to use them, A must explicitly include C.</p>
<p>Shallow inclusion and ordering-independent resolution of expansions, taken together, enable mutual inclusions: A can include B, while B can include A. This is an important capability when building derivations of taxonomies. While derivation of X naturally belongs to file A and of Y to file B, X may nevertheless be used in expansion in another derivation in B, and Y in another derivation in A.</p>
<p>To make derivations from several synder files available for queries, these files are imported into the derivator object one by one. Derivations from imported files (but not from files included by them, according to shallow inclusion principle) all share a single namespace. This means that key syntagmas across imported files can conflict, and must be resolved by one of outlined methods.</p>
<p>The design rationale for the inclusion mechanism was that in each collection of derivations, each <span class="emphasis"><em>visible</em></span> derivation, one which is available to queries by the user of the collection, must be accessible by at least one unique key, which does not depend on the underlying file hierarchy.</p>
</div>
<div class="sect2">
<div class="titlepage">
<div>
<div>
<h3 class="title"><a name="sec-lgsderrors" id="sec-lgsderrors"></a>8.6.9.&nbsp;Error Handling</h3>
</div>
</div>
</div>
<p>There are three levels of errors which may happen in syntagma derivations.</p>
<p>The first level are syntax errors, such as synder entry missing a colon which separates the key syntagma from the rest of the entry, unclosed curly bracket in expansion, etc. These errors are reported as soon as the synder file is imported into the derivator object or included by another synder file.</p>
<p>The second level of errors are expansion errors, such as an expansion referencing an undefined derivation, or an expansion mask discarding all properties. These errors are reported lazily, when the problematic derivation is actually looked up for the first time.</p>
<p>The third level is occupied by semantic errors, such as if we want every derivation to have a certain property, or <code class="literal">gender</code> property to have only values <code class="literal">mas</code>, <code class="literal">fem</code>, and <code class="literal">neu</code>, etc. and a derivation violates some of these requirements. At the moment, there is no prepared way to catch semantic errors.</p>
<p>In future, a mechanism (in form of file-level directives, perhaps) may be introduced to immediately report reference errors on request, and to constrain property keys and property values to avoid semantic errors. Until then, the way to validate a collection of derivations would be to write a piece of Python code which will import all files into a derivator object, iterate through derivations (this alone will catch expansion errors) and check for semantic errors.</p>
</div>
</div>
<div class="footnotes"><br>
<hr width="100" align="left">
<div class="footnote">
<p><sup>[<a name="ftn.id443596" href="#id443596" class="para" id="ftn.id443596">21</a>]</sup> Another advantage is that original text too will sometimes contain out-of-date UI references, which this process will automatically discover and enable the translation to be more up-to-date than the original. Of course, reporting the problem to the authors would be desireable, or even necessary when the related feature no longer exists.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id500443" href="#id500443" class="para" id="ftn.id500443">22</a>]</sup> Taking into account the current level of artificial intelligence development, which, granted, may become more sophisticated in the future.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id500843" href="#id500843" class="para" id="ftn.id500843">23</a>]</sup> And cause regular expressions to become horribly complicated.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id420639" href="#id420639" class="para" id="ftn.id420639">24</a>]</sup> Why not remove accelerator markers automatically before applying rules? Because some rules might be exactly about accelerator markers, e.g. if it should not be put next to certain letters.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id433807" href="#id433807" class="para" id="ftn.id433807">25</a>]</sup> These filtering examples are only for illustrative purposes, as there are more precise methods to remove markup, or literals such as command line options.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id401924" href="#id401924" class="para" id="ftn.id401924">26</a>]</sup> Until that is sufficiently satisfied, one simple safety measure is to remove <code class="literal">skip-rule:</code> comments from fuzzy messages just after the PO file is merged with template. This will sometimes cause false positive to reappear, but, after all, this is only a tertiary element in the translation workflow (after translation and review).</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id434079" href="#id434079" class="para" id="ftn.id434079">27</a>]</sup> As of this writting, one currently operative translation scripting system is <a class="ulink" href="http://techbase.kde.org/Localization/Concepts/Transcript" target="_top">KDE's Transcript</a>. Another one being developed, albeit not with PO format as base, is <a class="ulink" href="http://wiki.mozilla.org/L20n" target="_top">Mozilla's L20n</a>.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id434106" href="#id434106" class="para" id="ftn.id434106">28</a>]</sup> An exception would be <a class="ulink" href="http://en.wikipedia.org/wiki/Constructed_language" target="_top">constructed languages</a> with regular grammar, such as Esperanto.</p>
</div>
<div class="footnote">
<p><sup>[<a name="ftn.id434122" href="#id434122" class="para" id="ftn.id434122">29</a>]</sup> A combination of words having a certain meaning, possibly greater than the sum of meanings of each word.</p>
</div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left"><a accesskey="p" href="ch-misctools.html">Prev</a>&nbsp;</td>
<td width="20%" align="center">&nbsp;</td>
<td width="40%" align="right">&nbsp;<a accesskey="n" href="ch-common.html">Next</a></td>
</tr>
<tr>
<td width="40%" align="left" valign="top">Chapter&nbsp;7.&nbsp;Miscellaneous Tools&nbsp;</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;9.&nbsp;Common Functionality</td>
</tr>
</table>
</div>
</body>
</html>
