<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="ch-combined">
<title>Combined Arms Tactics</title>

<para>While each particular PO processing tool from Pology and other packages may be documented in itself, it may not be always obvious how to use these tools together. This chapter presents some scenarios where combined tool usage may increase the quality and efficiency of daily work on translation.</para>

<!-- ======================================== -->
<sect1 id="sec-cbcompend">
<title>Creating and Using PO Compendia</title>

<para>A <emphasis>PO compendium</emphasis> is simply a PO file which aggregates messages from many other normal PO files, usually all same-language PO files in a given translation project. It may aggregate only the messages currently present in project PO files, but also messages that were present once and are no longer. As such, the compendium can be regarded as an instance of a <emphasis>translation memory</emphasis>. This section explains how to create, update, and apply such a translation memory.</para>

<sect2 id="sec-cbcomptm">
<title>Why Translation Memory?</title>

<para>Imagine that the translator wants to start translating a PO file that was so far never translated, but which has content similar to some other, translated PO files. Perhaps it was even derived from those other PO files, by merging, splitting, etc. This means that many messages in the present PO file may have been translated already in some other PO file, or at least that very similar translated messages exist in other PO files. Since the translation memory (TM) contains all known translated messages, it can be used to automatically produce translated and fuzzy messages in the present PO file, significantly reducing translation effort. Matching against the TM can be performed either as the translator goes from message to message in the editor (if the editor has a TM feature), or at once for all messages (by a specialized command) before starting to go through messages in the editor.</para>

<para>In most non-PO based translation workflows, translation memories are crucial for efficiency. This is because most non-PO formats have no concept of merging with templates. Each new revision of the source material results in (an equivalent of) entirely empty translation files, and it is translator's duty to somehow bring old translations into the new context. A carefully maintained TM, with a corresponding matching tool, is the foremost way to do this.</para>

<para>In a PO-based translation workflow, merging with templates already provides most of what TM is essential for. In effect, the old PO file that is being merged can be considered as a TM for the new PO file that will become based on the new template. Even when PO files are renamed, merged, or split, if that is properly done, no translations will be lost. A TM for PO files is therefore useful mostly to smooth out glitches in translation maintenance procedures (e.g. a PO file improperly split).<footnote>
<para>To be sure, some short messages can be quite similar in many unrelated PO files. But having TM matches only on such messages will result in very small time savings, if measurable at all.</para>
</footnote> Nevertheless, having a well maintained TM in the form of PO compendium cannot hurt, while providing for the (hopefully) rare situations where TM matching is actually needed.</para>

<para>Many dedicated PO editors will automatically maintain an internal TM, usually in a database format, into which they will scoop messages from all PO files that were opened in them. However, in a team environment, these internal TMs are inferior to a PO compendium. For one, different translators will have different TMs; a translator may start to work on a file for which there are TM matches in another translator's internal TM. Internal TMs may be volatile, for example corrupted due to an editor bug, or perish during system maintainence. There is no control over which messages are scooped by the editor, and how they are treated (e.g. which message parts are being ignored).</para>

<para>On the other hand, a PO compendium can be maintained in a central place, and, being a PO file in itself, kept in version control just like all other PO files. In this way, all translators have fast access to a unified TM, which is secured from accidental corruption. Tight control over which messages are collected and how they are collected may be asserted, in the script which is written to update the compendium. This script can be made to run periodically, and to automatically commit updated compendium the version control repository.</para>

</sect2>

<sect2 id="sec-cmcompcr">
<title>Maintaining a Centralized PO Compendium</title>

<para>As a first attempt, the PO compendium can be created simply by concatenting all PO files in the project into one called <filename>compendium.po</filename>, using <command>msgcat</command>. If PO files are organized by language (all PO files of a given language kept in directory of that language), then the concatenation command would be:
<programlisting>
$ cd $LANGDIR
$ find -iname \*.po | xargs msgcat -o compendium.po
</programlisting>
Unfortunatelly, a compendium created in this way has a number of drawbacks:
<itemizedlist>

<listitem>
<para>Aside from translated messages, the compendium will also contain untranslated and fuzzy messages. While untranslated messages are obviously dead weight, a case could be made for taking in fuzzy messages. But in light of the suggested usage of the compendium in the following section, fuzzy messages too should be ignored.</para>
</listitem>

<listitem>
<para>Messages in the compendium will contain all parts as normal messages do. Some of these parts (such as source references) are unnecessary, since they will be ignored when applying the compendium later. Other than increasing the size of the compendium, another problem with these parts is that changes in them will cause unnecessary version control differences, so they should be stripped from the compendium.</para>
</listitem>

<listitem>
<para>Messages will be ordered as they are seen in concatenated PO files. The ordering of messages in the compendium is also of no importance for application. But, any changes in message ordering between two compendium updates will cause unnecessary version control differences, so it is best to sort messages by their keys (<varname>msgid</varname> and <varname>msgctxt</varname> fields).</para>
</listitem>

<listitem>
<para>When two or more PO files contain the same message by key (<varname>msgid</varname> and <varname>msgctxt</varname>) but with different translations (due to context), such as:
<programlisting>
msgid "Open File"
msgstr "Otvori datoteku"

msgid "Open File"
msgstr "Otvaranje datoteke"
</programlisting>
<command>msgcat</command> will <emphasis>aggregate</emphasis> translations (and translator comments if any) in the compendium message, and make it fuzzy:
<programlisting>
#, fuzzy
msgid "Open File"
msgstr ""
"#-#-#-#-#  alpha.po (alpha-1.2.9)  #-#-#-#-#\n"
"Otvori datoteku\n"
"#-#-#-#-#  bravo.po (bravo-0.8.12)  #-#-#-#-#\n"
"Otvaranje datoteke"
</programlisting>
Since the context should be double-checked anyway when applying the compendium later (especially for short messages), it is better to instead pick one of the translations and have a normal translated compendium message. If each translation appears only once, then it does not matter which is picked; but if one translation appears 10 times and the other once, clearly the former should be picked. That is, the most frequent translation should be picked.</para>
</listitem>

<listitem>
<para>The PO header is treated in the same way as messages by <command>msgcat</command>: since all headers have equal <varname>msgid</varname> field (empty), their <varname>msgstr</varname> fields will be aggregated. This too is just dead weight since the header is not used in applications of the compendium. Instead, a brief and informative header should be explicitly set (mentioning that this is a compendium PO file, for which project and language, etc).</para>
</listitem>

<listitem>
<para>In some translation projects, PO files frequently contain <emphasis>meta-messages</emphasis>, such as those where translators can add their names and contact addresses. These messages have the same key (<varname>msgid</varname>) in all PO files, but should be translated differently in general, the more so the more the people in the translation team. So it may be better to omit such messages from the compendium.</para>
</listitem>

</itemizedlist>
It must be noted that none of these problems are an actual deficiency of <command>msgcat</command> itself. Since its function is general concatenation of PO files, it cannot make any of the assumptions necessary for the present application. Instead, <command>msgcat</command> should be used as a part of a wider script, in which the necessary additional processing happens, tailored to the particular translation project and translation team.</para>

<para>Let us assume the following layout of the top directory for the translation project <literal>foo</literal> and translation team (language) <literal>nn</literal>:
<programlisting>
foo-nn/
    ui/
        alpha.po
        bravo.po
        ...
    doc/
        alpha.po
        bravo.po
        ...
    update-compendium-foo-nn.sh
    compendium-foo-nn.po
</programlisting>
<filename>update-compendium-foo-nn.sh</filename> will be the script to create or update the compendium, <filename>compendium-foo-nn.po</filename> the compendium itself. It helps clarity to add the project name and language into names of these two files, because both are tailored to that project and that language. Taking into account the aforementioned drawbacks of a simple compendium made by <command>msgcat</command> and the suggested resolutions, <filename>update-compendium-foo-nn.sh</filename> could look like this<footnote>
<para>At one point, the script creates a temporary PO file for each original PO file, and then calls <command>msgcat</command> on these temporary files to create the first, raw compendium. These temporary files have fuzzy and untranslated messages removed, and some other adjustments, before concatenation. One could think that all these adjustments could instead be done on the raw compendium. The problem is that then there would be no unambiguous way to tell which fuzzy messages in the raw compendium were fuzzy to begin with, and which were made fuzzy by <command>msgcat</command> due to agreggation of translations. With fuzzy messages removed prior to concatenation, in de-aggregation by frequency that follows it is known that messages with fuzzy flags are those aggregated.</para>
</footnote>:
<programlisting>
#!/bin/sh
#
# Create the PO compendium of Foo in Nevernissian language.
#
# Usage:
#   update-compendium-foo-nn.sh [trim]
#
# The script can be called from anywhere, because PO paths are
# hardcoded within the script relative to its own location.
# If the 'trim' argument is not given (i.e. script is called
# without arguments), messages in the old compendium that are
# no longer found in project PO files are preserved in
# the new compendium; if 'trim' is given, they are removed.

# Directory where this script resides.
cmddir=`dirname $0`
# Paths of directories containing PO files, space-separated.
# (Make sure the compendium itself is not in here!)
podirs="$cmddir/ui $cmddir/doc"
# Path to the compendium.
comppo="$cmddir/compendium-foo-nn.po"

trim=$1

# If there is already a compendium, preserve it for later.
test -f $comppo &amp;&amp; mv $comppo $comppo.old

# Collect PO files from given paths into a file.
find $podirs -iname \*.po | sort > polist

# Pre-process PO files in the project, creating temporary
# PO files named *.po.tmpcomp:
# - remove fuzzy and untranslated messages
# - declare obsolete messages non-obsolete
# - remove extracted comments, source references, flags
for pofile in `cat polist`; do
    msgattrib $pofile \
        --translated --no-fuzzy --clear-obsolete --force-po \
    | grep -v '^#[:.,]' > $pofile.tmpcomp
done
# Update file list to contain temporary PO files.
sed -i "s/$/.tmpcomp/" polist

# Reduce headers of temporary PO files to necessary minimum,
# proper header for the compendium will be added later.
posieve -q set-header -f polist \
    -srmallcomm \
    -sremoverx:'^(?!MIME-Version$|Content-Type$|Content-Transfer-Encoding$)'

# Create raw compendium from temporary PO files:
# - aggregate translations for repeated messages
# - sort messages by key
msgcat --sort-output --force-po -f polist -o $comppo

# Clean up temporary PO files and file list.
cat polist | xargs rm
rm polist

# Resolve aggregated messages to most frequent variant.
# It is safe to unfuzzy resolved messages, since at
# this point assured that only translated messages
# have been aggregated.
posieve -q resolve-aggregates $comppo -sunfuzzy

# Remove meta-messages which are found in many PO files but
# should in general be differently translated in each.
msggrep -v $comppo -o $comppo \
    -JFe 'NAME OF TRANSLATORS' \
    -JFe 'EMAIL OF TRANSLATORS' \
    -JFe 'ROLES_OF_TRANSLATORS' \
    -JFe 'CREDIT_FOR_TRANSLATORS' \

# Set the compendium header.
# Use current date as revision date.
dtnow=`date '+%Y-%m-%d %H:%M%z'`
posieve -q set-header $comppo -screate \
    -stitle:'Compendium of Foo translation into Nevernissian.' \
    -sfield:'Project-Id-Version:compendium-foo-nn' \
    -sfield:"PO-Revision-Date:$dtnow" \
    -sfield:'Last-Translator:Simulacrum' \
    -sfield:'Language-Team:Nevernissian &lt;l10n-nn@neverwhere.org&gt;' \
    -sfield:'Language:nn' \
    -sfield:'Plural-Forms:nplurals=9; plural=n==1 ? ...' \

# If the old compendium was preserved, add it to the new compendium
# in order to retain messages no longer found in the project
# (unless trimming was requested).
if test -f $comppo.old &amp;&amp; test x"$trim" != xtrim; then
    msgcat --use-first --sort-output $comppo $comppo.old -o $comppo
    # ...old compendium must be the second argument, in order
    # not to override possibly updated translations of
    # existing messages in the project.
fi

# Test if new compendium is different from the old, with
# the exception  of creation time. If they are the same,
# discard the new compendium.
if test -f $comppo.old; then
    for cpfile in $comppo $comppo.old; do
        grep -v '^"PO-Revision-Date:.*\\n"$' $cpfile >$cpfile.nrd
    done
    if cmp -s $comppo.nrd $comppo.old.nrd; then
        mv $comppo.old $comppo
    else
        rm $comppo.old
    fi
    rm $comppo.nrd $comppo.old.nrd
fi

# Canonically wrap the compendium.
msgcat $comppo -o $comppo

# All done.
</programlisting>
This script should be periodically called to update the compendium, and the updated file committed, such that all translators will automatically get it when they update their local repository copies. If after some (long) time the compendium becomes to big due to accumulation of old messages, running the script once with the <literal>trim</literal> argument will cause all old messages to be dropped.</para>

</sect2>

<sect2 id="sec-cmcompuse">
<title>Applying the PO Compendium</title>

<para>With a centralized PO compendium in place, </para>

<para>Translators who use a dedicated PO editor with internal TM should configure the editor to read the compendium into the internal TM. This may be done, for example, by including the compendium PO file (or the directory in which it resides) into editor's translation project paths. If the compendium is kept under version control, the editor should automatically update its internal TM from the compendium whenever the repository is updated and the editor started again. In this way, editor's internal TM becomes transient in nature, there being no problem if it gets corrupted or deleted.</para>

<para>When working on a particular PO file with a properly configured PO editor, as the translator jumps from one to another incomplete (untranslated or fuzzy) message, when the message is similar to one or few messages in the compendium (i.e. in internal TM) the editor will somehow "offer" those similar messages. Ideally, for each similar message the editor should show not only the possible translation, but also the difference between the two original texts (that of the current message and the TM match). This will allow the translator to quickly see how the offered translation should be adapted to fit the current original.</para>

<para>Dedicated PO editors may also offer <emphasis>batch</emphasis> application of the TM. This means that when the PO file is opened, the translator executes a command which fills in all untranslated messages with matches from the TM, making some translated (on exact matches) and some fuzzy (partial matches). However, simpleminded <emphasis>batch application of the TM should be considered dangerous</emphasis>. For one, exact matches in the source language may not be exact matches in the original; especially short messages frequently need different translations. But the translator will simply jump over each batch-translated message and fail to see this. The other problem comes up if the material in the compendium is not sufficiently reviewed, in which case every match from the TM, even on long messages, should be at least casually reviewed by the translator. Thus, if there is no way to configure batch application to be less indiscriminate, it is best to avoid it alltogether, or else the quality of translation may suffer.</para>

<para>Translators who use a general text editor to work on PO files can still make use of the compendium. One option could be merging the PO file with its template in presence of the compendium, just before starting to work on it:
<programlisting>
$ msgmerge alpha.po alpha.pot -C compendium.po --update --previous
</programlisting>
The <option>-C</option> option to <command>msgmerge</command> specifies the compendium from which to draw exact and partial matches, when there is no match in the PO file itself. This option can be repeated to add several compendia. The <option>--update</option> option is to modify the PO file in place, rather than writing the merged PO file to standard output. The <option>--previous</option> option is to get previous fields (<literal>#| ...</literal> comments) on fuzzy messages. Unfortunatelly, this method is a command line version of the batch application of the TM in a dedicated PO editor, and suffers from the same problem of indiscriminate exact matches that the translator will later fail to check. Therefore it should not be used (at least not for general translation).</para> 

<para>Fortunatelly, Pology provides the <command>poselfmerge</command> command, which is a wrapper around <command>msgmerge</command>, and has several options to mitigate the indiscriminancy problem of batch application of TM. To avoid silent exact matches on short messages, the <option>-W</option>/<option>--min-words-exact</option> can be used to set the minimum length of a message in words at which the exact match will be accepted; otherwise the message is made fuzzy. If every exact match should be checked by the translator, no matter the length of the message, there is the <option>-x</option>/<option>--fuzzy-exact</option> to make all exact matches fuzzy.<footnote>
<para>The translator can still see when the match was exact, because normal fuzzy messages will have previous fields and fuzzied exact matches will not.</para>
</footnote> These options have counterpart fields in Pology user configuration, so that the translator does not have to remember to use them on every run, and the PO template is not used at all. See <xref linkend="sec-miselfmerge"/> for details.</para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-cbeffedit">
<title>Efficiently Translating with a Text Editor</title>

<para></para>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-cbsumasc">
<title>Summit and Ascription</title>

<para></para>

</sect1>

</chapter>
