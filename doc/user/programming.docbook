<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"
[
    <!ENTITY apibase "../../api/en_US">
    <!ENTITY ap "&apibase;/pology.">
    <!ENTITY amm "-module.html">
    <!ENTITY am "&amm;#">
    <!ENTITY acc "-class.html">
    <!ENTITY ac "&acc;#">
]>

<chapter id="ch-prog">
<title>Programming with Pology</title>

<para></para>

<!-- ======================================== -->
<sect1 id="sec-prfile">
<title>PO File Abstraction</title>

<para></para>

<sect2 id="sec-prflmon">
<title>Monitored Objects</title>

<para></para>

</sect2>

<sect2 id="sec-prflmsg">
<title>Message</title>

<para></para>

</sect2>

<sect2 id="sec-prflcat">
<title>Catalog</title>

<para></para>

</sect2>

<sect2 id="sec-prflhead">
<title>Header</title>

<para></para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-prsieves">
<title>Writing Sieves</title>

<para><link linkend="ch-sieve">Pology sieves</link> are filtering-like processing elements applied by the <command>posieve</command> script to collections of PO files. A sieve can examine as well as modify the PO entries passed through it. Each sieve is written in a separate file. If the sieve file is put into <filename>sieve/</filename> directory of Pology distribution (or intallation), the sieve can be referenced on <command>posieve</command> command line by the shorthand notation; otherwise the path to the sieve file is given. The former is called an internal sieve, and the latter an external sieve, but the sieve file layout and the sieve definition are same for both cases.</para>

<para>In the following, <command>posieve</command> will be referred to as "the client". This is because tools other than <command>posieve</command> may start to use sieves in the future, and it will also be described what these clients should adhere to when using sieves.</para>

<sect2 id="sec-prsvlayout">
<title>Sieve Layout</title>

<para>The sieve file must define the <classname>Sieve</classname> class, with some mandatory and some optional interface methods and instance variables. There are no restrictions at what you can put into the sieve file beside this class, only keep in mind that <command>posieve</command> will load the sieve file as a Python module, exactly once during a single run.</para>

<para>Here is a simple sieve (also the complete sieve file) which just counts the number of translated messages:
<programlisting>
class Sieve (object):

    def __init__ (self, params):

        self.ntranslated = 0

    def process (self, msg, cat):

        if msg.translated:
            self.ntranslated += 1

    def finalize (self):

        report("Total translated: %d" % self.ntranslated)
</programlisting>
The constructor takes as argument an object specifying any sieve parameters (more on that soon). The <methodname>process</methodname> method gets called for each message in each PO file processed by the client, and must take as parameters the message (instance of <ulink url="&ap;message.Message_base&acc;"><classname>Message_base</classname></ulink>) and the catalog which contains it (<ulink url="&ap;catalog.Catalog&acc;"><classname>Catalog</classname></ulink>). The client calls the <methodname>finalize</methodname> method after no more messages will be fed to the sieve, but this method does need to be defined (client should check if it exists before placing the call).</para>

<para>Another optional method is <methodname>process_header</methodname>, which the client calls on the PO header:
<programlisting>
def process_header (self, hdr, cat):
    # ...
</programlisting>
<literal>hdr</literal> is an instance of <ulink url="&ap;header.Header&acc;"><classname>Header</classname></ulink>, and <literal>cat</literal> is the containing catalog. The client will check for the presence of this method, and if it is defined, it will call it prior to any <methodname>process</methodname> call on the messages from the given catalog. In other words, the client is not allowed to switch catalogs between two calls to <methodname>process</methodname> without calling <methodname>process_header</methodname> in between.</para>

<para>There is also the optional <methodname>process_header_last</methodname> method, for which everything holds just like for <methodname>process_header</methodname>, except that, when present, the client must call it <emphasis>after</emphasis> all consecutive <methodname>process</methodname> calls on messages from the same catalog:
<programlisting>
def process_header_last (self, hdr, cat):
    # ...
</programlisting>
</para>

<para>Sieve methods should not abort program execution in case of errors, instead they should throw an exception. In particular, if the <methodname>process</methodname> method throws <ulink url="&ap;sieve.SieveMessageError&acc;"><classname>SieveMessageError</classname></ulink>, it means that the sieve can still process other messages in the same catalog; if it throws <ulink url="&ap;sieve.SieveCatalogError&acc;"><classname>SieveCatalogError</classname></ulink>, then any following messages from the same catalog must be skipped, but other catalogs may be processed. Similarly, if <methodname>process_header</methodname> throws <classname>SieveCatalogError</classname>, other catalogs may still be processed. Any other type of exception tells the client that the sieve should no longer be used.</para>

<para>The <methodname>process</methodname> and <methodname>process_header</methodname> methods should either return <literal>None</literal> or an integer exit code. A return value which is neither <literal>None</literal> nor <literal>0</literal> indicates that while the evaluation was successfull (no exception was thrown), the processed entry (message or header) should not be passed further along the <link linkend="sec-svchains">sieve chain</link>.</para>

</sect2>

<sect2 id="sec-prsvparams">
<title>Sieve Parameter Handling</title>

<para>The <literal>params</literal> parameter of the sieve constructor is an object with data attributes as <link linkend="p-svparam">parameters which may influence</link> the sieve operation. The sieve file can define the <function>setup_sieve</function> function, which the client will call with
a <ulink url="&ap;subcmd.SubcmdView&acc;"><classname>SubcmdView</classname></ulink> object as the single argument, to fill in the sieve description and define all mandatory and optional parameters. For example, if the sieve takes an optional parameter named <literal>checklevel</literal>, which controles the level (an integer) at which to perform some checks, here is how <function>setup_sieve</function> could look like:
<programlisting>
def setup_sieve (p):

    p.set_desc("An example sieve.")
    p.add_param("checklevel", int, defval=0,
                desc="Validity checking level.")


class Sieve (object):

    def __init__ (self, params):

        if params.checklevel >= 1:
            # ...setup some level 1 validity checks...
        if params.checklevel >= 2:
            # ...setup some level 2 validity checks...
        #...

    ...
</programlisting>
See the <ulink url="&ap;subcmd.SubcmdView&ac;add_param"><methodname>add_param</methodname></ulink> method for details on defining sieve parameters.</para>

<para>The client is not obliged to call <function>setup_sieve</function>, but it must make sure that the object it sends to the sieve as <literal>params</literal> has all the instance variable according to the defined parameters.</para>

</sect2>

<sect2 id="sec-prsvregime">
<title>Catalog Regime Indicators</title>

<para>There are two boolean instance variables that the sieve may define, and
which the client may check for to decide on the regime in which the
catalogs are opened and closed:
<programlisting>
class Sieve (object):

    def __init__ (self, params):

        # These are the defaults:
        self.caller_sync = True
        self.caller_monitored = True

    ...
</programlisting>
The variables are:
<itemizedlist>

<listitem>
<para><varname>caller_sync</varname> instructs the client whether catalogs processed by the sieve should be synced to disk at the end. If the sieve does not define this variable, the client should assume <literal>True</literal> and sync catalogs. This variable is typically set to <literal>False</literal> in sieves which do not modify anything, because syncing catalogs takes time.</para>
</listitem>

<listitem>
<para><varname>caller_monitored</varname> tells the client whether it should open catalogs in monitored mode. If this variable is not set, the client should assume it <literal>True</literal>. This is another way of reducing processing time for sieves which do not modify PO entries.</para>
</listitem>

</itemizedlist>
</para>

<para>Usually a modifying sieve will set neither of these variables, i.e. catalogs will be monitored and synced by default, while a checker sieve will set both to <literal>False</literal>. For a modifying sieve that unconditionally modifies all entries sent to it, only <varname>caller_monitored</varname> may be set to <literal>False</literal> and <varname>caller_sync</varname> left undefined (i.e. <literal>True</literal>).</para>

<para>If a sieve requests no monitoring or no syncing, the client is not obliged to satisfy these requests. On the other hand, if a sieve does request monitoring or syncing (either explicitly or by not defining the corresponding variables), the client must provide catalogs in that regime. This is because there may be several sieves operating at the same time (a sieve chain), and monitoring and syncing is usually necessary for proper operation of those sieves that request it.</para>

</sect2>

<sect2 id="sec-prsvnotes">
<title>Further Notes on Sieves</title>

<para>Since monitored catalogs have modification counters, the sieve may use them within its <methodname>process*</methodname> methods to find out if any modification really took place. The proper way to do this is to record the counter at start, and check for increase at end:
<programlisting>
def process (self, msg, cat):

    startcount = msg.modcount

    # ...
    # ... do some stuff
    # ...

    if msg.modcount > startcount:
        self.nmodified += 1
</programlisting>
The <emphasis>wrong</emphasis> way to do it would be to merely check if <literal>msg.modcount > 0</literal>, because several modifying sieves may be operating at the same time, each increasing the counters.</para>

<para>If the sieve wants to remove the message from the catalog, if at all possible it should use catalog's <methodname>remove_on_sync</methodname> instead of <methodname>remove</methodname> method, to defer actual removal to sync time. This is because <methodname>remove</methodname> will probably ruin client's iteration over the catalog, so if it must be used, the sieve documentation should state it clearly. <methodname>remove</methodname> also has linear execution time, while <methodname>remove_on_sync</methodname> has constant.</para>

<para>If the sieve is to become part of Pology distribution, it should be properly documented. This means fully equipped <function>setup_sieve</function> function in the sieve file, and a piece of user manual documentation.
The <classname>Sieve</classname> class itself should not be documented in general. Only when <methodname>process*</methodname> are returning an exit code, this should be stated in their own comments (and in the user manual).</para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-prhooks">
<title>Writing Hooks</title>

<para>Hooks are functions with specified sets of input parameters, return values, processing intent, and behavioral constraints. They can be used as modification and validation plugins in many processing contexts in Pology. There are three broad categories of hooks: filtering, validation and side-effect hooks.</para>

<para>Filtering hooks modify some of their inputs. Modifications are done in-place whenever the input is mutable (like a PO message), otherwise the modified input is provided in a return value (like a PO message text field).</para>

<para>Validation hooks perform certain checks on their inputs, and return a list of <emphasis>annotated spans</emphasis> or <emphasis>annotated parts</emphasis>, which record all the encountered errors:
<itemizedlist>

<listitem>
<para id="p-annspans">Annotated spans are reported when the object of validation is a piece of text. Each span is a tuple of start and end index of the problematic segment in the text, and a note which explains the problem. The return value of a text-validation hook will thus be a list:
<programlisting>
[(start1, end1, "note1"), (start2, end2, "note1"), ...]
</programlisting>
The note can also be <literal>None</literal>, if there is nothing to say about the problem.</para>
</listitem>

<listitem>
<para id="p-annparts">Annotated parts are reported for an object which has more than one distinct piece of text, such as a PO message. Each annotated part is a tuple stating the name of the problematic part of the object (e.g. <literal>"msgid"</literal>, <literal>"msgstr"</literal>), the item index for array-like parts (e.g. for <literal>msgstr</literal>), and the list of problems in appropriate form (for a PO message this is a list of annotated spans).
The return value of a PO message-validation hook will look like this:
<programlisting>
[("part1", item1, [(start11, end11, "note11"), ...]),
 ("part2", item2, [(start21, end21, "note21"), ...]),
 ...]
</programlisting>
</para>
</listitem>

</itemizedlist>
</para>

<para>Side-effect hooks neither modify their inputs nor report validation information, but can be used for whatever purpose which is independent of the processing chain into which the hook is inserted. For example, a validation hook can be implemented like this as well, when it is enough that it reports problems to standard output, or where the hook client does not know how to use structured validation data (annotated spans or parts). The return value of a side-effect hook the number of errors encountered internally by the hook (an integer). Clients may use this number to decide upon further behavior. For example, if a side-effect hook modified a temporary copy of a file, the client may decide to abandon the result and use the original file if there were some errors.</para>

<sect2 id="sec-prhktypes">
<title>Hook Taxonomy</title>

<para>In this section a number of hook types are described and assigned a formal
type keyword, so that they can be conveniently referred to elsewhere in Pology documentation.</para>

<para>Each type keyword has the form <emphasis>&lt;letter1&gt;&lt;number&gt;&lt;letter2&gt;</emphasis>, e.g. F1A. The first letter represents the hook category: <emphasis>F</emphasis> for filtering hooks, <emphasis>V</emphasis> for validation hooks, and <emphasis>S</emphasis> for side-effect hooks. The number enumerates the input signature by parameter types, and the final letter denotes the difference in semantics of input parameters for equal input signatures. As a handy mnemonic, each type is also given an informal signature in the form of <literal>(param1, param2, ...) -> result</literal>; in them, <literal>spans</literal> stand for <link linkend="p-annspans">annotated spans</link>, <literal>parts</literal> for <link linkend="p-annparts">annotated parts</link>, and <literal>numerr</literal> for number of errors.</para>

<para>Hooks on pure text:
<itemizedlist>
<listitem>
<para>F1A (<literal>(text) -> text</literal>): filters the text</para>
</listitem>
<listitem>
<para>V1A (<literal>(text) -> spans</literal>): validates the text</para>
</listitem>
<listitem>
<para>S1A (<literal>(text) -> numerr</literal>): side-effects on text</para>
</listitem>
</itemizedlist>
</para>

<para>Hooks on text fields in a PO message in a catalog:
<itemizedlist>
<listitem>
<para>F3A (<literal>(text, msg, cat) -> text</literal>): filters any text field</para>
</listitem>
<listitem>
<para>V3A (<literal>(text, msg, cat) -> spans</literal>): validates any text field</para>
</listitem>
<listitem>
<para>S3A (<literal>(text, msg, cat) -> numerr</literal>): side-effects on any text field</para>
</listitem>
<listitem>
<para>F3B (<literal>(msgid, msg, cat) -> msgid</literal>): filters an original text field; original fields are either <literal>msgid</literal> or <literal>msgid_plural</literal></para>
</listitem>
<listitem>
<para>V3B (<literal>(msgid, msg, cat) -> spans</literal>): validates an original text field</para>
</listitem>
<listitem>
<para>S3B (<literal>(msgid, msg, cat) -> numerr</literal>): side-effects on an original text field</para>
</listitem>
<listitem>
<para>F3C (<literal>(msgstr, msg, cat) -> msgstr</literal>): filters a translation text field; translation fields are the <literal>msgstr</literal> array</para>
</listitem>
<listitem>
<para>V3C (<literal>(msgstr, msg, cat) -> spans</literal>): validates a translation text field</para>
</listitem>
<listitem>
<para>S3C (<literal>(msgstr, msg, cat) -> numerr</literal>): side-effects on a translation text field</para>
</listitem>
</itemizedlist>
</para>

<para>*3B and *3C hook series are introduced next to *3A for cases when it does not make sense for text field to be any other but one of the original, or translation fields. For example, to process the translation sometimes the original (obtained by <literal>msg</literal> parameter) must be consulted. If a *3B or *3C hook is applied on an inappropriate text field, the results are undefined.</para>

<para>Hooks on PO entries in a catalog:
<itemizedlist>
<listitem>
<para><literal>F4A</literal> (<literal>(msg, cat) -> numerr</literal>): filters a message, modifying it</para>
</listitem>
<listitem>
<para><literal>V4A</literal> (<literal>(msg, cat) -> parts</literal>): validates a message</para>
</listitem>
<listitem>
<para><literal>S4A</literal> (<literal>(msg, cat) -> numerr</literal>): side-effects on a message (no modification)</para>
</listitem>
<listitem>
<para><literal>F4B</literal> (<literal>(hdr, cat) -> numerr</literal>): filters a header, modifying it</para>
</listitem>
<listitem>
<para><literal>V4B</literal> (<literal>(hdr, cat) -> parts</literal>): validates a header</para>
</listitem>
<listitem>
<para><literal>S4B</literal> (<literal>(hdr, cat) -> numerr</literal>): side-effects on a header (no modification)</para>
</listitem>
</itemizedlist>
</para>

<para>Hooks on PO catalogs:
<itemizedlist>
<listitem>
<para><literal>F5A</literal> (<literal>(cat) -> numerr</literal>): filters a catalog, modifying it in any way</para>
</listitem>
<listitem>
<para><literal>S5A</literal> (<literal>(cat) -> numerr</literal>): side-effects on a catalog (no modification)</para>
</listitem>
</itemizedlist>
</para>

<para>Hooks on file paths:
<itemizedlist>
<listitem>
<para><literal>F6A</literal> (<literal>(filepath) -> numerr</literal>): filters a file, modifying it in any way</para>
</listitem>
<listitem>
<para><literal>S6A</literal> (<literal>(filepath) -> numerr</literal>): side-effects on a file, no modification</para>
</listitem>
</itemizedlist>
</para>

<para>The *2* hook series (with signatures <literal>(text, msg) -> ...</literal>) has been skipped because no need for them was observed so far next to *3* hooks.</para>

</sect2>

<sect2 id="sec-prhkfact">
<title>Hook Factories</title>

<para>Since hooks have fixed input signatures by type, the way to customize
a given hook behavior is to produce its function by another function.
The hook-producing function is called a I{hook factory}. It works by
preparing anything needed for the hook, and then defining the hook proper
and returning it, thereby creating a lexical closure around it:
<programlisting>
def hook_factory (param1, param2, ...):

    # Use param1, param2, ... to setup hook definition.

    def hook (...):

        # Perhaps use param1, param2, ... in the hook definition too.

    return hook
</programlisting>
</para>

<para>In fact, most internal Pology hooks are defined by factories.</para>

</sect2>

<sect2 id="sec-prhknotes">
<title>Further Notes on Hooks</title>

<para>General hooks should be defined in top level modules, language-dependent hooks in <literal>lang.<replaceable>code</replaceable>.<replaceable>module</replaceable></literal>,
project-dependent hooks in <literal>proj.<replaceable>name</replaceable>.<replaceable>module</replaceable></literal>,
and hooks that are both language- and project-dependent in <literal>lang.<replaceable>code</replaceable>.proj.<replaceable>name</replaceable>.<replaceable>module</replaceable></literal>. Hooks placed like this can be fetched by <ulink url="&ap;getfunc&am;get_hook_ireq"><function>getfunc.get_hook_ireq</function></ulink> in various non-code contexts, in particular from Pology utilities which allow users to insert hooks into processing through command line options or configurations. If the complete module is dedicated to a single hook, the hook function (or factory) should be named same as the module, so that users can select it by giving only the hook module name.</para>

<para><link linkend="p-annparts">Annotated parts</link> for PO messages returned by hooks are a reduced but valid instance of highlight specifications used by reporting functions, e.g. <ulink url="&ap;msgreport&am;report_msg_content"><function>msgreport.report_msg_content</function></ulink>. Annotated parts do not have the optional fourth element of a tuple in highlight specification, which is used to provide the filtered text against which spans were constructed, instead of the original text. If a validation hook constructs the list of problematic spans against the filtered text, just before returning it can apply <ulink url="&ap;diff&am;adapt_spans"><function>diff.adapt_spans</function></ulink>
to reconstruct the spans against the original text.</para>

<para>The documentation to a hook function should state the hook type within the short description, in square brackets at the end as <literal>[type ... hook]</literal>. Input parameters should be named like in the informal signatures in the taxonomy above, and should not be omitted in <literal>@param:</literal> Epydoc entries; but the return should be given under <literal>@return:</literal>, also using one of the listed return names, in order to complete the hook signature.</para>

<para>The documentation to a hook factory should have <literal>[hook factory]</literal> at the end of the short description. It should normally list all the input parameters, while the return value should be given as <literal>@return: type ... hook</literal>, and
the hook signature as the <literal>@rtype:</literal> Epydoc field.</para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-prascsel">
<title>Writing Ascription Selectors</title>

<para></para>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-prcstyle">
<title>Coding Style</title>

<para></para>

<!-- reporting, exceptions -->

<sect2 id="sec-prcsi18n">
<title>User-Visible Text and Internationalization</title>

<para></para>

<!-- named format directives, well-formed XML, color markup, proper sentences, every message with context -->

</sect2>

</sect1>

</chapter>
