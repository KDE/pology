<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="ch-lingo">
<title>Language Validation and Derivation</title>

<para>Pology was designed with strong language-specific support in mind, and this chapter describes the currently available features in the direction of validation and derivation of translation as whole and various bits in it.</para>

<!-- ======================================== -->
<sect1 id="sec-lglangenv">
<title>The Notion of Language in Pology</title>

<para>A versatile translation-supporting tool has to have some language-specific functionality. But, it is difficult to agree on what is a language and what is a dialect, what is standard and what is jargon, what is derived from what, how any of these are named, and there are many witty remarks about existing classifications. Therefore, Pology takes a rather simple and non-formal approach to the definition of "language", but such that should provide good technical leverage for constructing language-specific functionality.</para>

<para>There are two levels of language-specificity in Pology.</para>

<para>The first level is simply the "language". In linguistic sense this can be a language proper (whatever that means), a dialect, a variant written in different script, etc. Each language in this sense is assigned a code in Pology, when first elements of support for that language are introduced. By convention this code should be an <ulink url="http://en.wikipedia.org/wiki/ISO_639">ISO 639</ulink> code (either two- or three-digit) if applicable, but in principle can be anything. Another convenient source of language codes is the GNU C library. For example, Portugese language spoken in Portugal would have the code <literal>pt</literal> (ISO 639) while Portugese spoken in Brazil would be <literal>pt_BR</literal> (GNU C library).</para>

<para>The second level of language-specificity is the "environment". In linguistic terms this could be whatever distinct but minor variations in vocabulary, style, tone, or ortography, which are specific to certain groups of people within a single language community. Within Pology, this level is used to support variations between specific translation environments, such as long-standing translation projects and their teams. Although translating into the same language, translation teams will almost inevitably have some differences in terminology, style guidelines, etc. Environments also have codes assigned.</para>

<para>In every application in Pology, the language and its environments have a hierarchical relation. In general, language-specific elements defined outside of a specific environment ("environment-agnostic" elements) are a sort of a relaxed least common denominator, and specific environments add their own elements to that. Relaxed means that environment-agnostic elements can sometimes include that which holds for most but not all environments, while each environment can override what it needs to. This prevents the environment-agnostic language support from getting too limited just to cater for perculiarities in certain environments.</para>

<para>When processing PO files, it is necessary to somehow convey to Pology tools to which language and environment the PO files belong. The most effective way of doing this is by adding the necessary information to PO headers. All Pology tools that deal with language-specific elements will check the header of the PO file they process for the language and environment. Some Pology tools will also consult the user configuration (typically with lower priority than PO headers) or provide appropriate command line options (typically giving them higher priority). See <xref linkend="sec-cmheader"/> and <xref linkend="sec-cmconfig"/> for details.</para>

<sect2>
<title>Supported Languages and Environments</title>

<para>The following languages and environments within those languages currently have some level of support in Pology (assigned code in parenthesis, "t.t." stands for translation team):

<informaltable>
<tgroup cols="2">
<colspec colwidth="30%"/>
<colspec colwidth="70%"/>
<thead>
<row>
<entry>Language</entry>
<entry>Environments</entry>
</row>
</thead>
<tbody>

<row>
<entry>Catalan (<literal>ca</literal>)</entry>
</row>

<row>
<entry>French (<literal>fr</literal>)</entry>
</row>

<row>
<entry>Galician (<literal>gl</literal>)</entry>
</row>

<row>
<entry>Japanese (<literal>ja</literal>)</entry>
</row>

<row>
<entry>Low Saxon (<literal>nds</literal>)</entry>
</row>

<row>
<entry>Norwegian Nynorsk (<literal>nn</literal>)</entry>
</row>

<row>
<entry>Serbian (<literal>sr</literal>)</entry>
<entrytbl cols="1">
<tbody>
<row><entry>KDE t.t. (<literal>kde</literal>)</entry></row>
<row><entry>The Battle for Wesnoth t.t. (<literal>wesnoth</literal>)</entry></row>
</tbody>
</entrytbl>
</row>

<row>
<entry>Spanish (<literal>es</literal>)</entry>
</row>

</tbody>
</tgroup>
</informaltable>
</para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-lgspell">
<title>Spell Checking</title>

<para>Pology can employ various well-known spell-checkers to check the translation in PO files. Currently there is standalone support for <ulink url="http://aspell.net/">Aspell</ulink>, and unified support for many spell-checkers (including Aspell) through <ulink url="http://www.abisource.com/projects/enchant/">Enchant, the spell-checking wrapper library</ulink> (more precisely, through <ulink url="http://pyenchant.sourceforge.net">Python bindings</ulink> for Enchant).</para>

<para>Spell-checking of one PO file or a collection of PO files can be performed directly by <link linkend="ch-sieve">sieving</link> them through one of <link linkend="sv-check-spell"><command>check-spell</command></link> (Aspell) or <link linkend="sv-check-spell-ec"><command>check-spell-ec</command></link> sieves. The sieve will report each unknown word, possibly with a list of suggestions, and the location of the message (file and line/entry numbers). It can also be requested to show the full message, with unknown words in the translation highlighted.</para>

<para>Also provided are several <link linkend="hk-spell">spell-checking hooks</link>, which can be used as building blocks in custom translation validation chains. For example, a spell-checking hook can be used to define the spell-checking rule within Pology's <link linkend="sec-lgrules">validation rules</link> collection for a given language.</para>

<sect2 id="sec-lgspdicts">
<title>Internal Spelling Dictionaries</title>

<para>Pology collects internal language-specific word lists as supplements
to system spelling dictionaries. One use of internal dictionaries is to record those words which are omitted in the system spelling dictionaries, but are actually proper words in the given language. Such words should be added into internal dictionaries only as an immediate fix for false spelling warnings, with an eye towards integrating them into the upstream spelling dictionaries of respective spell-checkers.</para>

<para>More importantly, internal dictionaries serve to collect words specific to a given environment, i.e. the words which are deemed too specific to be part of the upstream, general spelling dictionaries for the language. For example, this can be technical jargon, with newly coined terms which are yet to be more widely accepted. Another example could be translation of fiction, in books or computer games, where it is common-place to make up words for fictional objects, animals, places, etc. which are not even intended to be more widely used.</para>

<para>In Pology source tree, internal spelling dictionaries by language are located in <filename>lang/<replaceable>lang</replaceable>/spell/</filename> directories. This directory can contain arbitrary number of dictionary files, which are all automatically picked up by Pology when spelling-checking for that language is done. Dictionary files directly in this directory are environment-agnostic, and should contain only the words which are standard (or standard derivations) in the language, but happen to be missing from the system spelling dictionary. Subdirectories represent specific environments, they are named with the environment code, and can also contain any number of dictionaries. An example of internal dictionary tree with environments:
<programlisting>
lang/
    sr/
        spell/
            colors.aspell
            fruit.aspell
            ...
            science.aspell
            kde/
                general.aspell
            wesnoth/
                general.aspell
                propernames.aspell
</programlisting>
</para>

<para>Dictionary files are in the Aspell word list format (regardless of the spell-checker actually used), and must have <filename>.aspell</filename> extension. This is a simple plain text format, listing one word per line. Only the first line is special, the header, which states the language code, number of words in the list, and the encoding. For example:
<programlisting>
personal_ws-1.1 fr 1234 UTF-8
apricot
banana
cherry
...
</programlisting>
Actually the only significant element of the header is the encoding. Language code and number of words can be arbitrary, as Pology will not use them.</para>

<para>Pology provides the <command>organizeDict.py</command> script which sorts word list files alphabetically (and corrects the word count in the header, even if not important), so that you do not have to manually insert new words in proper order. The script is simply run with arbitrary number of word list files as arguments, and modifies them in place. In case of duplicate words, it will report duplicates and eliminate them. In case of words with invalid characters (e.g. space), the script will output a warning, but it will not remove them; automatic removal of invalid words can be requested with <option>-r</option>/<option>--remove-invalid</option> option.</para>

</sect2>

<sect2 id="sec-lgspskip">
<title>Skipping Messages and Words</title>

<para>Sometimes a message or a few words in it should not be spell-checked. This can be, for example, when the message is dense computer input (like a command line synopsis), or when a word is part of a literal phrase (such as an email address). It may be possible to filter the text to remove some of the non-checkable words prior to spell-checking (especially when spell-checking is done as a <link linkend="sec-lgrules">validation rule</link>), but not all such words can be automatically detect. For example, especially problematic are onomatopoeic constructs ("Aaargh! Who released the beast?!").</para>

<para>For this reason it is possible to manually skip spell-checking on a message, or on certain words within a message, by adding a <link linkend="sec-cmskipcheck">special translator comment</link>. The whole message is skipped by adding the <literal>no-check-spell</literal> translator flag to it:
<programlisting>
# |, no-check-spell
</programlisting>
Words within the message are skipped by listing them in <literal>well-spelled:</literal> translator comment, comma- or space-separated:
<programlisting>
# well-spelled: Aaarg, gaaah, khh
</programlisting>
Which of these two levels of skipping to use depends on the nature of the text. For example, if most of the text is composed of proper words, and there are only a few which should not be checked, it is probably better to list those words explicitly instead of skipping the whole message.</para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-lggrammar">
<title>Grammar Checking</title>

<para>With Pology you can use <ulink url="http://www.languagetool.org/">LanguageTool</ulink>, a free grammar and style checker, to check translation in PO files. At the moment LanguageTool is applicable only through <link linkend="sv-check-grammar">the <command>check-grammar</command> sieve</link>, so look up the details in its documentation.</para>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-lgmtrans">
<title>Machine Translation</title>

<para><emphasis>Machine translation</emphasis> is the process where a computer program is used to produce translation of more than a trivial piece of text, starting from single sentences, over paragraphs, to full documents. There are debates on how useful machine translation is right now and how much better it could become in the future, and there is a steady line of research in that direction. Limiting to widely available examples of machine translation software today, it is safe to say that, on the one hand, machine translation can preserve a lot of the meaning of the original and thus be very useful to the reader who needs to grasp the main points of the text, but on the other hand, are not at all passable for producing translations of the quality expected of human translators who are native speaker of the target language.</para>

<para>As far as Pology is concerned, the question of machine translation reduces to this: would it increase the efficiency of translation if PO files were first machine-translated, and then manually corrected by a human translator? There is no general answer to this question, as it depends stronly on all elements in the chain: the quality of machine translation software, the source language, the target language, and the human translator. Be that as it may, Pology provides the <command>pomtrans</command> script, which can fill in untranslated messages in PO files by passing original text through various machine translation services.</para>

<para><command>pomtrans</command> has two principal modes of operation. The more straightforward is the direct mode, where original texts are simply <varname>msgid</varname> strings in the given PO file. In this mode, PO files can be machine-translated with:
<programlisting>
$ pomtrans <replaceable>transerv</replaceable> -t <replaceable>lang</replaceable> <replaceable>paths...</replaceable>
</programlisting>
The first argument is the translation service keyword, chosen from one known to <command>pomtrans</command>. The <option>-t</option> option specifies the target language; it may not be necessary if processed PO files have the <literal>Language:</literal> header field properly set. The source language is assumed to be English, but there is an option to specify another source language. Afterwards an arbitrary number of paths follow, which may be either single PO files or directories which will be recursively searched for PO files.</para>

<para><command>pomtrans</command> will try to translate only untranslated messages, and not fuzzy messages. When it translates a message, by default it will make it fuzzy as well, meaning that a human should go through all machine-translated messages. These defaults are based on the perceived current quality of most machine translation services. There are several command line options to change this behavior.</para>

<para>The other mode of operation is the parallel mode. Here <command>pomtrans</command> takes the original text to be the translation into another language, i.e. <varname>msgstr</varname> strings from a PO file translated into another language. For example, if a PO file should be translated into Spanish (i.e. from English to Spanish), and that same PO file is available fully translated into French (i.e. from English to French), then <command>pomtrans</command> could be used to translate from French to Spanish. This is done in the following way:
<programlisting>
$ pomtrans <replaceable>transerv</replaceable> -s <replaceable>lang1</replaceable> -t <replaceable>lang2</replaceable> -p <replaceable>search</replaceable>:<replaceable>replace</replaceable> <replaceable>paths...</replaceable>
</programlisting>
As in direct mode, the first argument is the translation service. Then both the source (<option>-s</option>) and the target language (<option>-t</option>) are specified; again, if PO files have their <literal>Language:</literal> header fields set, these options are not necessary. The perculiar here is the <option>-p</option> option, which specifies two strings, separated by colon. These are used to construct paths to source language PO files, by replacing the first string in paths of target language PO files with the second string. For example, if the file tree is:
<programlisting>
foo/
    po/
        alpha/
            alpha.pot
            fr.po
            es.po
        bravo/
            bravo.pot
            fr.po
            es.po
</programlisting>
then the invocation could be:
<programlisting>
$ cd .../foo/
$ pomtrans <replaceable>transerv</replaceable> -s fr -t es -p es.:fr. po/*/es.po
</programlisting>
In case a PO file in target language does not have a counterpart in source language, it is simply skipped.</para>

<para>There is another variation of the parallel mode, where source language texts are drawn not from counterpart PO files, but from a single, compendium PO file in source language. This mode is engaged by giving the path to that compendium with the <option>-c</option> option, instead of the <option>-p</option> option for path replacement.</para>

<sect2 id="sec-lgpomtopts">
<title>Command Line Options</title>

<para>Options specific to <command>pomtrans</command>:
<variablelist>

<varlistentry>
<term><option>-a <replaceable>CHARS</replaceable></option>, <option>--accelerator=<replaceable>CHARS</replaceable></option></term>
<listitem>
<para>Characters used as <link linkend="sec-poaccel">accelerator markers</link> in user interface messages. They should be removed from the source language text before translation, in order not to confuse the translation service.<footnote>
<para>This also means that, at the moment, machine-translated text has no accelerator when the original text did have one. Some heuristics may be implemented in the future to add the accelerator to translated text as well.</para>
</footnote></para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-c <replaceable>FILE</replaceable></option>, <option>--parallel-compendium=<replaceable>FILE</replaceable></option></term>
<listitem>
<para>The path to source language compendium, in parallel translation mode.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-l</option>, <option>--list-transervs</option></term>
<listitem>
<para>Lists known translation services (the keywords which can be the first argument to <command>pomtrans</command>).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-m</option>, <option>--flag-mtrans</option></term>
<listitem>
<para>Adds the <literal>mtrans</literal> flag to each machine-translated message. This may be useful to positively identify machine-translated messages in the resulting PO file, as otherwise they are simply fuzzy.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-M <replaceable>MODE</replaceable></option>, <option>--translation-mode=<replaceable>MODE</replaceable></option></term>
<listitem>
<para>Translation services need as input the mode in which to operate, usually the source and target language at minimum. By default the translation mode is constructed based on source and target languages, but this is sometimes not precise enough. This option can be used to issue a custom mode string for the chosen translation service, overriding the default construction. The format of the mode string is translation service dependent, check documentation of respective translation services for details.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-n</option>, <option>--no-fuzzy-flag</option></term>
<listitem>
<para>By default machine-translated messages are made fuzzy, which is prevented by this option. It goes without saying that this is dangerous at current state of the art in machine translation, and should be used only in very specific scenarios (e.g. high quality machine translation between two dialects of the same language).</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-p <replaceable>SEARCH</replaceable>:<replaceable>REPLACE</replaceable></option>, <option>--parallel-catalogs=<replaceable>SEARCH</replaceable>:<replaceable>REPLACE</replaceable></option></term>
<listitem>
<para>The string to search for in paths of target language PO files, and the string to replace them with to construct paths of source language PO files, in parallel translation mode.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-s <replaceable>LANG</replaceable></option>, <option>--source-lang=<replaceable>LANG</replaceable></option></term>
<listitem>
<para>The source language code, i.e. the language which is being translated from.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-t <replaceable>LANG</replaceable></option>, <option>--target-lang=<replaceable>LANG</replaceable></option></term>
<listitem>
<para>The target language code, i.e. the language which is being translated into.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><option>-T <replaceable>PATH</replaceable></option>, <option>--transerv-bin=<replaceable>PATH</replaceable></option></term>
<listitem>
<para>If the selected translation service is (or can be) a program on the local computer, this option can be used to specify the path to its executable file, if it is not in the <envar>PATH</envar>.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

</sect2>

<sect2 id="sec-lgpomtservs">
<title>Supported Machine Translation Services</title>

<para>Currently supported translation services are as follows (with keyword in parenthesis):
<variablelist>

<varlistentry>
<term>Apertium (<literal>apertium</literal>)</term>
<listitem>
<para><ulink url="http://www.apertium.org/">Apertium</ulink> is a free machine translation platform, developed by the TRANSDUCENS research group of University of Alicante. There is a basic web service, but the software can be locally installed and that is how <command>pomtrans</command> uses it (some distributions provide packages).</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Google Translate (<literal>google</literal>)</term>
<listitem>
<para><ulink url="http://translate.google.com/">Google Translate</ulink> is Google's proprietary web machine-translation service, which can be used free of charge. At the moment, <command>pomtrans</command> makes one query to it per message, which can take quite some time on long PO files.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-lguirefs">
<title>Automatic Insertion of UI Labels</title>

<para>In program documentation, but also in help texts in running programs, frequently labels from user interface are mentioned. Here are two such messages, one a UI tooltip, the other a Docbook paragraph:
<programlisting>
#: comic.cpp:466
msgid "Press the \"Get New Comics...\" button to install comics."
msgstr ""

#: index.docbook:157
msgid ""
"&lt;guimenuitem>Selected files only&lt;/guimenuitem> extracts only "
"the files which have been selected."
msgstr ""
</programlisting>
In the usual translation process, an embedded UI label is manually translated just like the surrounding text. You could directly translate the label, hoping that the original UI message was translated in the same way, but this will frequently not be the case (especially for longer labels). To be thorough, you could look up the UI message in its PO file, or run the program, to see how it was actually translated. There are two problems with being thorough in this way: it takes time to look up original UI messages, and worse, translation of a UI message might change in the future (e.g. after a review) and leave the referencing message out of date.</para>

<para>An obvious solution to these problems, in principle, would be to leave embedded UI labels untranslated but properly marked (such as with <literal>&lt;gui*&gt;</literal> tags in Docbook), and have an automatic system fetch their translations from original UI messages and insert them into referencing messages. However, there could be many implementational variations of this approach (like at which stage of the translation chain the automatic insertion happens), with some significant details to get right.</para>

<para>At present, Pology approaches automatic insertion of UI labels in a generalized way, which does not mandate any particular organization of PO files or translation workflow. It defines a syntax for wrapping and disambiguating UI references, for linking referencing and originating PO files, and provides a series of <link linkend="hk-uiref-resolve-ui">hooks to resolve and validate UI references</link>. A UI reference resolving hook will simply replace a properly equipped non-translated UI label with its translation. This implies that PO files which are delivered must not be the same PO files which are directly translated, because resolving UI references in directly translated PO files would preclude their automatic update in the future<footnote>
<para>Another advantage is that original text too will sometimes contain out-of-date UI references, which this process will automatically discover and enable the translation to be more up-to-date than the original. Of course, reporting the problem to the authors would be desireable, or even necessary when the related feature no longer exists.</para>
</footnote>. It is upon the translator or the translation team to establish the separation between delivered and translated PO files. One way is by translating in summit (see <xref linkend="ch-summit"/>), which by definition provides the desired separation, and setting UI reference resolving hooks as filters on scatter.</para>
<!-- FIXME: Link ...filters on scatter... to hooks section of summit documentation, once ready. -->

<sect2 id="sec-lguiformat">
<title>Wrapping UI References</title>

<para>If UI references are inserted into the text informally (even if relying on certain ortographic or typographic conventions), then they must be manually wrapped in the translation using an explicit UI reference directive. For example:
<programlisting>
#: comic.cpp:466
msgid "Press the \"Get New Comics...\" button to install comics."
msgstr "Pritisnite dugme „~%/Get New Comics/“ da instalirate stripove."
</programlisting>
Explicit UI reference directives are of the format <replaceable>head</replaceable>/<replaceable>reference-text</replaceable>/. The directive head is <literal>~%</literal> in this example, which is the default, but another head may be specified as parameter to UI resolving hooks. Delimiting slashes in the UI reference directive can be replaced with any other character consistenly (e.g. if the UI text itself contains a slash). Note that the directive head must be fixed for a collection of PO files (though more than one head can be defined), while delimiting character can be freely chosen from one to another directive.</para>

<para>The other the type are implicit UI references, which do not require
special directive, made possible when UI text is indicated in the text through formal markup. This is the case, for example, in PO files coming from Docbook documenation:
<programlisting>
#: index.docbook:157
msgid ""
"&lt;guimenuitem>Selected files only&lt;/guimenuitem> extracts only "
"the files which have been selected."
msgstr ""
"&lt;guimenuitem>Selected files only&lt;/guimenuitem> raspakuje samo "
"datoteke koje su izabrane."
</programlisting>
Here the translation contains nothing special, save for the fact that the UI reference is not translated. UI resolving hooks can be given a list of tags to be considered as UI references, and for some common formats (such as Docbook) there are predefined specialized hooks which already list all UI tags.</para>

<para>If the message of the UI text is unique by its <varname>msgid</varname> string in the originating PO file, then it can be wrapped simply as in previous examples. This means that even if it has the <varname>msgctxt</varname> string, the reference will still be resolved. But, if there are several UI messages with same <varname>msgid</varname> (implying different <varname>msgctxt</varname>), then the <varname>msgctxt</varname> string has to be manually added to the reference. This is done by puting the context into the prefix of the reference, separated by the pipe <literal>|</literal> character. For example, if the PO file has these two messages:
<programlisting>
msgctxt "@title:menu"
msgid "Columns"
msgid "Kolone"

msgctxt "@action:inmenu View Mode"
msgid "Columns"
msgstr "kolone"
</programlisting>
then the correct one can be selected in an implicit UI reference like this:
<programlisting>
msgid ""...&lt;guibutton>Columns&lt;/guibutton>..."
msgstr "...&lt;guibutton>@title:menu|Columns&lt;/guibutton>..."
</programlisting>
In the very unlikely case of <literal>|</literal> character being part of the context string itself, the <literal>¦</literal> character ("broken bar") can be used as the context separator instead.</para>

<para>If the UI reference equipped with context does not resolve to a message through direct match on context, the given context string will next be tried as regular expression match on <varname>msgctxt</varname> strings of the messages with matching <varname>msgid</varname> (matching will be case-insensitive). If this results in exactly one matched message, the reference is resolved. This matching sequence allows simplification and robustness in case of longer contexts, which would look ungainly in the UI reference and may slightly change over time.</para>

<para>If two UI messages have equal <varname>msgid</varname> but are not part of the same PO file, that is not a conflict because one of those PO files has the priority (see <xref linkend="sec-lguilink"/>).</para>

<para>If of UI two messages with equal <varname>msgid</varname> one has <varname>msgctxt</varname> and the other does not, the message without context can be selected by adding the context separator in front of the text with nothing before it (i.e. as if the context is "empty").</para>

<para>Sometimes, though rarely, it happens that the referenced UI text is not statically complete, that is, that it contains a format directive which is resolved at runtime. In such cases, the reference must be transformed to exactly an existing <varname>msgid</varname>, and the arguments are substituted with special syntax. If the UI message is:
<programlisting>
msgid "Configure %1..."
msgstr "Podesi %1..."
</programlisting>
then it can be used in an implicit UI reference like this:
<programlisting>
msgid "...&lt;guimenuitem>Configure Foobar...&lt;/guimenuitem>..."
msgstr "...&lt;guimenuitem>Configure %1...^%1:Foobar&lt;/guimenuitem>..."
</programlisting>
Substitution arguments follow after the text, separated with the <literal>^</literal> character. Each argument specifies the format directive it replaces and the argument text, separated by <literal>:</literal>. In the unlikely case that <literal>^</literal> is part of the <varname>msgid</varname> itself, the <literal>ª</literal> ("feminine ordinal indicator") can be used instead as the argument separator.</para>

<para>If there are several format directives in the UI reference, they are by default considered "named". This means that all same format directives will be replaced by the same argument. This is the right thing to do for some formats, e.g. <literal>python-format</literal> or <literal>kde-format</literal> messages, but not for all formats. In <literal>c-format</literal>, if there are two <literal>%s</literal> in the text, to replace just one of them with the current argument, the format directive attached to the argument must be preceded with <literal>!</literal>:
<programlisting>
#, c-format
msgid "...&lt;guilabel>This Foo or that Bar&lt;/guilabel>..."
msgstr "...&lt;guilabel>This %s or that %s.^!%s:foo^!%s:bar&lt;/guilabel>..."
</programlisting>
</para>

<para>In general, but especially with implicit references, the text wrapped as reference may actually contain several references in form of UI path (<literal>"...go to Foo->Bar->Baz, and click on..."</literal>). To handle such cases, if it is not possible or it is not convenient to wrap each element of the UI path separately, UI reference resolving hooks can be given one or more UI path separators (e.g. <literal>-></literal>) to split and resolve the element references on their own.</para>

<para>Sometimes the UI reference in the original text is not valid, i.e. such message no longer exists in the program. This can happen due to slight interpunction mismatch, small style changes, etc., such that you can easily locate the correct UI message and use its <varname>msgid</varname> as the reference. However, if the UI reference is not valid due to documentation being outdated, there is no correct UI message to use in translation. This should most certainly be reported to the authors, but up until they fix it, it presents a problem for immediate resolution of UI references. For this reason, a UI reference can be temporarily translated in place, by preceding it with twin context separators:
<programlisting>
msgid "...<guilabel>An Outdated Label</guilabel>..."
msgstr "...<guilabel>||Zastarela etiketa</guilabel>..."
</programlisting>
This will resolve into the verbatim text of the reference (i.e. context separators will simply be removed), without the hook complaining about an unresolvable reference.</para>

</sect2>


<sect2 id="sec-lguinorm">
<title>Normalization of UI Text</title>

<para>The text of the UI message may contain some characters and substrings which should not be carried over into the text which references the message, or should be modified. To cater for this, UI PO files are normalized after being opened and before UI references are looked up in them. In fact, UI references are written precisely in this normalized form, rather than using the true original <varname>msgid</varname> from the UI PO file. This is both for convenience and for necessity.</para>

<para>One typical thing to handle in normalization is the accelerator marker. UI reference resolving hooks eliminate accelerator markers automatically, by for that they need to known what the accelerator marker character is. To find this out, hooks will read <link linkend="hdr-x-accelerator-marker">the <literal>X-Accelerator-Marker</literal> header field</link>.</para>

<para>Another problem is when UI messages contain subsections which would invalidate the target format which is being translated in the referencing PO file, e.g. malformed XML in Docbook catalogs. For example, literal <literal>&amp;</literal> must be represented as <literal>&amp;amp;</literal> in Docbook markup, thus this UI message:
<programlisting>
msgid "Scaled &amp; Cropped"
msgstr ""
</programlisting>
would be referenced as:
<programlisting>
msgid "...&lt;guimenuitem>Scaled &amp;amp; Cropped&lt;/guimenuitem>..."
msgstr "...&lt;guimenuitem>Scaled &amp;amp; Cropped&lt;/guimenuitem>..."
</programlisting>
Resolving hooks have parameters for specifying the type of escaping needed by the target format.</para>

<para>Normalization may flatten several different messages from the UI PO file into one. Example of this is when <varname>msgid</varname> fields are equal but for the accelerator marker. If this happens and normalized translations are not equal for all flattened messages, a special "tail" is added to their contexts, consisting of a tilde and several alphanumeric characters. The first run of the resolving (or validation) hook will report ambiguities of this kind, as well as assigned contexts, so that proper context can be copied and pasted over into the UI reference. The alphanumeric context tail is computed from the non-normalized <varname>msgid</varname> alone, so it will not change if, for example, messages in the UI PO file get reordered.</para>

</sect2>

<sect2 id="sec-lguilink">
<title>Linking to Originating PO Files</title>

<para>In general, the UI message may not be present in the same PO file in which it is referenced in another messages. This is always the case for documentation PO files. Therefore UI reference resolving hooks need to know two things: the list of all UI PO files (those from which UI references may be drawn), and, for each PO file which contains UI references, the list of PO files from which it may draw UI references.</para>

<para>The list of UI PO files can be given to resolving hooks explicitly, as list of PO file paths (or directory paths to search for PO files). This can, however, be inconvenient, as it implies either that the resolution script must be invoked in a specific directory (if paths are relative), or that UI PO files must reside in a fixed directory on the system where the resolution script is run (if paths are absolute). Therefore there is another way of specifying paths to UI PO files, through an environment variable which contains a colon-separated list of directory paths. Both the explict list of paths and the environment variable which contains the paths can be given as parameters to hooks.</para>

<para>By default, for a given PO file, UI references are looked for only in the PO file of the same name, assuming that it is found among UI PO files. This may be sufficient, for example, for UI references in tooltips, but it is frequently not sufficient for documentation PO files, which may have a different names from corresponding UI PO file names. Therefore a PO file can be manually linked to UI PO files from which it draws UI references, through a special header field <literal>X-Associated-UI-Catalogs</literal>. This field specifies only the PO domain names, as space- or comma-separated list:
<programlisting>
msgid ""
msgstr ""
"Project-Id-Version: foobar\n"
"..."
"X-Associated-UI-Catalogs: foobar libfoobar libqwyx\n"
</programlisting>
The order of domain names in the list is important: if the referenced UI message exists in more than one linked PO file, the translation is taken from the one which appears earlier in the list. Knowing PO domain names, resolving hooks can look up the exact file paths in the supplied list of paths.</para>

</sect2>

<sect2 id="sec-lguinotes">
<title>Notes on UI Reference Resolution</title>

<para>When a UI reference cannot be resolved, for whatever reason -- it does not exist, there is a context conflict, the message is not translated, etc. -- resolving hooks will output warnings and fallback to original text.</para>

<para>For each resolving hook there exists the counterpart validation hook. Validation hooks may be used in a "dry run" before starting to build PO files for delivery, or they may be built into a general translation validation framework (such as Pology's <link linkend="sec-lgrules">validation rules</link>).</para>

</sect2>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-lgrules">
<title>Validation Rules</title>

<para></para>

</sect1>

<!-- ======================================== -->
<sect1 id="sec-lgsynder">
<title>Syntagma Derivation</title>

<para></para>

</sect1>

</chapter>
