<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>pology.misc.synder</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="pology-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="pology-module.html">Package&nbsp;pology</a> ::
        <a href="pology.misc-module.html">Package&nbsp;misc</a> ::
        Module&nbsp;synder
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module synder</h1><p class="nomargin-top"></p>
<p>Derive forms and properties of syntagmas by macro expansion.</p>
  <p>A syntagma, a set of one or several words with a certain meaning, in a
  human language may have many grammar forms and properties. When the forms
  are sufficiently regular small perturbations of the original syntagma 
  (e.g. different word endings by grammar case), it is possible to 
  construct them by macro derivation, rather than having to write out each 
  form in full.</p>
  <p>This module provides facilities for such macro derivations on 
  syntagmas. It consists of two elements: the text format for defining 
  macro derivations, and the derivator class which reads and processes 
  these definitions. The derivator class is documented in the usual places,
  and the rest of this text deals with syntax and semantics of derivation 
  definitions.</p>
  <p>As an example application, we consider a dictionary of proper names, 
  where for each name in source language we want to define the basic name 
  and some of its forms and properties in target language.</p>
  <h1 class="heading">Basic Derivations</h1>
    <p>For the name in source language &quot;Venus&quot; and in target 
    language &quot;Venera&quot;, we could write the following simplest 
    derivation, which defines only the basic form in target language:</p>
<pre class="literalblock">
   Venus: =Venera
</pre>
    <p><code>Venus</code> is the key syntagma or derivation key, which is 
    separated by the colon character from its properties. Properties are 
    written as <code>KEY=VALUE</code> pairs, and separated by commas; in 
    <code>=Venera</code>, the key is empty string and the value is 
    <code>Venera</code>.</p>
    <p>We would now like to define some grammar cases in target language. 
    &quot;Venera&quot; is the nominative (basic) case, so instead of empty 
    string we use <code>nom</code> as its key; other cases that we want to 
    define are genitive (<code>gen</code>) &quot;Venere&quot;, dative 
    (<code>dat</code>) &quot;Veneri&quot;, and accusative 
    (<code>acc</code>) &quot;Veneru&quot;. Then we can write:</p>
<pre class="literalblock">
   Venus: nom=Venera, gen=Venere, dat=Veneri, acc=Veneru
</pre>
    <p>By this point, everything is written out manually, there are no 
    &quot;macro derivations&quot; to speak of. But observe the difference 
    between different cases of &quot;Venera&quot; -- only the final letter 
    is changing. Therefore, we first write the following <i>base</i> 
    derivation for this system of case endings alone, called 
    &quot;declension-1&quot;:</p>
<pre class="literalblock">
   |declension-1: nom=a, gen=e, dat=i, acc=u
</pre>
    <p>A base derivation is normally also <i>hidden</i>, by prepending the 
    pipe character to its syntagma. We make it hidden because it should be 
    used only in other derivations, and does not represent a proper entry 
    in our dictionary example; in the processing stage, derivations with 
    hidden syntagmas will not be offered on queries into dictionary. We can
    now use this derivation to shorten the derivation for 
    &quot;Venus&quot;:</p>
<pre class="literalblock">
   Venus: Vener|declension-1
</pre>
    <p>Here <code>Vener</code> is the root, and <code>|declension-1</code> 
    is the expansion, referencing the previously defined base derivation. 
    The final forms are derived by inserting the property values found in 
    the expansion (<code>a</code> from <code>nom=a</code>, <code>e</code> 
    from <code>gen=e</code>, etc.) at the position where the expansion 
    occurs, for each of the keys found in the expansion, thus obtaining the
    expected properties (<code>nom=Venera</code>, <code>gen=Venere</code>, 
    etc.) for current derivation.</p>
    <p>Note that <code>declension-1</code> may be a too verbose name for 
    the base derivation. If the declension type can be identified by the 
    stem of the nominative case (here <code>a</code>), to have much more 
    natural looking derivations we could write:</p>
<pre class="literalblock">
   |a: nom=a, gen=e, dat=i, acc=u
   Venus: Vener|a
</pre>
    <p>Now the derivation looks just like the nominative case alone, only 
    having the root and nominative stem separated by the pipe.</p>
    <p>The big gain of this transformation is, of course, when there are 
    many syntagmas having the same declension type. Other such 
    source-target pairs could be &quot;Earth&quot; and &quot;Zemlja&quot;, 
    &quot;Europe&quot; and &quot;Evropa&quot;, &quot;Rhea&quot; and 
    &quot;Reja&quot;, so we can write:</p>
<pre class="literalblock">
   |a: nom=a, gen=e, dat=i, acc=u
   Venus: Vener|a
   Earth: Zemlj|a
   Europe: Evrop|a
   Rhea: Rej|a
</pre>
    <p>This is a good point to note that derivations are separated by 
    newlines. If necessary, single derivation can be split into several 
    lines by putting a backslash at the end of each line but the last.</p>
    <p>Expansion is implicitly terminated by a whitespace or a comma, or by
    another expansion. If these characters are part of the expansion itself
    (i.e. of the syntagma of the derivation it refers to), or the text 
    continues right after the expansion without a whitespace, braces can be
    used to explicitly delimit the expansion:</p>
<pre class="literalblock">
   Alpha Centauri: Alf|{a}-Kentaur
</pre>
    <p>Any character which is special in the current context may be escaped
    with a backslash. Only the second colon here is a separator:</p>
<pre class="literalblock">
   Destination\: Void: Odredi&#353;t|{e}: ni&#353;tavilo
</pre>
    <p>A single derivation may state more than one key syntagma, 
    comma-separated. For example, if the syntagma in source language has 
    several spellings:</p>
<pre class="literalblock">
   Iapetus, Japetus: Japet|
</pre>
    <p>A syntagma can also be an empty string. This is useful for base 
    derivations when nominative-stem naming is used and a nominative stem 
    happens to be null -- such as in the previous example. The derivation 
    to which this empty expansion refers to would be:</p>
<pre class="literalblock">
   |: nom=, gen=a, dat=u, acc=
</pre>
    <p>Same-valued properties do not have to be repeated, but instead 
    several keys can be linked to one value, ampersand-separated. The 
    previous base derivation could thus be defined as:</p>
<pre class="literalblock">
   |: nom&amp;acc=, gen=a, dat=u
</pre>
    <p>Derivation definitions may contain the # to end of line 
    comments:</p>
<pre class="literalblock">
   # A comment.
   Venus: Vener|a # another comment
</pre>
  <h1 class="heading">Multiple Expansions</h1>
    <p>A single derivation may contain more than one expansion. There are 
    two distinct types of multiple expansion, outer and inner.</p>
    <p>Outer multiple expansion is used when it is advantageous to split 
    derivations by grammar classes. The examples so far were only deriving 
    grammar cases of nouns, but we may also want to define possesive 
    adjective per noun. For &quot;Venera&quot;, the possesive adjective in 
    nominative is &quot;Venerin&quot;. Using the same nominative-stem 
    naming of base derivations, we could write:</p>
<pre class="literalblock">
   |a: &#8230;  # as above
   |in: &#8230;  # posessive adjective
   Venus: Vener|a, Vener|in
</pre>
    <p>Expansions are resolved from left to right, with the expected effect
    of derived properties accumulating along the way. The only question is 
    what happens if two expansions produce properties with same keys but 
    different values -- then the value produced by the last (rightmost) 
    expansion takes precedence.</p>
    <p>Inner multiple expansion is used on multi-word syntagmas, when more 
    than one word needs expansion. For example, the target pair of 
    &quot;Orion Nebula&quot; is &quot;Orionova maglina&quot;, where the 
    first word is a possesive adjective, and the second a noun. The 
    derivation for this is:</p>
<pre class="literalblock">
   |a: &#8230;  # as above
   |ova&gt;: &#8230;  # posessive adjective as noun, &gt; is not special
   Orion Nebula: Orion|ova&gt; maglin|a
</pre>
    <p>Inner expansions are resolved from left to right, such that all 
    expansions right of the expansion currently resolved are treated as 
    plain text. If all expansions define same properties by key, then the 
    derivation will have all those properties, with values derived as 
    expected. However, if there is a mismatch between properties, then the 
    derivation will get the intersection of them, i.e. only those common to
    all expansions.</p>
    <p>Both outer and inner expansion may be used in a single 
    derivation.</p>
  <h1 class="heading">Expansion Masks</h1>
    <p>An expansion can be made not to result in all properties of referred
    to derivation, but only a subset of them, and with modification to 
    keys.</p>
    <p>Consider again the example of &quot;Orion Nebula&quot; and 
    &quot;Orionova maglina&quot;. Here the possesive adjective 
    &quot;Orionova&quot; has to be matched in both case and gender to the 
    noun &quot;maglina&quot; (feminine). Earlier we defined a special 
    adjective-as-noun derivation <code>|ova</code>, which was also 
    specialized to the feminine gender of &quot;maglina&quot;, but now we 
    want to make use of full posessive adjective derivation instead. Let 
    the property keys of this derivation be of the form <code>nommas</code>
    (nominative masculine), <code>genmas</code> (genitive masculine), &#8230;, 
    <code>nomfem</code> (nominative feminine), <code>genfem</code> 
    (genitive feminine), &#8230;. If we use the stem of nominative masculine 
    form, &quot;Orionov&quot;, to name the possesive adjective base 
    derivation, then we get:</p>
<pre class="literalblock">
   |ov: nommas=&#8230;, genmas=&#8230;, &#8230;, nomfem=&#8230;, genfem=&#8230;, &#8230;
   Orion Nebula: Orion|ov~...fem maglin|a
</pre>
    <p><code>|ov~...fem</code> here is a masked expansion. It states to 
    expand only those properties which have keys starting with any three 
    characters and ending in <code>fem</code>, as well as to drop 
    <code>fem</code> (being a constant) from the resulting keys. This 
    precisely selects only the feminine forms of the possesive adjective 
    and transforms their keys into noun keys needed to match with those of 
    <code>|a</code> expansion.</p>
    <p>We could also use this same masked expansion to produce the earlier 
    specialized adjective-as-noun base derivation:</p>
<pre class="literalblock">
   |ov: nommas=&#8230;, genmas=&#8230;, &#8230;, nomfem=&#8230;, genfem=&#8230;, &#8230;
   |ova&gt;: |ov~...fem
   Orion Nebula: Orion|ova&gt; maglin|a
</pre>
    <p>A special case of masked expansion is when there are no variable 
    characters in the mask (no dots). In the pair &quot;Constellation of 
    Cassiopeia&quot; and &quot;Sazve&#382;&#273;e Kasiopeje&quot;, the &quot;of 
    Cassiopeia&quot; is constructed by genitive case, 
    &quot;Kasiopeje&quot;, avoiding the need for preposition. If 
    &quot;Cassiopeia&quot; has its own derivation, then we can use it like 
    this:</p>
<pre class="literalblock">
   Cassiopeia: Kasiopej|a
   Constellation of Cassiopeia: Sazve&#382;&#273;|e |Cassiopeia~gen
</pre>
    <p><code>|e</code> is the usual nominative-stem expansion. The 
    <code>|Cassiopeia~gen</code> expansion produces only the genitive form 
    of &quot;Cassiopeia&quot;, but with an empty property key. If this 
    expansion would be treated as normal inner expansion, it would cancel 
    all forms produced by <code>|e</code> expansion, since none of them has
    an empty key. Instead, when an expansion produces a single form with 
    empty key, its value is treated as raw text and inserted into all forms
    produced to that point. Just as if we had written:</p>
<pre class="literalblock">
   Constellation of Cassiopeia: Sazve&#382;&#273;|e Kasiopeje
</pre>
    <p>Sometimes the default modification of propety keys, removal of all 
    fixed characters in the mask, is not exactly what we want. This should 
    be a rare case, but if it happens, the mask can also be given a <i>key 
    extender</i>. For example, if we would want to select only feminine 
    forms of the <code>|ov</code> expansion, but preserve the 
    <code>fem</code> ending of the resulting keys, we could write:</p>
<pre class="literalblock">
   Foobar: Fubar|ov~...fem%*fem
</pre>
    <p>The key extender in this expansion is <code>%*fem</code>. For each 
    resulting property, the final key is constructed by substituting every 
    asterisk, <code>*</code>, with the key resulting from 
    <code>~...fem</code> mask. Thus, here the <code>fem</code> ending is 
    added to every key, as desired.</p>
    <p>Expanded values can have their capitalization changed. By prepending
    circumflex (<code>^</code>) or backtick (<code>`</code>) to the 
    expansion reference, the first letter in resulting values is uppercased
    or lowercased, respectively. We could derive the pair &quot;Distant 
    Sun&quot; and &quot;Udaljeno sunce&quot; by using &quot;Sun&quot; and 
    &quot;Sunce&quot; (note the case difference in 
    &quot;Sunce&quot;/&quot;sunce&quot;) like this:</p>
<pre class="literalblock">
   Sun: Sunc|e  # this defines uppercase first letter
   Distant Sun: Dalek|o&gt; |`Sun  # this needs lowercase first letter
</pre>
  <h1 class="heading">Special Properties</h1>
    <p>Property keys may be given several endings, to make these properties
    behave differently from what was described so far. These ending are not
    treated as part of the property key itself, so they should not be given
    when querying derivations by syntagma and property key.</p>
    <p><i>Cutting</i> properties are used to avoid the normal insertion on 
    expansion. For example, if we want also to define the gender of nouns 
    through base expansions, we could come up with:</p>
<pre class="literalblock">
   |a: nom=a, gen=e, dat=i, acc=u, gender=fem
   Venus: Vener|a
</pre>
    <p>However, this will cause the <code>gender</code> property in 
    expansion to become <code>Venerafem</code>. For the <code>gender</code>
    property to be taken verbatim, without adding the segments from the 
    calling derivation around it, we add make it a cutting property by 
    appending an exclamation mark (<code>!</code>) to its key:</p>
<pre class="literalblock">
   |a: nom=a, gen=e, dat=i, acc=u, gender!=fem
</pre>
    <p>Now when dictionary is queried for <code>Venus</code> syntagma and 
    <code>gender</code> property, we will get the expected <code>fem</code>
    value.</p>
    <p>Cutting properties also behave differently in multiple inner 
    expansions. Instead of being canceled when not all inner expansions 
    define it, simply the rightmost value is taken -- just like in outer 
    expansions.</p>
    <p><i>Terminal</i> properties are those hidden with respect to 
    expansion, i.e. they are not taken into the calling derivation. A 
    property is made terminal by appending a dot (<code>.</code>) to its 
    key. For example, if some derivations have the short description 
    property <code>desc</code>, we typically do not want it to propagate 
    into calling derivations which happen not to override it by outer 
    expansion:</p>
<pre class="literalblock">
   Mars: Mars|, desc.=planet
   Red Mars: Crven|i&gt; |Mars  # a novel
</pre>
    <p><i>Canceling</i> properties will cause a previously defined property
    with the same key to be removed from the collection of properties. 
    Canceling property is indicated by ending its key with a circumflex 
    (<code>^</code>). The value of canceling property has no meaning, and 
    can be anything. Canceling is useful in expansions and alternative 
    derivations (see below), where some properties introduced by expansion 
    or alternative fallback should be removed from the final collection of 
    properties.</p>
  <h1 class="heading">Text Tags</h1>
    <p>Key syntagmas and property values can be equipped with simple tags, 
    which start with tag name in the form <code>~TAG</code> and extend to 
    next tag or end of text. For example, when deriving people names, we 
    may want to tag their first and last names, using tags <code>~fn</code>
    and <code>~ln</code> respectively:</p>
<pre class="literalblock">
   ~fn Isaac ~ln Newton: ~fn Isak| ~ln Njutn|
</pre>
    <p>In default processing, these tags are simply ignored, syntagmas and 
    property values are reported as if there were no tags. However, 
    derivator objects (which process derivation definitions) can take as 
    optional parameters transformation functions for key syntagmas and 
    property values, to which  tagged text segments will be passed, so that
    they can act on particular tags when producing the final text.</p>
    <p>Tag is implicitly terminated by whitespace or comma (or colon in 
    case of key syntagmas), but when none of these characters can be put 
    after a tag, tag name can be explicitly delimited by braces 
    (<code>~{TAG}</code>).</p>
  <h1 class="heading">Alternative Derivations</h1>
    <p>Sometimes there may be several alternative derivations to the given 
    syntagma. The default (in suitable sense) derivation is written as 
    usual, and other derivations are written under named 
    <i>environments</i>.</p>
    <p>For example, if deriving a transcribed person's name, there may be 
    several versions of the transcription. For &quot;Isaac Newton&quot;, 
    the usual, traditional transcription may be &quot;Isak Njutn&quot;, 
    while the modern transcription (i.e. applied to a living person of that
    name) would be &quot;Ajzak Njuton&quot;. Then we could have an 
    environment <code>modern</code> and write:</p>
<pre class="literalblock">
   Isaac Newton: Isak| Njutn|
       @modern: Ajzak| Njuton|
</pre>
    <p>Environment name is preceded with <code>@</code> and ended with 
    colon, after which the usual derivation follows. There can be any 
    number of non-default environments.</p>
    <p>The immediate question that arises is how are expansions treated in 
    non-default environments. In the previous example, what does 
    <code>|</code> expansion resolve to in <code>modern</code> environment?
    This depends on processing. By default, processing will require that 
    derivations referenced by expansions also have matching environments. 
    If <code>|</code> were defined as:</p>
<pre class="literalblock">
   |: nom=, gen=a, dat=u, acc=
</pre>
    <p>then expansion of &quot;Isaac Newton&quot; in <code>modern</code> 
    environment would fail. Instead, it would be necessary to define the 
    base derivations as:</p>
<pre class="literalblock">
   |: nom=, gen=a, dat=u, acc=
       @modern: nom=, gen=a, dat=u, acc=
</pre>
    <p>However, this may not be a very useful requirement. As can be seen 
    in this example already, in many cases base derivations are likely to 
    be same for all environments, so they would be needlessly duplicated. 
    It is therefore possible to define environment fallback chain in 
    processing, such that when a derivation in certain environment is 
    requested, environments in the fallback chain are tried in order. In 
    this example, if the chain would be given as <code>(&quot;modern&quot;,
    &quot;&quot;)</code> (name of default environment is empty string), 
    then we could write:</p>
<pre class="literalblock">
   |: nom=, gen=a, dat=u, acc=
   Isaac Newton: Isak| Njutn|
       @modern: Ajzak| Njuton|
   Charles Messier: &#352;arl| Mesje|
</pre>
    <p>When derivation of &quot;Isaac Newton&quot; in <code>modern</code> 
    environment is requested, the default expansion for <code>|</code> will
    be used, and the derivation will succeed. Derivation of &quot;Charles 
    Messier&quot; in <code>modern</code> environment will succeed too, 
    because the environment fallback chain is applied throughout; if 
    &quot;Charles Messier&quot; had different <code>modern</code> 
    transcription, we would have explicitly provided it.</p>
  <h1 class="heading">Treatment of Whitespace</h1>
    <p>ASCII whitespace in derivations, namely the space, tab and newline, 
    are not preserved as-is, but by default <i>simplified</i> in all final 
    forms. The simplification consists of removing all leading and trailing
    whitespace, and replacing all inner sequences of whitespace with a 
    single space. These two derivations are equivalent:</p>
<pre class="literalblock">
   Venus: nom=Venera
   Venus  :  nom =  Venera
</pre>
    <p>but these two are not:</p>
<pre class="literalblock">
   Venus: Vener|a
   Venus: Vener  |a
</pre>
    <p>because the two spaces between the root <code>Vener</code> and 
    expansion <code>|a</code> become inner spaces in resulting forms, so 
    they get converted into a single space.</p>
    <p>Non-ASCII whitespace, on the other hand, is preserved as-is. This 
    means that significant whitespace, like non-breaking space, zero width 
    space, word joiners, etc. can be used normally.</p>
    <p>For property values and key syntagmas it is possible to have 
    different treatment of whitespace, through an optional parameter to the
    derivator object. This parameter is a transformation function to which 
    text segments with raw whitespace are passed, so it can do with them as
    desired.</p>
    <p>Due to simplifaction of whitespace, indentation of key syntagmas and
    environment names is not significant, but it is enforced to be 
    consistent. This will fail parsing:</p>
<pre class="literalblock">
   Isaac Newton: Isak| Njutn|
       @modern: Ajzak| Njuton|
    George Washington: D&#382;ord&#382;| Va&#353;ington|  # inconsitent indent
     @modern: D&#382;ord&#382;| Vo&#353;ington|  # inconsitent indent
</pre>
    <p>This is done both in order to enforce a single indentation style 
    when several people are working on the same source, as well as to 
    discourage indentation schemes unfriendly to version control systems, 
    such as:</p>
<pre class="literalblock">
   Isaac Newton: Isak| Njutn|
        @modern: Ajzak| Njuton|
   George Washington: D&#382;ord&#382;| Va&#353;ington|
             @modern: D&#382;ord&#382;| Vo&#353;ington|  # inconsitent indent
</pre>
    <p>(Unfriendliness to VCS comes from the need to reindent lines which 
    are otherwise unchanged, merely in order to keep them aligned to lines 
    which were actually changed.)</p>
  <h1 class="heading">Uniqueness, Ordering and Inclusions</h1>
    <p>Within given source of derivations, each derivation must have at 
    least one unique key syntagma, because it is used as derivation key on 
    lookups. These two derivations are in conflict:</p>
<pre class="literalblock">
   Mars: Mars|  # the planet
   Mars: mars|  # the chocholate bar
</pre>
    <p>There are several possibilities to resolve conflicts in derivation 
    keys. The simplest possibility is to have keyword-like key syntagmas, 
    if key syntagmas themselves do not need to be human readable:</p>
<pre class="literalblock">
   marsplanet: Mars|
   marsbar: mars|
</pre>
    <p>If key syntagmas do have to be human readable, then one option is to
    extend them in human readable way as well:</p>
<pre class="literalblock">
   Mars (planet): Mars|
   Mars (chocolate bar): mars|
</pre>
    <p>This too is not acceptable if key syntagmas are intended to be of 
    equal weight to derived syntagmas, like in a dictionary application. In
    that case, the solution is to add a hidden keyword-like syntagma to 
    both derivations:</p>
<pre class="literalblock">
   Mars, |marsplanet: Mars|
   Mars, |marsbar: mars|
</pre>
    <p>Processing will now silently eliminate &quot;Mars&quot; as key to 
    either derivation, because it is conflicted, and leave only 
    <code>marsplanet</code> as key for the first and <code>marsbar</code> 
    as key for the second derivation. It is these keys that are also used 
    in expansions, to point to appropriate derivation. However, when 
    querying the derivator object for key syntagmas by derivation key 
    <code>marsplanet</code>, only &quot;Mars&quot; will be returned, 
    because <code>marsplanet</code> is hidden; likewise for 
    <code>marsbar</code>.</p>
    <p>Ordering of derivations is not important. The following order is 
    valid, although the expansion <code>|Venus~gen</code> is seen before 
    the derivation of &quot;Venus&quot;:</p>
<pre class="literalblock">
   Merchants of Venus: Trgovc|i&gt; s |Venus~gen
   Venus: Vener|a
</pre>
    <p>This enables derivations to be ordered naturally, e.g. 
    alphabetically, instead of the order being imposed by 
    technicalities.</p>
    <p>It is possible to include one file with derivations into another. A 
    typical use case would be to split the base derivations into a separate
    file, and include it into the visible derivations. If basic derivations
    are defined in <code>base.sd</code>:</p>
<pre class="literalblock">
   |: nom=, gen=a, dat=u, acc=, gender!=mas
   |a: nom=a, gen=e, dat=i, acc=u, gender!=fem
   &#8230;
</pre>
    <p>then the file <code>solarsys.sd</code>, placed in the same 
    directory, can include <code>base.sd</code> and use its derivations in 
    expansions like this:</p>
<pre class="literalblock">
   &gt;base.sd
   Mercury: Merkur|
   Venus: Vener|a
   Earth: Zemlj|a
   &#8230;
</pre>
    <p><code>&gt;</code> is the inclusion directive, followed by the 
    absolute or relative path to file to be included. If the path is 
    relative, it always relative to the including file, and not e.g. to 
    some externaly specified set of inclusion paths.</p>
    <p>If the including and included file contain a derivation with same 
    key syntagmas, that is not a conflict. On expansion, first the 
    derivations in the current file are checked, and if the referenced 
    derivation is not there, then the included files are checked in reverse
    to the inclusion order. In this way, it is possible to override some of
    base derivations in only one or few including files.</p>
    <p>Inclusions are &quot;shallow&quot;: only the derivations in the 
    included file itself are visible (available for use in expansions) in 
    the including file. In other words, if file A includes file B, and file
    B includes file C, then derivations from C are not automatically 
    visible in A; to use them, A must explicitly include C.</p>
    <p>Shallow inclusion and ordering-independent resolution of expansions 
    together make it possible to have mutual inclusions: A can include B, 
    while B can include A. This is an important capability when building 
    derivations of taxonomies. While derivation of X naturally belongs to A
    and of Y to B, X may nevertheless be used in expansion in another 
    derivation in B, and Y in another derivation in A.</p>
    <p>When a derivator object is created, files with derivations are 
    imported into it one by one, to make them available for queries. 
    Derivations from imported files (but not from files included by them, 
    according to shallow inclusion principle) all share a single namespace.
    This means that key syntagmas (derivation keys) across imported files 
    can conflict, and must be resolved by one of outlined methods.</p>
    <p>Design guideline behind the inclusion mechanism was that in each 
    collection of derivations, each <i>visible</i> derivation, one which is
    available to queries by the user of the collection, must be accessible 
    by at least one unique key, which does not depend on the underlying 
    file hierarchy.</p>
  <h1 class="heading">Error Handling</h1>
    <p>There are three levels of errors which may happen in 
    derivations.</p>
    <p>The first level are syntax errors, such as derivation missing a 
    colon which separates key syntagma from the rest, unclosed braced 
    expansion, etc. These errors are reported as soon as a derivation 
    source is imported into the derivator object.</p>
    <p>The second level of errors are expansion errors, such as an 
    expansion pointing to undefined derivation, or an expansion mask 
    discarding everything. These errors are reported by the derivator 
    object lazily, when the problematic derivation is actually looked up 
    for the first time.</p>
    <p>On the third level are semantic errors, such as if we want every 
    derivation to have a certain property, or <code>gender</code> property 
    to have only values <code>mas</code>, <code>fem</code> and 
    <code>neu</code>, and a derivation violates these requirements. At the 
    moment, there is no special way to catch these errors.</p>
    <p>In future, a mechanism (in form of file-level directives, perhaps) 
    may be introduced to immediately report reference errors on request, 
    and to constrain property keys and property values to avoid semantic 
    errors. Until then, the way to validate a collection of derivations 
    would be to write a piece of Python code which will import all files 
    into a derivator object, iterate through derivations (this alone will 
    catch expansion errors) and check for semantic errors.</p>
  <h1 class="heading">Miscellaneous Bits</h1>
    <p><code>syntax/</code> directory in Pology distribution contains 
    syntax highlighting definitions for syntagma derivations for some text 
    editors.</p>

<hr />
<div class="fields">      <p><strong>Author:</strong>
        Chusslove Illich (&#1063;&#1072;&#1089;&#1083;&#1072;&#1074; &#1048;&#1083;&#1080;&#1115;) &lt;caslav.ilic@gmx.net&gt;
      </p>
      <p><strong>License:</strong>
        GPLv3
      </p>
</div><!-- ==================== CLASSES ==================== -->
<a name="section-Classes"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Classes</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="pology.misc.synder.SynderError-class.html" class="summary-name">SynderError</a>
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="pology.misc.synder.Synder-class.html" class="summary-name">Synder</a><br />
      Derivator objects import sources of derivations and get queried for
        properties of syntagmas.
    </td>
  </tr>
</table>
<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Functions</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pology.misc.synder-module.html#empty_source_cache" class="summary-sig-name">empty_source_cache</a>()</span><br />
      Clear all cached sources.</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Function Details</span></td>
</tr>
</table>
<a name="empty_source_cache"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">empty_source_cache</span>()</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Clear all cached sources.</p>
  <p>When file with derivations is loaded, its parsed form is cached, such 
  that future load instructions on that same path (e.g. when the path is 
  included from another file) do not waste any extra time and memory. This 
  function erases all sources from the cache, when loading files anew on 
  future load instructions is desired.</p>
  <dl class="fields">
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="pology-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
