<?xml version="1.0" encoding="ascii"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>pology.misc.rules</title>
  <link rel="stylesheet" href="epydoc.css" type="text/css" />
  <script type="text/javascript" src="epydoc.js"></script>
</head>

<body bgcolor="white" text="black" link="blue" vlink="#204080"
      alink="#204080">
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="pology-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table width="100%" cellpadding="0" cellspacing="0">
  <tr valign="top">
    <td width="100%">
      <span class="breadcrumbs">
        <a href="pology-module.html">Package&nbsp;pology</a> ::
        <a href="pology.misc-module.html">Package&nbsp;misc</a> ::
        Module&nbsp;rules
      </span>
    </td>
    <td>
      <table cellpadding="0" cellspacing="0">
        <!-- hide/show private -->
      </table>
    </td>
  </tr>
</table>
<!-- ==================== MODULE DESCRIPTION ==================== -->
<h1 class="epydoc">Module rules</h1><p class="nomargin-top"></p>
<p>Match messages by rules of arbitrary specificity.</p>
  <p>A message-matching rule, represented by <a 
  href="pology.misc.rules.Rule-class.html" class="link">Rule</a> object, is
  a series of pattern matches to be applied to the message, leading to the 
  decision of whether or not the rule as whole matches the message. 
  Patterns can be of different kinds, act on different parts of the 
  message, and be applied in a boolean-like combinations. The idea behind 
  rules is to detect messages faulty in some way, hence when a rule matches
  it is said that it &quot;fails the message&quot;, and when it does not 
  match, that it &quot;passes the message&quot;.</p>
  <p><a href="pology.misc.rules.Rule-class.html" class="link">Rule</a> 
  objects can be constructed by the same code that uses them, but the 
  primary intended use is that of maintaining collections of rules in 
  external, special-format files, and loading them on demand. For example, 
  there may be a collection of rules that catches typical ortography errors
  in a given language, or checks terminology, etc. Such collections of 
  language and translation-environment dependent rules are maintained 
  within Pology itself, in <code>l10n/&lt;lang&gt;/rules/</code> 
  directories.</p>
  <p>The <a href="pology.sieve.check_rules-module.html" 
  class="link">check-rules</a> sieve is normally used to apply rules to 
  messages in PO files, while in custom code function <a 
  href="pology.misc.rules-module.html#loadRulesFromFile" 
  class="link">loadRulesFromFile</a> can be used to load rules from an 
  arbitrary rule file, and <a 
  href="pology.misc.rules-module.html#loadRules" class="link">loadRules</a>
  to fetch rules from Pology's internal rule files.</p>
  <h1 class="heading">Rule Files</h1>
    <p>Rule files are kept simple, to facilitate easy editing without 
    verbose syntax getting in the way. Rule file has the following 
    layout:</p>
<pre class="literalblock">
   # Title of the rule collection.
   # Author name.
   # License.

   # Directives affecting all the rules.
   global-directive
   ...
   global-directive

   # Rule 1.
   trigger-pattern
   subdirective-1
   ...
   subdirective-n

   # Rule 2.
   trigger-pattern
   subdirective-1
   ...
   subdirective-n

   ...

   # End of rules
</pre>
    <p>An example rule, to fail a message when the original part contains 
    the word &quot;foo&quot; and the translation does not contain 
    &quot;bar&quot;, except in PO catalog &quot;qwyx&quot; where it should 
    contain &quot;baz&quot; instead, would be:</p>
<pre class="literalblock">
   # A contrieved example rule.
   {\bfoo}i
   valid msgstr=&quot;\bbar&quot;
   valid cat=&quot;qwyx&quot; msgstr=&quot;\bbaz&quot;
   hint=&quot;Translate 'foo' with 'bar' (only in qwyx.po use 'baz')&quot;
</pre>
    <p>The elements of a rule are detailed in the following.</p>
  <h1 class="heading">Trigger Pattern</h1>
    <p>Trigger pattern is a regular expression, which can be given within 
    curly or square brackets, <code>{...}</code> or <code>[...]</code>, if 
    the intention is to match the original or translation parts of the 
    message, respectively. Following the brackets there may the optional 
    match-modifier character <code>i</code>, which indicates 
    case-insensitive matching for <i>all</i> the patterns in the rule 
    (default is case-sensitive).</p>
    <p>This was the shorthand notation of the trigger pattern. The more 
    verbose notation is 
    <code>*&lt;part&gt;/&lt;regex&gt;/&lt;flags&gt;</code>, where for 
    separation instead of the slash (<code>/</code>) any other non-letter 
    character can be used consistently. This notation is needed when some 
    other part of the message except the original and translation is to be 
    matched, or when using brackets would cause balancing issues (e.g. when
    a closing curly bracket without the opening one is a part of the match 
    for the original text). For all messages, <code>&lt;part&gt;</code> can
    be one of the keywords: <code>msgid</code>, <code>msgstr</code>, 
    <code>msgctxt</code>. E.g. <code>{\bfoo}i</code> is equivalent to 
    <code>*msgid/\bfoo/i</code>.</p>
    <p>For plural messages, <code>msgid/.../</code> (and conversely 
    <code>{...}</code> matches in either the <code>msgid</code> or 
    <code>msgid_plural</code> fields, whereas <code>msgstr</code> (and 
    <code>[...]</code>) in any of the <code>msgstr</code> fields. That is, 
    there is an implied boolean OR relationship when matching in 
    corresponding groups. If particular among these fields are wanted, the 
    following keywords can be used instead: <code>msgid_singular</code>, 
    <code>msgid_plural</code>, <code>msgstr_&lt;N&gt;</code>, where 
    <code>N</code> is a number corresponding to the index of 
    <code>msgstr</code> field.</p>
    <p>The trigger pattern is the main element of the rule; if it matches, 
    the message is by default considered failed by the rule. Tests that 
    follow in subdirectives are there to pass the message if additional 
    conditions are met.</p>
  <h1 class="heading">Subdirectives</h1>
    <p>There are several types of rule subdirectives. The main one is 
    <code>valid</code>, which provides additional tests to pass the 
    message. These tests are given by a list of 
    <code>name=&quot;pattern&quot;</code> entries, which test different 
    parts of the message and in different ways. For a <code>valid</code> 
    directive to pass the message all its tests must pass it, and if any of
    the <code>valid</code> directives passes the message, then the rule as 
    whole passes it. Effectively, this means the boolean AND relationship 
    within a directive, and OR across directives.</p>
    <p>The following tests can be used within <code>valid</code> 
    directives:</p>
    <ul>
      <li>
        <code>msgid</code>: passes if the original text matches a regular 
        expression
      </li>
      <li>
        <code>msgstr</code>: passes if the translation text matches a 
        regular expression
      </li>
      <li>
        <code>ctx</code>: passes if the message context matches a regular 
        expression
      </li>
      <li>
        <code>srcref</code>: passes if file path of one of the source 
        references matches a regular expression
      </li>
      <li>
        <code>comment</code>: passes if any extracted or translator comment
        line matches a regular expression
      </li>
      <li>
        <code>span</code>: passes if the part of the text matched by the 
        trigger pattern is matched by this regular expression as well
      </li>
      <li>
        <code>before</code>: passes if the part of the text matched by the 
        trigger pattern is placed exactly before the part matched by this 
        regular expression
      </li>
      <li>
        <code>after</code>: passes if the part of the text matched by the 
        trigger pattern is placed exactly after the part matched by this 
        regular expression
      </li>
      <li>
        <code>cat</code>: passes if the PO catalog name is contained in 
        this comma-separated list of catalog names
      </li>
      <li>
        <code>catrx</code>: passes if the PO catalog name matches a regular
        expression
      </li>
      <li>
        <code>env</code>: passes if the operating environment is contained 
        in this comma-separated list of environment names
      </li>
      <li>
        <code>head</code>: passes if the catalog header contains 
        field/value combination; the format is 
        <code>&lt;sep&gt;&lt;field&gt;&lt;sep&gt;&lt;value&gt;</code>, 
        where <code>&lt;sep&gt;</code> is an arbitrary separator character 
        used consistently at both positions, and <code>&lt;field&gt;</code>
        and <code>&lt;value&gt;</code> are regular expressions on field 
        name and value. Example: 
        <code>head=&quot;/Language.*/\bsr&quot;</code>
      </li>
    </ul>
    <p>Each test can be negated by prefixing it with exclamation sign, e.g.
    <code>!cat=&quot;foo,bar&quot;</code> will pass if catalog name is 
    neither <code>foo</code> nor <code>bar</code>. Tests are 
    short-circuiting, so it is good for performance to put simple string 
    matching rules (e.g. <code>cat</code>, <code>env</code>) before more 
    intensive regular expression ones (<code>msgid</code>, 
    <code>msgstr</code>, etc.) For <code>before</code> and 
    <code>after</code> tests, when there are several matched substrings, by
    the trigger pattern and/or by the test patterns, then the test passes 
    if any two are in the requested order.</p>
    <p>Subdirectives other than <code>valid</code> set states and 
    properties of the rule. The property directives are written simply as 
    <code>property=&quot;value&quot;</code>. These include:</p>
    <ul>
      <li>
        <code>hint</code>: hint which may be shown to the user when the 
        rule fails a message
      </li>
      <li>
        <code>id</code>: &quot;almost&quot; unique rule identifier (see 
        part on rule environments)
      </li>
    </ul>
    <p>State directives are given by the directive name, possibly followed 
    by keyword parameters: <code>directive arg1 ...</code>. These are:</p>
    <ul>
      <li>
        <code>validGroup &lt;groupname&gt;</code>: source a predefined 
        group of <code>valid</code> directives
      </li>
      <li>
        <code>environment &lt;envname&gt;</code>: explicitly set the 
        environment of the rule
      </li>
      <li>
        c{disabled}: disable the rule, i.e. make it pass all messages
      </li>
    </ul>
  <h1 class="heading">Global Directives</h1>
    <p>Global directives are typically placed at the beginning of a rule 
    file, before any rules, and are used to define common elements for 
    rules to source, or to set state for all rules below them. Global 
    directives can also be placed in the middle of the rule file, between 
    two rules, when they affect all the rules that follow.</p>
    <p>One global directive is <code>validGroup</code>, which defines 
    common groups of <code>valid</code> directives, which can be sourced by
    any rule:</p>
<pre class="literalblock">
   # Global validity group.
   validGroup passIfQuoted
   valid after=&quot;&#8220;&quot; before=&quot;&#8221;&quot;
   valid after=&quot;&#8216;&quot; before=&quot;&#8217;&quot;

   ....

   # Rule X.
   {...}
   validGroup passIfQuoted
   valid ...
   ...

   # Rule Y.
   {...}
   validGroup passIfQuoted
   valid ...
   ...
</pre>
    <p>Another global directive is to set the specific environment for the 
    rules that follow (unless overriden with namesake rule 
    subdirective):</p>
<pre class="literalblock">
   # Global environment.
   environment FOO

   ...

   # Rule X, belongs to FOO.
   {...}
   ...

   # Rule Y, overrides to BAR.
   {...}
   environment BAR
   ...
</pre>
    <p>Files can be included into rule files using the <code>include</code>
    directive:</p>
<pre class="literalblock">
   include file=&quot;foo.something&quot;
</pre>
    <p>If the file to be included is a relative path, it is taken as 
    relative to the file which includes it. One rule file should not 
    include another (with <code>.rules</code> extension), as all rule files
    are sourced automatically. Instead, an inclusion file should contain a 
    subset of directives needed in several rule files, such as filter 
    sets.</p>
    <p>Global directives are also used to set filters to apply to messages 
    before the rules are matched; these directives are detailed below.</p>
  <h1 class="heading">Rule Environments</h1>
    <p>When there are no <code>environment</code> directives in a rule 
    file, either global or as subdirectives, then all rules loaded from it 
    are considered as being environment-agnostic. This comes into picture 
    when applying a rule, using <a 
    href="pology.misc.rules.Rule-class.html#process" 
    class="link">Rule.process</a> method, which may take <i>operating 
    environments</i> as argument. If operating environments are given and 
    the rule is environment-agnostic, it will operate on the message 
    ignoring those environments. However, if there was an 
    <code>environment</code> directive in the file which covered the rule, 
    i.e. the rule itself is environment-specific, then it will operate on 
    the message only if its environment matches one of the operating 
    environments, and otherwise it will pass the message 
    unconditionally.</p>
    <p>Rule environments are used to control application of rules between 
    diverse translation environments, where some rules may be common, some 
    may be somewhat common, and some not common at all. In such a scenario,
    common rules would be made environment-agnostic (i.e. not covered by an
    <code>environment</code> directive), while totally non-common rules 
    would be provided in separate rule files per environment, with one 
    global <code>environment</code> directive in each.</p>
    <p>The rules falling in between may be treated differently. Sometimes 
    it may be organizationally convenient to keep in a single file rules 
    from different environments, but still similar in some way; then the 
    environment can either be switched by a global directive in the middle 
    of the file, or rules may be given their own environment directives. At
    other times, the rules are wholly similar, needing only one or few 
    <code>valid</code> subdirectives different across environments; then 
    the <code>valid</code> directives for specific environments may be 
    started with the <code>env</code> test.</p>
    <p>When mixing environment-agnostic and environment-specific rules, the
    rule identifier, given by <code>id</code> property subdirective, plays 
    a special role. If an environment-specific rule has the same identifier
    as an environment-agnostic rule, and the operating environment is same 
    as that of the environment-specific rule, than <a 
    href="pology.misc.rules-module.html#loadRules" 
    class="link">loadRules</a> will &quot;shadow&quot; the 
    environment-agnostic rule, excluding it from its returned list of rules
    (if several environments are loaded, the last environment's, as given 
    by the parameter <code>envs</code>, rule with same identifier takes 
    precedence). This is used when there is a rule common to most 
    translation environments, except for one or few outliers -- the 
    outliers' rule and the common rule to be shadowed should be given same 
    identifiers.</p>
    <p>The <a href="pology.sieve.check_rules-module.html" 
    class="link">check-rules</a> sieve has the <code>env</code> parameter 
    to specify the operating environments, when it will apply the rules 
    according to previous passages. This means that if operating 
    environments are not specified, from sieve's point of view all 
    environment-specific rules are simply ignored.</p>
  <h1 class="heading">Message Filtering</h1>
    <p>It is frequently advantageous for a set of rules not to act on raw 
    text given by message fields, but on a suitably filtered variants. For 
    example, if rules are used for terminology checks, it would be good to 
    remove any markup from the text (e.g. for an <code>&lt;email&gt;</code>
    tag not to record as a real word missing proper translation).</p>
    <p>Filters sets are created by issuing global <code>addFilter*</code> 
    directives:</p>
<pre class="literalblock">
   # Remove XML-like tags.
   addFilterRegex match=&quot;&lt;.*?&gt;&quot; on=&quot;pmsgid,pmsgstr&quot;
   # Remove long command-line options.
   addFilterRegex match=&quot;--[\w-]+&quot; on=&quot;pmsgid,pmsgstr&quot;

   # Rule A will act on a message filtered by previous two directives.
   {...}
   ...

   # Remove function calls like foo(x, y).
   addFilterRegex match=&quot;\w+\(.*?\)&quot; on=&quot;pmsgid,pmsgstr&quot;

   # Rule B will act on a message filtered by previous three directives.
   {...}
   ...
</pre>
    <p>Filters are thus added cumulatively to the filter set, the current 
    set affecting all the rules beneath it. (Note that these examples are 
    only for illustration, there are more finely tuned filtering options to
    remove markup or literals such as command line options.) 
    <code>addFilter*</code> directive may also appear within a rule, when 
    it adds only to the filter set for that rule:</p>
<pre class="literalblock">
   # Rule C, with an additional filter just for itself.
   {...}
   addFilterRegex match=&quot;grep\(1\)&quot; on=&quot;pmsgstr&quot;
   ...

   # Rule D, sees only previous global filter additions.
   {...}
   ...
</pre>
    <p>Every filter directive must have the <code>on=</code> field, which 
    lists parts of the message or the rule to which the filter should 
    apply. In the examples above, <code>pmsgid</code> and 
    <code>pmsgstr</code> indicate that the filter applies <i>purely</i> to 
    msgid/msgstr, i.e. not taking into account rest of the message; in 
    comparison, <code>msgid</code> and <code>msgstr</code> would indicate 
    that filter applies to the same fields, but that it can also analyze 
    the rest of the message to decide its behavior. It depends on the 
    filter directive which parts it can state in the <code>on=</code> 
    field.</p>
    <p>To remove a filter from the current set, the addition directive can 
    give filter a <i>handle</i>, which is then given to the 
    <code>removeField</code> directive to remove a filter:</p>
<pre class="literalblock">
   addFilterRegex match=&quot;&lt;.*?&gt;&quot; on=&quot;pmsgid,pmsgstr&quot; handle=&quot;tags&quot;

   # Rule A, &quot;tags&quot; filter applies to it.
   {...}
   ...

   # Rule B, removes &quot;tags&quot; filter only for itself.
   {...}
   removeFilter handle=&quot;tags&quot;
   ...

   # Rule C, &quot;tags&quot; filter applies to it again.
   {...}
   ...

   removeFilter handle=&quot;tags&quot;

   # Rule D, &quot;tags&quot; filter does not apply to it and any following rule.
   {...}
   ...
</pre>
    <p>Several filters may have the same handle, in which case a remove 
    directive removes them all from the current set. One filter can have 
    several handles, given by comma-separated in <code>handle=</code> 
    field, in which case it can be removed by any of those handles. 
    Likewise, <code>handle=</code> field in remove directive can state 
    several handles by which to remove filters. A remove directive within a
    rule influences the complete rule regardless of where it is positioned 
    (e.g. between two validity directives).</p>
    <p>To completely clear filter set, <code>clearFilters</code> directive 
    is used, without any fields. Like <code>removeFilter</code>, it can be 
    issued either globally, or within a rule.</p>
    <p>Parts of the message and the rule to which the filter may apply in 
    general (whereas the precise applicable subset depends on the filter 
    type), given by a comma-separate list in the <code>on=</code> field, 
    are:</p>
    <ul>
      <li>
        <code>msg</code>: filter applies to the complete message
      </li>
      <li>
        <code>msgid</code>: modifies only original fields 
        (<code>msgid</code>, <code>msgid_plural</code>), but the precise 
        behavior may depend on other parts of the message, e.g. on the 
        presence of <code>*-format</code> flags.
      </li>
      <li>
        <code>msgstr</code>: modifies only translation fields 
        (<code>msgstr</code> set), possibly depending on other parts of the
        mesage
      </li>
      <li>
        <code>pmsgid</code>: modifies only original fields, without 
        considering other parts of the message
      </li>
      <li>
        <code>pmsgstr</code>: modifies only translation fields, without 
        considering other parts of the message
      </li>
      <li>
        <code>pattern</code>: modifies all search patterns in the rule
      </li>
    </ul>
    <p>A filter may be added or removed only in certain environments, 
    specified by the <code>env=</code> field in <code>addFilter*</code> and
    <code>removeFilter</code> directives.</p>
    <p>The following filters are currently available:</p>
    <h2 class="heading"><code>addFilterRegex</code></h2>
      <p>Parts of the text to remove are determined by a regular 
      expression. The pattern is given by the <code>match=</code> field; if
      a replacement of the matched segment is wanted instead of full 
      removal, the <code>repl=</code> field may be used to specify the 
      replacement string (which can include back-references):</p>
<pre class="literalblock">
   # Replace %&lt;number&gt; format directives with a tilde in translation.
   addFilterRegex match=&quot;%\d+&quot; repl=&quot;~&quot; on=&quot;pmsgstr&quot;
</pre>
      <p>Case-sensitivity of matching can be controlled by 
      <code>casesens=</code> field, see <a 
      href="pology.misc.config-module.html#strbool" 
      class="link">strbool</a> for boolean-like values it can use. By 
      default, matching is case-sensitive.</p>
      <p>Applicable to <code>pmsgid</code>, <code>pmsgstr</code>, and 
      <code>pattern</code> parts.</p>
    <h2 class="heading"><code>addFilterHook</code></h2>
      <p>Hooks are functions with special signatures, defined in the 
      submodules of <a href="pology.hook-module.html" 
      class="link">pology.hook</a> module. The hook function to use is 
      specified by the <code>name=</code> field, the specification taking 
      the form of <code>[lang:]hook-module[/hook-function]</code>; optional
      <code>lang</code> is given when the hook is language specific, in one
      of the <code>pology.l10n.&lt;lang&gt;.hook</code> modules, and 
      <code>hook-function</code> when the function name in the hook module 
      is not equal to module name. For example, to remove accelerator 
      markers from GUI POs, possibly based on what each PO itself states 
      the marker character to be, the following hook filter can be 
      used:</p>
<pre class="literalblock">
   addFilterHook name=&quot;remove-subs/remove-accel-msg&quot; on=&quot;msg&quot;
</pre>
      <p>(see <a 
      href="pology.hook.remove_subs-module.html#remove_accel_text" 
      class="link">pology.hook.remove_subs.remove_accel_text</a> for 
      details).</p>
      <p>It depends on the hook type to which parts of the message it can 
      apply. Hooks of type F4A (<code>(msg, cat) -&gt; numerr</code>) must 
      apply to <code>msg</code>, whereas F3A (<code>(text, msg, cat) -&gt; 
      text</code>) can apply to <code>msgid</code> and <code>msgstr</code>;
      F3B and F3C hooks should be applied only to <code>msgid</code> or 
      <code>msgstr</code>, respectively, to satisfy their type 
      restrictions. Pure text hooks F1A (<code>(text) -&gt; text</code>) 
      apply to <code>pmsgid</code>, <code>pmsgstr</code>, and 
      <code>pattern</code>.</p>
      <p>Aside from hook functions, a hook module may provide <i>hook 
      factories</i> used to parametrize hook functions. Factory arguments 
      can be given by the <code>factory=</code> field, in the same form as 
      they would be written when calling the factory from the code:</p>
<pre class="literalblock">
   addFilterHook name=&quot;remove-subs/remove-fmtdirs-msg-tick&quot; \
                 factory=&quot;'~'&quot; on=&quot;msg&quot;
</pre>
      <p>(see <a 
      href="pology.hook.remove_subs-module.html#remove_fmtdirs_msg_tick" 
      class="link">pology.hook.remove_subs.remove_fmtdirs_msg_tick</a> for 
      details).</p>
    <h2 class="heading">Cost of Filtering</h2>
      <p>Filtering may be time expensive, and it normally is in real-life 
      uses. Therefore the implementation will try to assemble as little 
      filter sets as necessary, judging by their signatures -- a hash of 
      ordering, type, and fields of filters in the current set for a rule. 
      Likewise, <a href="pology.sieve.check_rules-module.html" 
      class="link">check-rules</a> will apply one filter set only once per 
      message, distributing the appropriate filtered message to a given 
      rule.</p>
      <p>This means that you should be conservative when adding and 
      removing filters, such to produce as little sets as really necessary.
      For example, you may know that filters P and Q can be applied in any 
      order, and in one rule file give P followed by Q, but in another Q 
      followed by P. However, the implementation cannot know that the 
      ordering does not matter, so it will create two filter sets, and 
      waste twice as much time in filtering.</p>
      <p>For big filter sets which are needed in several rule files, it may
      be best to split them out in a separate file and use 
      <code>include</code> directive to include them into rule files.</p>
  <h1 class="heading">Special Triggers</h1>
    <p>Regular expression matching of message fields is most of the time 
    sufficient as a trigger, and hence has the two succint notations 
    provided. But there are other trigger options, applicable like standard
    directives, in the form of <code>*&lt;trigger_type&gt; 
    &lt;field1&gt;=&quot;&lt;value1&gt;&quot;...</code>.</p>
    <p>Every trigger can be given the field <code>casesens=</code>, to 
    control case-sensitivity of pattern matching both in the trigger itself
    (if applicable), and in other patterns in the rule (validity tests). 
    See <a href="pology.misc.config-module.html#strbool" 
    class="link">strbool</a> for boolean-like values that can be used. By 
    default, matching is case-sensitive.</p>
    <h2 class="heading"><code>hook</code></h2>
      <p>Like for filtering, a hook can serve as the rule trigger too. It 
      is specified exactly like in the <code>addFilterHook</code> 
      directive, with <code>name=</code>, <code>factory=</code>, and 
      <code>on=</code> fields having the same meaning. The difference is in
      the type of hooks which are applicable in this context, which must be
      one of the validation types: V4A (<code>(msg, cat) -&gt; 
      parts</code>) applies to <code>msg</code> part as given by the 
      <code>on=</code> field), V3A (<code>(text, msg, cat) -&gt; 
      spans</code>) applies to either <code>msgid</code> or 
      <code>msgstr</code>, V3B and V3C to strictly <code>msgid</code> or 
      <code>msgstr</code>, respectively, and V1A (<code>(text) -&gt; 
      spans</code>) to <code>pmsgid</code> or <code>pmsgstr</code>. Also 
      unlike with filter hooks, <code>on=</code> field can state only one 
      message part to apply the validation hook to, not a comma-separated 
      list.</p>
      <p>An example rule with a test hook as the trigger would be:</p>
<pre class="literalblock">
   *hook name=&quot;ui-references/check-ui&quot; on=&quot;msgstr&quot;
   id=&quot;check-ui-refs&quot;
   hint=&quot;some UI references cannot be validated&quot;
</pre>
      <p>(see <a href="pology.hook.ui_references-module.html#check_ui" 
      class="link">hook.ui_references.check_ui</a> for details).</p>
  <h1 class="heading">Quoting and Escaping</h1>
    <p>Similar as with the verbose notation for the trigger pattern, any 
    quoted value may consistently use any other character other than the 
    double quote (single quote, slash, etc.) Literal quote inside the value
    can also be escaped using the backslash. The values of fields that are 
    regular expressions are sent to the regular expression engine without 
    resolving any escape sequences other than for the quote character 
    itself.</p>
    <p>A line is continued by a backslash in the last column.</p>

<hr />
<div class="fields">      <p><strong>Author:</strong>
        S&#233;bastien Renard &lt;sebastien.renard@digitalfox.org&gt;
      </p>
      <p><strong>License:</strong>
        GPLv3
      </p>
</div><!-- ==================== CLASSES ==================== -->
<a name="section-Classes"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Classes</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a href="pology.misc.rules.Rule-class.html" class="summary-name">Rule</a><br />
      Represent a single rule
    </td>
  </tr>
</table>
<!-- ==================== FUNCTIONS ==================== -->
<a name="section-Functions"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Functions</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pology.misc.rules-module.html#printStat" class="summary-sig-name">printStat</a>(<span class="summary-sig-arg">rules</span>)</span><br />
      Print rules match statistics</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pology.misc.rules-module.html#loadRules" class="summary-sig-name">loadRules</a>(<span class="summary-sig-arg">lang</span>,
        <span class="summary-sig-arg">stat</span>,
        <span class="summary-sig-arg">envs</span>=<span class="summary-sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="summary-sig-arg">envOnly</span>=<span class="summary-sig-default">False</span>,
        <span class="summary-sig-arg">ruleFiles</span>=<span class="summary-sig-default">None</span>)</span><br />
      Load rules for a given language</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
      <table width="100%" cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td><span class="summary-sig"><a href="pology.misc.rules-module.html#loadRulesFromFile" class="summary-sig-name">loadRulesFromFile</a>(<span class="summary-sig-arg">filePath</span>,
        <span class="summary-sig-arg">stat</span>,
        <span class="summary-sig-arg">envs</span>=<span class="summary-sig-default"><code class="variable-group">set([</code><code class="variable-group">])</code></span>,
        <span class="summary-sig-arg">seenMsgFilters</span>=<span class="summary-sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>)</span><br />
      Load rule file and return list of Rule objects</td>
          <td align="right" valign="top">
            
            
          </td>
        </tr>
      </table>
      
    </td>
  </tr>
</table>
<!-- ==================== VARIABLES ==================== -->
<a name="section-Variables"></a>
<table class="summary" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Variables</span></td>
</tr>
<tr>
    <td width="15%" align="right" valign="top" class="summary">
      <span class="summary-type">&nbsp;</span>
    </td><td class="summary">
        <a name="TIMEOUT"></a><span class="summary-name">TIMEOUT</span> = <code title="8">8</code>
    </td>
  </tr>
</table>
<!-- ==================== FUNCTION DETAILS ==================== -->
<a name="section-FunctionDetails"></a>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr bgcolor="#70b0f0" class="table-header">
  <td align="left" colspan="2" class="table-header">
    <span class="table-header">Function Details</span></td>
</tr>
</table>
<a name="printStat"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">printStat</span>(<span class="sig-arg">rules</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Print rules match statistics</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>rules</code></strong> - list of rule files</li>
    </ul></dd>
  </dl>
</td></tr></table>
</div>
<a name="loadRules"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">loadRules</span>(<span class="sig-arg">lang</span>,
        <span class="sig-arg">stat</span>,
        <span class="sig-arg">envs</span>=<span class="sig-default"><code class="variable-group">[</code><code class="variable-group">]</code></span>,
        <span class="sig-arg">envOnly</span>=<span class="sig-default">False</span>,
        <span class="sig-arg">ruleFiles</span>=<span class="sig-default">None</span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Load rules for a given language</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>lang</code></strong> - lang as a string in two caracter (i.e. fr). If none or empty, try
          to autodetect language</li>
        <li><strong class="pname"><code>stat</code></strong> - stat is a boolean to indicate if rule should gather count and 
          time execution</li>
        <li><strong class="pname"><code>envs</code></strong> - also load rules applicable in these environments</li>
        <li><strong class="pname"><code>envOnly</code></strong> - load only rules applicable in given environments</li>
        <li><strong class="pname"><code>ruleFiles</code></strong> - a list of rule files to load instead of internal</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>list of rules objects or None if rules cannot be found (with 
          complaints on stdout)</dd>
  </dl>
</td></tr></table>
</div>
<a name="loadRulesFromFile"></a>
<div>
<table class="details" border="1" cellpadding="3"
       cellspacing="0" width="100%" bgcolor="white">
<tr><td>
  <table width="100%" cellpadding="0" cellspacing="0" border="0">
  <tr valign="top"><td>
  <h3 class="epydoc"><span class="sig"><span class="sig-name">loadRulesFromFile</span>(<span class="sig-arg">filePath</span>,
        <span class="sig-arg">stat</span>,
        <span class="sig-arg">envs</span>=<span class="sig-default"><code class="variable-group">set([</code><code class="variable-group">])</code></span>,
        <span class="sig-arg">seenMsgFilters</span>=<span class="sig-default"><code class="variable-group">{</code><code class="variable-group">}</code></span>)</span>
  </h3>
  </td><td align="right" valign="top"
    >&nbsp;
    </td>
  </tr></table>
  
  <p>Load rule file and return list of Rule objects</p>
  <dl class="fields">
    <dt>Parameters:</dt>
    <dd><ul class="nomargin-top">
        <li><strong class="pname"><code>filePath</code></strong> - full path to rule file</li>
        <li><strong class="pname"><code>stat</code></strong> - stat is a boolean to indicate if rule should gather count and 
          time execution</li>
        <li><strong class="pname"><code>envs</code></strong> - environments in which the rules are to be applied</li>
        <li><strong class="pname"><code>seenMsgFilters</code></strong> - dictionary of previously encountered message filter functions, by
          their signatures; to avoid constructing same filters over 
          different files</li>
    </ul></dd>
    <dt>Returns:</dt>
        <dd>list of Rule object</dd>
  </dl>
</td></tr></table>
</div>
<br />
<!-- ==================== NAVIGATION BAR ==================== -->
<table class="navbar" border="0" width="100%" cellpadding="0"
       bgcolor="#a0c0ff" cellspacing="0">
  <tr valign="middle">
  <!-- Home link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="pology-module.html">Home</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Tree link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="module-tree.html">Trees</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Index link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="identifier-index.html">Indices</a>&nbsp;&nbsp;&nbsp;</th>

  <!-- Help link -->
      <th>&nbsp;&nbsp;&nbsp;<a
        href="help.html">Help</a>&nbsp;&nbsp;&nbsp;</th>

      <th class="navbar" width="100%"></th>
  </tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="100%%">
  <tr>
    <td align="left" class="footer">
    Generated by Epydoc 3.0.1
    </td>
    <td align="right" class="footer">
      <a target="mainFrame" href="http://epydoc.sourceforge.net"
        >http://epydoc.sourceforge.net</a>
    </td>
  </tr>
</table>

<script type="text/javascript">
  <!--
  // Private objects are initially displayed (because if
  // javascript is turned off then we want them to be
  // visible); but by default, we want to hide them.  So hide
  // them unless we have a cookie that says to show them.
  checkCookie();
  // -->
</script>
</body>
</html>
